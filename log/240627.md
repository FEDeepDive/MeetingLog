## 보경

### **CPU 스케줄링 정의**

- **CPU 스케줄링** : 어떤 프로그램에게 CPU 소유권을 줄 지 결정하는 알고리즘
- **CPU 스케줄러** : CPU 스케줄링을 수행하는 운영체제의 구성 요소

### **스케줄링의 단계**

- **고수준 스케줄링(장기 스케줄링)**
    
    시스템 내의 프로세스 수(멀티프로그래밍 정도)를 조절
    
- **중간수준 스케줄링(중기 스케줄링)**
    
    전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는 것
    
- **저수준 스케줄링(단기 스케줄링)**
    
    어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기상태로 보낼지 등을 결정하는 것
    

### 비선점형 알고리즘

- **FCFS 스케줄링(First Come First Service), 선입선출 스케줄링**
    - 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
    - 단점 : CPU를 오래 쓰는 프로세스가 먼저 도착하면 짧은 프로세스들이 다 기다려줘야 하므로 비효율적
- **SJF 스케줄링(Shortest Job First), 최단 작업 우선 스케줄링**
    - 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
    - 단점 : CPU 시간이 긴 서비스는 영원히 CPU를 못받을수도 있으며, CPU 사용시간을 미리 알 수없음
- **HRN 스케줄링(Highest Response Ratio Next), 최고 응답률 우선 스케줄링**
    - CPU를 할당 받기 위해 기다린 시간(대기 시간)과 CPU 사용 시간(서비스 시간)을 고려하여 프로세스의 응답 비율을 계산하여 응답 비율이 가장 높은 프로세스에게 CPU를 할당하는 방식

### 선점형 알고리즘

- **라운드 로빈 스케줄링(Round Robin, RR), 순환 순서 방식**
    - 한 프로세스가 할당받은 시간(time quantum) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    - 단점 : 퀀텀타임이 크면 FCFS, 너무 작으면 오버헤드 발생
- **SRTF 스케줄링(Shortest Remaining Time First), 최소 잔류 시간 우선 스케줄링**
    - 현재 수행중인 프로세스보다 더 짧은 작업이 준비큐에 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 선점형 방식
    - 단점 : 프로세스의 종료시간을 예측하기 어려우며, Starvation 발생
- **다단계 큐 스케줄링(Multilevel Queue)**
    - 스케줄링의 우선순위에 따라 준비 큐를 여러개 사용해 큐마다 다른 스케줄링 알고리즘을 적용하는 비선점형 방식
    - 단점 : 우선순위를 이용해 공평성에 위배되며 큐 간의 프로세스 이동이 안되므로 유연성이 떨어짐
- **다단계 피드백 큐 스케줄링(Multilevel Feedback Queue)**
    - 다단계 큐 스케줄링의 문제점을 보완한 방식으로 기본적 형태가 동일하지만, CPU를 사용하고 난 프로세스가 원래 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 삽입
    - 오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식

### 둘 다 허용되는 알고리즘

- **우선순위 스케줄링(Priority Scheduling)**
    - 프로세스의 중요도에 따라 우선순위를 반영하여 CPU를 할당하는 방식으로 선점형, 비선점형 둘다 구현 가능
    - 단점 : 우선순위 낮은애들은 영원히 CPU를 받지 못함(Starvation)
    - 해결법 : 우선순위가 낮아도 오래되면 우선순위를 높여줌(Aging)
    - **고정 우선순위 방식** : 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날때까지 바뀌지 않는 방식으로 구현하기 쉽지만 유연하지 못해 효율이 좋지 않음
    - **변동 우선순위 방식** : 프로젝트 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식으로 구현하기 어렵지만 효율성이 좋음

## 미림

# 3.4 CPU 스케줄링 알고리즘

- CPU 스케줄링: CPU는 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당함
- CPU 스케줄링 알고리즘의 목표
    - 높은 CPU 이용률 (=CPU의 유휴 시간을 최소화)
    - 단위 시간당 많은 처리량
    - 적은 대기 시간 (=프로세스가 준비 큐에서 대기하는 시간 최소화)
    - 짧은 응답 시간 (=프로세스가 요청한 후 CPU에 할당받기까지의 시간 최소화)
    - 공정성 (=특정 프로세스가 무한정 대기하지 않고 모든 프로세스가 CPU를 공평하게 씀)

### 비선점형 방식

강제로 프로세스를 중지하지 않고, 프로세스가 스스로 CPU 소유권을 포기하는 방식

- **FCFS(First Come, First Served)**
    - 가장 먼저 온 프로세스부터 처리
    - 프로세스가 처리되는 동안 기다려야 해서 대기 시간이 길어지는 문제
- **SJF(Shortest Job First)**
    - 처리 시간이 짧은 프로세스부터 처리 (과거 실행했던 시간을 토대로 처리 시간을 추측)
    - 처리 시간이 긴 프로세스가 무한정 대기하는 문제(starvation)
- **우선순위(Priority)**
    - 우선순위가 높은 프로세스부터 처리 (우선순위는 시스템 또는 사용자가 지정)
    - 우선순위가 낮은 프로세스가 무한정 대기하는 문제(starvation)
        - ⇒ 에이징(Aging): 오래 기다린 작업일수록 우선순위를 높여주는 방식
        - 책에서는 에이징을 `align`이라고 썼는데(p180), 처음 보는 말

### 선점형 방식

강제로 프로세스를 중지하고 다른 프로세스에 CPU 소유권을 할당하는 방식

- **라운드 로빈(RR, Round Robin)**
    - *현대 컴퓨터가 쓰는 스케줄링 방식*
    - 모든 프로세스에 동일한 시간을 주고 돌아가면서 처리
    - 할당 시간이 크면 FCFS가 되고, 작으면 컨텍스트 스위칭 비용이 커짐
    - 일반적으로 전체 작업 시간이 길어지나, 평균 응답 속도가 빠름
- **SRF(Shortest Remaining Time First)**
    - *SJF의 선점형 방식*
    - 처리 시간이 짧은 프로세스부터 처리 (현재 처리하는 프로세스보다 짧은 실행 시간을 갖는 프로세스가 도착하면, 현재 프로세스를 중지하고 새 프로세스를 수행)
- **다단계 큐(Multilevel Queue)**
    - 여러 큐가 각각 다른 스케줄링 알고리즘과 우선순위를 가지고 프로세스를 처리
    - 프로세스를 분리하여 각각의 특성에 맞는 스케줄링이 가능
    - 우선순위가 낮은 큐에 배치된 프로세스가 무한정 대기하는 문제(starvation)
    

## 정욱

## 4. CPU 스케줄링 알고리즘

### 스케줄링

어떤 시점에 어떤 작업을 위해 자원을 할당할 지 결정하는 것으로 다음과 같은 목적을 가진다.

| 이름 | 설명 |
| --- | --- |
| 공평성 | 특정 작업이 수행되지 않는 경우가 없도록 모든 작업이 공평하게 자원을 배정받아야 한다. |
| 효율성 | 시스템 자원이 유휴 시간을 가지지 않도록 효율적으로 사용되어야 한다. |
| 안정성 | 중요한 작업이 먼저 작동하도록 우선순위를 고려하여 시스템 자원을 점유하거나 파괴하려는 작업으로부터 보호해야 한다. |
| 확장성 | 작업 개수가 증가하더라도 시스템이 안정적으로 동작할 수 있도록 해야 한다. |
| 반응 시간 보장 | 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 보기 때문에, 시스템은 적절한 시간 내에 작업 요구에 반응해야 한다. |
| 무한 연기 방지 | 특정 작업에 대한 처리가 무한히 연기되지 않도록 해야 한다. |

컴퓨터 시스템에 있어 작업의 단위는 프로세스(또는 스레드)이며, 일반적으로 설명의 편의를 위해 프로세스를 작업의 단위로 정하는 경우가 많다. 프로세스 실행에 필수적인 자원은 CPU이기 때문에, 운영체제에서 스케줄링이라 하면 보통은 CPU에 대한 스케줄링을 의미한다. 스케줄링은 크게 **장기, 중기, 단기(또는 고수준, 중수준, 저수준 등)**의 세 가지로 나뉘며 각각의 차이는 다음과 같다.

| 단계 | 설명 |
| --- | --- |
| 단기 스케줄링(Short-term schedulling) | 일반적으로 PCB의 연결 리스트 형태로 구현되는 운영체제의 준비 큐에 있는 대기 상태 프로세스 중, 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정한다. |
| 중기 스케줄링(Mid-term schedulling) | 우선순위가 가장 낮거나 일정 시간 동안 활성화되지 않았던 프로세스를 보조 기억 장치로 내보내 메모리 내 적재된 프로세스의 수를 동적으로 조절한다. |
| 장기 스케줄링(Long-term schedulling) | 프로세스의 작업이 IO 위주인지 CPU 위주인지 판단하여, 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스의 균형을 조절한다. 멀티프로그래밍의 정도를 결정한다고도 하지만, 현대의 일반적인 사용자를 위한 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다고 한다. |

### 정책(Policy) vs. 작동 원리(Mechanism)

시스템 설계에 있어, **정책**과 **작동 원리**를 잘 분리하는 것이 중요하다. 정책은 상황에 따라 잘 변하는 가변적인 요소이기 때문에 서로 분리되지 않았다면 정책이 변할 때마다 작동 원리도 함께 변해야 한다. 예를 들어, 자원 할당을 제어하는 작동 원리가 어떤 자원을 할당할 지에 대한 정책을 결정하면 안 된다.

| 정책 | 작동 원리 |
| --- | --- |
| 어떠한 종류의 결정을 하기 위한 알고리즘 | 필요한 기능을 실제로 구현하기 위한 저수준의 방법 또는 프로토콜 |

CPU 스케줄링의 경우, 주어진 CPU에서 실행 중이던 프로그램을 멈추고 다른 프로그램을 실행하기 위해 **문맥 교환**이라는 작동 원리를 가지고 있으며 이를 이용하는 방식으로 여러 가지 정책들을 채택할 수 있다.

### 단기 스케줄링

스케줄링의 여러 가지 목적 달성 여부를 판단하기 위해, CPU 스케줄링 알고리즘을 평가할 때 사용하는 척도는 다음과 같다.

| 척도명 | 설명 |
| --- | --- |
| 사용률(Utilization) | CPU가 작업을 수행하는 동안 실제로 사용되는 시간의 비율.  |
| 처리량(Throughput) | 단위 시간 당 실행한 프로세스 수 |
| 응답 시간(Response Time) | 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간 |
| 반환 시간(Turnaround Time) | 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간 |
| 대기 시간(Latency) | 프로세스가 대기 큐(Wait Queue)에서 대기하는 시간의 총합 |

<aside>
💡 **대기 큐(Wait Queue)**: 실행을 위해 필요한 시스템 자원을 할당받기 위해 대기하는 프로세스들을 관리하기 위한 자료구조. 프로세스 동기화 방법인 세마포어에서도 쓰이는 개념이다.

</aside>

### 기아 상태(Starvation)

**자원이 사용 가능해도** 여러 가지 이유로 인해 특정 프로세스가 낮은 **우선순위**를 배정받아 원하는 자원을 계속 할당받지 못하는 상태를 뜻한다. 스케줄링의 목적 중 하나인 **무한 연기 방지**가 제대로 지켜지지 못했다는 것을 의미한다.

<aside>
💡 교착 상태(Deadlock)과 혼동할 수 있지만, 교착 상태는 **사용 불가능한 자원**의 할당을 기다리는 상태이기 때문에 명백히 구분된다.

</aside>

### 선점형(Preemptive) 스케줄링 알고리즘

스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있는 알고리즘이다.

| 주요 선점형 스케줄링 알고리즘 | 설명 |
| --- | --- |
| RR(Round Robin) | 프로세스 간 우선순위가 없으며, 프로세스를 단위 시간 동안 실행한 후 할당된 시간 초과 시 순서대로 다른 프로세스를 실행한다. 문맥 교환이 빈번하게 일어나 오버헤드가 크지만 모든 프로세스의 수행이 보장될 수 있으며 각 프로세스의 응답 속도가 빠르다. |
| SRTF(Shortest Remaining Time First) | 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행한다. 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 해당 프로세스가 CPU를 할당받는다. 평균 대기 시간이 짧지만 실행 시간이 긴 프로세스는 기아 상태가 되기 쉽다. |

### 비선점형(Non-preemtive, cooperative) 스케줄링 알고리즘

실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없는 알고리즘이다.

| 주요 비선점형 스케줄링 알고리즘 | 설명 |
| --- | --- |
| FCFS(First Come First Serve) / FIFO(First In First Out) | 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는다.  |
| SJF(Shortest Job First) / SJN(Shortest Job Next) | 실행 시간이 짧은 프로세스가 우선순위를 갖는다. 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 제일 짧은 프로세스부터 실행한다. 평균 대기 시간이 짧지만 기아 상태의 프로세스가 생길 수 있다. |
| HRRN(Highest Response Ratio Next) | 실행 시간이 긴 작업과 짧은 작업 간의 지나친 불평등을 해소하기 위해 대기 시간을 동시에 고려한다. |

### 번외: [React Scheduler](https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js)

React 18 이전에는 모든 갱신이 도중에 중단될 수 없는 하나의 렌더링을 통해 반영되었으며, 렌더링은 동기적으로 이루어졌다. React 18부터는 [Fiber](https://github.com/facebook/react/blob/133ada72549b9aa01a0bc3df2b1c9bb341e861fd/packages/react-reconciler/src/ReactInternalTypes.js#L83)라는 [작업 단위로 수행](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2374)하며, Fiber는 [스케줄러](https://github.com/facebook/react/blob/d878489431e2c6cf69982b51403f8e1f68f4e73d/packages/react-reconciler/src/ReactFiberRootScheduler.js#L265)를 통해 우선순위를 부여받는다. React의 스케줄러는 [최소 힙](https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerMinHeap.js)을 이용하여 구현한 [우선순위](https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerPriorities.js) 큐를 통해 Fiber의 실행 순서를 정한다. 또한 [단위 시간 동안 작업을 수행 후 제어를 협조적으로 넘겨주는](https://github.com/facebook/react/blob/d878489431e2c6cf69982b51403f8e1f68f4e73d/packages/scheduler/src/forks/Scheduler.js#L458) 비선점형 스케줄링을 채택했다.

## 영은

### CPU 스케줄링 알고리즘

운영체제가 여러 프로세스를 효율적으로 처리하기 위해 사용하는 다양한 전략

### 비선점형(Non-preemptive) 스케줄링 알고리즘

현재 실행 중인 프로세스가 자발적으로 CPU를 반환할 때까지 다른 프로세스가 CPU를 사용할 수 없는 방식

| 알고리즘 | 개념 | 장점 | 단점 |
| --- | --- | --- | --- |
| First-Come, First-Served (FCFS) | 도착 순서대로 CPU 할당 | 구현이 간단, 공정하게 보임 | 긴 대기 시간, Convoy effect |
| Shortest Job First (SJF) | 실행 시간이 가장 짧은 프로세스에 CPU 할당 | 평균 대기 시간 최소화 | 실행 시간을 미리 알아야 함, 기아 현상 |
| Priority Scheduling (우선순위) | 우선순위가 높은 프로세스에 CPU 할당 | 중요한 작업 우선 처리 | 기아 현상, 우선순위 결정 어려움 |

### 선점형(Preemptive) 스케줄링 알고리즘

현재 실행 중인 프로세스를 중단하고, 다른 프로세스에 CPU를 할당할 수 있는 방식 - 현대 쓰는 방식

| 알고리즘 | 개념 | 장점 | 단점 |
| --- | --- | --- | --- |
| Shortest Remaining Time (SRT) | 남은 실행 시간이 가장 짧은 프로세스에 CPU 할당 | 평균 대기 시간 최소화 | 실행 시간을 미리 알아야 함, 컨텍스트 스위칭 오버헤드 |
| Priority Scheduling (선점형) | 더 높은 우선순위의 프로세스가 도착하면 CPU 할당 | 중요한 작업 우선 처리 | 기아 현상, 컨텍스트 스위칭 오버헤드 |
| Round Robin (RR) | 고정된 시간 단위 동안 프로세스에 CPU 할당 | 공정하게 CPU 할당, 반응 시간 예측 가능 | 타임 슬라이스 설정 어려움, 컨텍스트 스위칭 오버헤드 |
| Multilevel Queue Scheduling | 프로세스를 여러 큐로 분류, 각 큐에 다른 스케줄링 적용 | 다양한 작업 효율적 관리 | 큐와 정책 설정 복잡 |
| Multilevel Feedback Queue | 프로세스가 여러 큐 사이를 이동, 우선순위가 변함 | 유연하고 반응성 뛰어남 | 설정과 튜닝 복잡 |