## 보경

## 1. 자바스크립트 엔진

**자바스크립트 엔진이란 ?**

자바스크립트 코드를 실행하는 인터프리터로 웹 브라우저에서 사용된다.

**V8이란 ?**

- 구글에서 만들어진 엔진으로 C++로 작성되었다.
- Chrome과 Node.js에서 사용하며 멀티쓰레드로 동작한다.
- 그 밖의 애플 사의 JavaScript Core(Safari, RN사용)와 마이크로소프트 사의 Chakra(익스플로러, Edge사용)등의 자바스크립트 엔진이 있다.

**V8의 동작 원리**

1. **토크나이저(Tokenizer)/파서(Parser)**
   - 토크나이징(Tokenizing) : 자바스크립트 코드를 분석하여 ‘의미를 갖는 최소 단위’인 토큰(Token)으로 분해하는 과정
   - 파싱(Parsing) : 분해한 ‘토큰’들을 분석하여, 문법적으로 의미를 갖는 AST 생성
2. **Ignition 인터프리터**
   - Ignition라는 인터프리터에 파싱된 결과물인 AST를 전달하고 이를 **ByteCode**로 변환하여 실행
   - Ignition 의 3가지 장점
     1. **메모리 사용량 감소 :** 기계어로 보다 바이트 코드로 컴파일 하는것이 메모리가 적게 소모됨
     2. **파싱 시 오버헤드 감소 :** 바이트 코드는 간결하기 때문에 다시 파싱하기도 편하다.
     3. **컴파일 파이프 라인의 복잡성 감소 :** **`Optimizing`**이든 **`Deoptimizing`**이든 바이트 코드 하나만 생각하면 되기 때문에 편하다.
3. **TuroboFan JIT 컴파일러**
   - 인터프리팅 된 ByteCode를 최적화 하기 위해 **TuroboFan JIT 컴파일러**를 사용한다.
   - 자주 사용되는 코드는 TurboFan 으로 보내줘서 **`Optimized Machine Code`**, 즉 최적화된 코드로 다시 컴파일된다. 그러다가 다시 사용이 덜 된다 싶으면 **`Deoptimizing`** 하기도 한다.
   - TurboFan은 얼마나 자주 호출되는지, 인터프리팅된 바이트 코드의 길이가 특정 임계점을 높는지 아닌지등 내부적인 조건을 최적화 될 코드를 선별한다.

**V8의 최적화 기법**

- 히든클래스/인라인캐싱 정리안된내용(추후정리예정)
  https://ui.toast.com/posts/ko_20210909
  https://www.nextree.io/javascript-engine/
  https://oliveyoung.tech/blog/2023-10-28/oliveyoung-javascript-turbofan/
- Hidden Class(히든클래스) : 비슷한놈들 가져다 놓고 쓰는거
- Inline Cashing(인라인 캐싱) : 캐싱해주는거

**자바스크립트 엔진의 동작 원리를 고려하여 성능 좋은 자바스크립트 코드를 작성하는법**

- C나 Java 처럼 정적 타이핑 언어로 생각하며 코드를 작성한다.
- 하나의 배열에는 하나의 타입만 넣어준다.
- 잘 짜여진 JS코드는 C++에 근사한 성능을 낼 수 있다고 한다.
- 정리안된내용(추후정리예정)
  1. 객체 속성의 순서 : hidden class와 최적화된 코드가 공유될 수 있게 하기 위해서 객체의 속성값 초기화는 모두 같은 순으로 한다.
  2. 동적 요소 : 객체의 초기화 이후에 속성을 추가하는 것은 hidden class 가 이미 최적화된 상태에서 변화하는 것이기 때문에 성능 저하를 야기할 수 있다. 따라서 생성자에서 객체의 속성을 정의하는 것이 좋다.
  3. 메소드 : 같은 메소드를 호출하는 코드는 서로 다른 메소드를 호출하는 코드보다 더 빠르게 수행될 것이다. (inline caching으로 인해)
  4. 배열 : key가 증가하는 숫자가 아닌 sparse array는 피하라. 안에 요소가 없는 sparse 배열은 hash table이다. 그런 배열에 접근하는 것은 비용이 더 많이 든다. 마찬가지로 배열의 요소를 삭제하지 말라. 이건 key sparse를 만든다. 또한, 미리 큰 배열을 할당해놓는 것도 좋지 않다.
  5. tagged 값 : V8은 객체와 숫자들을 32 비트로 표현한다. 그것이 객체인지(flag = 1), 정수인지(flag =0) 나타내기 위해 SMI라고 부르는 1 비트를 사용한다. 그리고, 숫자의 값이 31비트보다 크다면 숫자를 double로 만든 후 숫자를 저장하기 위한 새로운 객체를 만든다. 따라서 이러한 boxing operation을 줄이기 위해 31 bit signed number를 사용하는 것이 좋다.

**자바스크립트 엔진의 구성요소**

자바스크립트 엔진은 콜스택(실행 컨택스트 스택)과 메모리 힙으로 이루어져 있으며 콜스택에 맞게 요청된 작업을 순차적으로 진행한다.

## **2. 자바스크립트 런타임 환경**

자바스크립트 런타임 환경이란 자바스크립트로 만든 프로그램이 실행되는 환경을 의미한다. 자바스크립트 런타임은 자바스크립트 엔진, Web API, Task Queue(Microtask Queue, Animation Frames) \*\*\*\*, EventLoop, RenderingEngine 으로 이루어져 있다.

**자바스크립트 엔진**

- 자바스크립트 코드를 해석하고 실행하는 역할을 하며 메모리 힙과 콜 스택 두개의 컴포넌트로 구성된다.
- **콜 스택(call stack)**
  - 실행컨텍스트(함수의 실행순서)가 쌓이는 스택.
  - 원시타입 데이터와 메모리 힙의 주소값의 식별자 값이 저장된다.
- **메모리 힙(memory heap)**
  - 객체가 저장되는 메모리 공간. 즉 메모리 할당이 일어나는 곳.
  - 이 때 참조타입의 데이터가 저장됨
  - 참조타입 데이터가 저장된 메모리힙의 주소값은 콜스택의 변수 식별자의 값으로 각각 저장됨
  - 콜스택에 할당되는 변수 식별자 자체는 콜스택 상의 **실행 컨텍스트(Execution Context)의 렉시컬 환경(Lexical Environment) 라는 곳에 저장**됨

**Web APIs**

- 브라우저 환경에서 비동기 작업을 처리하기위해 제공되는 API들이다.
- 네트워크 요청, 타이머 설정, DOM 조작 및 이벤트 처리 메서드를 제공한다.(ex. **setTimeout, fetch, XMLHttpRequest, addEventListener)**
- Node.js 의 경우 Web API가 아닌 C++ binding과 thread pool로 이루어져 있다.

**Task Queue(Callback Queue, Event Queue, Macrotask Queue)**

- setTimeout(), setInterval(), setImmediate()와 같은 함수에 등록된 콜백이 보관되는 큐
- Web APIs를 한번 거쳐서 오는 콜백은 Task Queue로 등록됨(궁예)

**Microtask Queue**

- Promise나 async/await, process.nextTick, Object.observe, MutationObserver 등 프로미스나 옵저버에 등록된 콜백이 보관되는 큐
- JS 문법에 관련된 콜백은 Microtask Queue 내부로 들어옴(궁예)

**Animation Frames**

- requestAnimationFrame() 과 같이 브라우저 렌더링과 관련된 함수에 등록된 콜백이 보관되는 큐
- 우선순위는 Microtask보다는 낮고, (Macro)Task보다는 높다.

**[Event Loop](https://helloinyong.tistory.com/291)(링크 클릭시 이벤트 루프의 5단계를 볼수있다.~~)~~**

- 이벤트 루프는 자바스크립트의 비동기 동작을 관리하는 핵심 매커니즘 중 하나이다.
- 태스크 큐와 콜 스택을 돌면서 현재 실행중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러)가 있는지 반복하며 확인한다.
- 이벤트 루프는 **Microtask Queue -> Animation Frames -> Task Queue** 순으로 task를 수행한다.
- 이벤트 루프는 Microtask Queue나 Animation Frames를 방문할 때는, 큐 안에 있는 **모든 작업들을 수행**하지만, Task Queue를 방문할 때는 **한 번에 하나의 작업**만 call stack으로 전달하고 다른 Queue를 순회한다.
- 이벤트 루프는 왜 콜스택이 비어있을때만 태스크 큐의 함수들을 옮겨줄까 ?
  - 만약 콜스택이 비어있지 않을때 태스크를 넘겨주면 멀티스레드에서 발생하는 문제를 똑같이 안게 된다. 동기화 문제를 해결해야됨 그래서 **JS가 단일 스레드 언어라는 것을 보장해주기 위해서** 반드시 콜 스택이 비어있을때만 데이터 전달한다.

**RenderingEngine**

- 렌더링, 브라우저, 레이아웃 단어 그대로 웹 페이지에 대한 컨텐츠 및 데이터를 위해 동작하는 엔진

## **3. 비동기 프로그래밍**

자바스크립트 엔진은 단 하나의 콜 스택(실행컨텍스트 스택)을 갖기 때문에 기본적으로는 동기식에 싱글 스레드로 동작한다. 하지만 실제로 자바스크립트의 작동은 웹 브라우저나 node.js같은 멀티 스레드 환경에 임베디드 되어 실행되기 때문에 자바스크립트는 비동기 프로그래밍이 가능하고 블로킹이 발생하지 않으며 멀티스레드인 것처럼 동작한다.

## 4. 실행 컨텍스트

자바스크립트 엔진은 소스코드를 2개의 과정, '소스코드의 평가'와 '소스코드의 실행' 과정으로 나누어 처리한다.

- 소스코드의 평가 과정 : 실행 컨텍스트를 생성하고 문만 먼저 실행해서 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경레코드)에 등록해둔다.
- 소스코드의 실행 과정 : 문을 제외한 소스코드가 순차적으로 실행된다. 즉 런타임 된다. 이때 소스코드 실행에 필요한 정보는 실행컨텍스트에서 검색해 취득하고, 소스코드의 실행 결과는 실행컨텍스트가 관리하는 스코프에 등록된다.

**실행 컨택스트란 ?**

- 변수 이름을 비롯한 모든 식별자가 등록되는는곳으로 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
- 변수 객체, 스코프 체인, this 객체, 외부 환경(클로저 구현에 사용됨), 함수 매개변수, 함수/변수 선언 위치 정보, 스코프 종류(현재 컨텍스트가 함수 스코프인지, 전역 스코프인지), strict 모드 여부를 기록한다.
- 실행 컨텍스트는 자바스크립트 엔진이 코드를 실행할때 생성되며 스택으로 쌓이면서 관리됨.

**실행 컨텍스트 스택**

- 실행 컨텍스트를 관리하는 스택 자료구조로 코드의 실행 순서를 관리한다.
- 실행 컨텍스트 스택의 최상위 실행 컨텍스트는 언제나 현재 실행중인 코드의 실행 컨텍스트이다.

**렉시컬 환경**

- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조. 즉 스코프와 식별자를 관리한다.
- 렉시컬 환경은 **환경 레코드**와, **외부 렉시컬 환경에 대한 참조** 두개의 컴포넌트로 구성되어 있다.
- 렉시컬 스코프의 실체이다.

## 5. 스코프

**스코프**

식별자의 유효한 범위

**스코프 체인**

스코프가 중첩되어 있는 상황에서 스코프의 연결된 구조

**스코프 체이닝**

자바스크립트 엔진이 변수 및 함수를 검색할 때 발생하는 매커니즘. 현재 스코프에서 변수 또는 함수를 찾지 못하면 상위 스코프로 이동하여 변수를 찾아냄

**렉시컬 스코프**

자바스크립트에서 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정함

**블록 레벨 스코프 / 함수 레벨 스코프**

- 함수 레벨 스코프(Function-level Scope) : var
  함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level Scope) : let, const
  모든 코드 블록(함수,if문,for문,while문,try/catch문 등)내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

**JS의 가비지 컬렉션**

JS는 객체가 생성되었을 때 자동으로 메모리를 할당하고, 더이상 필요하지 않을때 자동으로 메모리를 해제한다.

**[JS 가비지 컬렉션 알고리즘](https://sambalim.tistory.com/154)**

- **Reference-Counting** : 메모리 할당과 메모리 해제가 한 블럭 이내에서 이뤄질 수 없는 경우. 단 두개의 객체가 서로 참조하는 순환 참조가 발생하면 레퍼런스 카운팅을 할 수 없다.
- **Mark-and-Sweep :** 부모로부터 자식까지 참조를 타면서 접근 불가능한 객체를 선별하여 가비지로 판단

**V8 엔진 메모리 구조**

- V8엔진의 힙 메모리는 객체와 동적 데이터가 저장되는 공간이자 가비지 컬렉션이 발생하는곳이다.

**메모리 누수**

- 추후정리예정
  - https://yceffort.kr/2020/07/memory-leaks-in-javascript
  - https://ui.toast.com/posts/ko_20210611

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.

JS의 배열은 해시 테이블로 구현된 특수한 객체이다. 참조타입의 데이터는 메모리 힙에 저장되기 때문에 push나 pop 등으로 저장된 값을 변경하더라도 메모리 힙의 주소값과 콜스택에 저장된 메모리힙의 주소값, 할당된 콜스택의 주소도 변경되지 않는다.

## 8. 호이스팅(hoisting)에 대해 설명해주세요

자바스크립트 엔진이 소스코드를 한 줄 씩 실행하기 전에 모든 선언문을 찾아서 스코프의 상단으로 이동시키는 과정을 의미한다.

## 미림

## 1. 자바스크립트 엔진의 동작 방법

### 자바스크립트 엔진이란?

- 자바스크립트 코드를 실행하는 프로그램 또는 인터프리터(해석&실행)
- 대표적으로 `Chrome`, `Node.js`에서 사용되는 `V8`이 있음

### 자바스크립트 엔진의 메모리 모델

- **콜스택(call stack)**: 호출된 코드의 실행 컨텍스트를 순서대로 저장하는 공간
- **힙(Heap)**: 값이 저장되는 메모리 공간

<aside>
💡 **모든 값은 타입에 관계 없이 힙에 allocate되며**(small integer 제외), 콜스택에 저장된 참조 포인터를 통해 힙 내 값에 접근할 수 있다.

</aside>

### 자바스크립트 코드가 실행되는 과정

- **파싱 (Parsing)**
  - parser가 코드 구문을 분석함 (Syntax Error를 확인하는 부분)
  - 구문 분석을 통해 코드를 **`추상 구문 트리(Abstract Syntax Tree, AST)`**로 변환
  - AST는 코드의 구조와 의미를 나타냄
- **컴파일 (Compilation)**
  - **실행 컨텍스트 생성** (‣)
    - `AST`를 바이트 코드/기계 코드로 컴파일한 후, 실행 컨텍스트를 생성함
    - `전역 실행 컨텍스트(GEC)` 생성 후 각 함수의 `함수 실행 컨텍스트(FEC)` 생성
- **실행 (Execution)**
  - 코드 호출 시 호출한 코드의 **실행 컨텍스트가 `call stack`에 `push`되고, 실행이 완료되면 `pop`됨**
  - `call stack`이 빌 때까지 반복
  - 실제로 변수에 값이 할당되는 단계
  - 비동기 관련 실행 과정은 “2. 이벤트 루프” 참고
- **최적화 (Optimization)**
  - 자주 실행되는 함수를 확인하고 이러한 함수를 최적화해 코드를 다시 컴파일함
  - JIT(Just-In-Time) 컴파일, 인라인 캐싱 등 최적화 기술 사용

## 2. 이벤트 루프

### **이벤트 루프**

- **`콜스택`과 `콜백 큐`를 모니터링하며, 태스크를 스케쥴링함**
  - 콜백함수를 `콜백 큐`로 이동시킴
  - `콜스택`이 비어있는지 확인(=`tick`)
  - `콜스택`이 비어있으면, `콜백 큐` 내 태스크를 꺼냄
    - 모든 `마이크로태스크`를 하나씩 순차적으로 꺼내 `콜스택`에 적재
    - `마이크로태스크 큐`가 비어있으면, `매크로태스크`를 하나 꺼내 `콜스택`에 적재
    - 주기마다 반복함
- 일이 없으면 잠듬 (=잠든 동안 CPU를 거의 안씀)

### Web APIs

- **브라우저에서 제공하는 Web API 집합**
  - `DOM`, `XMLHttpRequest`, `Timer API`, `Console API`, `Canvas API` 등 ([전체보기](https://developer.mozilla.org/en-US/docs/Web/API))
- **Web API에 의해 생성된 비동기 작업은 백그라운드에서 멀티 스레드로 처리됨**

  - 예시: `setTimeout(callback, 0)` 호출 시 비동기 작업(0ms 대기)이 생성됨
    ⇒ 백그라운드에서 0ms 대기
    ⇒ 타이머 만료 시 웹 브라우저 타이머 시스템에 의해 `callback`이 `콜백큐`에 추가됨
    <aside>
    💡 모든 Web API가 비동기적인 것은 아니다. `Console API`처럼 동기적으로 실행되는 Web API의 메서드는 메인 스레드의 `콜스택`에 쌓인다.

    </aside>

### 콜백 큐

- **비동기 작업과 연결된 콜백함수들이 `콜스택`에 적재되기 전에 대기하고 있는 공간**
- **`이벤트 루프`에 의해 `콜백 큐`의 태스크들이 실행됨**

| 태스크＼큐                    | 태스크 큐(Macro Task Queue)                           | 마이크로태스크 큐(Micro Task Queue)                |
| ----------------------------- | ----------------------------------------------------- | -------------------------------------------------- |
| 명칭                          | 태스크 or 매크로태스크                                | 마이크로태스크                                     |
| 대표 종류                     | 비동기 Web API 작업의 콜백                            | 프로미스 핸들러(then/catch/finally)의 콜백 & await |
| 실행 시점                     | 이벤트 루프의 새 주기가 시작될 때                     | 콜스택이 비어있을 때                               |
| 실행 단위                     | 실행 시점 당시 큐에 들어있던 태스크                   |
| (새로 추가된 태스크는 미포함) | 큐에 있는 모든 마이크로태스크, 즉 큐가 빌 때까지 실행 |
| 우선순위                      | 마이크로태스크보다 낮음                               | 매크로태스크보다 높음                              |

- 태스크 실행 과정 예시

  - (콜스택이 비면…) 마이크로태스크 → 렌더링 → 매크로태스크 (반복)

  ```jsx
  console.log('콜스택 - 1'); // ------------------------------------- (a)
  setTimeout(() => console.log('태스크 큐'), 0); // ------------------ (b)
  Promise.resolve().then(() => console.log('마이크로태스크 큐')); // -- (c)
  console.log('콜스택 - 2'); // ------------------------------------- (d)

  // ---- 실행 결과 ----
  // 콜스택 - 1
  // 콜스택 - 2
  // 마이크로태스크 큐
  // 태스크 큐

  // ---- 해석 ----
  // 1. (a)로 인해 콜스택에 (a)의 FEC가 쌓이고 console.log()가 실행됨
  // 2. (b)로 인해 콜스택에 (b)의 FEC가 쌓이고 setTimeout()가 실행됨
  //     백그라운드에서는 타이머가 작동하며, 그동안 다른 스크립트가 수행됨
  // 3.  타이머가 종료되면 콜백함수가 매크로태스크 큐로 이동함
  // 4. (c)로 인해 콜스택에 (c)의 FEC가 쌓이고 Promise.resolve(), .then()가 실행됨
  //     .then()이 실행됨에 따라 콜백함수가 마이크로태스크 큐로 이동함
  // 5. (d)로 인해 콜스택에 (d)의 FEC가 쌓이고 console.log()가 실행됨
  // 6. 이벤트 루프가 콜스택이 비었음을 감지함
  // 7. 이벤트 루프가 마이크로태스크 큐에 있는 태스크를 순차적으로 콜스택에 쌓고 실행함
  // 8. 렌더링이 필요한 경우 렌더링이 일어남
  // 9. 이벤트 루프가 마이크로태스크 큐가 비었음을 감지함
  // 10. 이벤트 루프가 매크로태스크 큐에 있는 태스크를 콜스택에 쌓고 실행함
  // 11. 이벤트 루프가 잠듬...
  ```

---

### 자바스크립트는 싱글 스레드 언어인데 어떻게 비동기 처리를 할 수 있나요?

자바스크립트의 비동기 작업은 메인 스레드와 독립적으로 수행되기 때문입니다. 예를 들어 비동기적인 `Web API` 메서드는 브라우저의 백그라운드 스레드에서 독립적으로 수행되고, 그동안 메인 스레드에서는 다른 작업을 수행할 수 있습니다. 비동기 작업이 완료되고 나면 해당 작업의 콜백함수가 `콜백 큐`에 프로미스 내 비동기 작업은추가되며, `콜스택`이 비었을 때 `이벤트루프`에 의해 `콜스택`에 적재됩니다.

### 참고

- [[MDN] JavaScript의 queueMicrotask()와 함께 마이크로태스크 사용하기](https://developer.mozilla.org/ko/docs/Web/API/HTML_DOM_API/Microtask_guide)
- [[MDN] 심층 탐구: 마이크로태스크와 JavaScript 런타임 환경 (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth#run_javascript_run)
- [🔄 자바스크립트 이벤트 루프 동작 구조 & 원리 끝판왕](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%9D%B4%EB%B2%A4%ED%8A%B8_%EB%A3%A8%ED%94%84_%EC%8B%9C%EA%B0%81%ED%99%94)

## 3. 호이스팅(hoisting)에 대해 설명해주세요

- **호이스팅이란?**
  - 변수를 선언 전에 사용할 수 있게 하는 자바스크립트의 동작 방식
  - 선언부가 유효 범위의 최상단으로 끌어올려진 것처럼 보이는 현상
  - 실행 컨텍스트 생성 단계에서 발생함
- **TDZ (Temporal Dead Zone)**
  - 변수가 선언되었지만 초기화되지 않은 상태
  - 즉, 할당된 메모리 공간이 없는 상태
  - `let`, `const`로 선언한 변수는 호이스팅된 후 초기화되기 전 `TDZ`에 들어감
  ```jsx
  // myVar 선언부가 호이스팅됨
  console.log(myVar); // ReferenceError: Cannot access 'myVar' before initialization
  let myVar = 10; // 할당
  ```

## 4. 실행 컨텍스트

### 개념

- 실행 가능한 코드의 환경 정보를 모아놓은 객체
- 스코프 체인, 변수 객체, `this` 포함

### 종류

- **전역 실행 컨텍스트 (GEC)**
  - 자동으로 생성됨
  - 자바스크립트는 싱글 스레드 언어이므로 `1개`만 생김
  - `콜스택`에 가장 먼저 쌓임
- **함수 실행 컨텍스트 (FEC)**
  - 함수 호출 시 생성됨
- Eval 함수 실행 컨텍스트
  - `eval()` 함수 호출 시 생성됨

---

### 생성 및 실행 단계

### 예시 코드

```jsx
function func(pass) {
  var a = 1;
  var b = function innerExpression() {};
  function innerDeclaration() {}
}
func(1);
```

### 생성 단계

- 스코프와 스코프 체인 생성
- 변수 객체 생성 + 호이스팅
  - `arguments`, 변수, 내부 함수 등을 포함하는 객체
- `this` 값 할당

```jsx
funcExectuionContext = {
	Scope Chain,
	Activation Object = {
		arguments = {
			0: 1
			length: 1
		},
		pass: 1,
		a: undefined,
		b: undefined,
		innerDeclaration: reference to innerDeclaration
	}
}
```

### **실행 단계**

- 변수에 값이 할당됨

```jsx
funcExectuionContext = {
	Scope Chain,
	Activation Object = {
		arguments = {
			0: 1
			length: 1
		},
		pass: 1,
		a: 1,
		b: reference to innerExpression,
		innerDeclaration: reference to innerDeclaration
	}
}
```

### 참고

- [[Javascript] Execution Context](https://baeharam.github.io/posts/javascript/jsexecution-context/)

## 5. 스코프

- **스코프란?**
  - **유효 범위**
  - **참조 대상 식별자**(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)**를 찾아내기 위한 규칙**
    - ⇒ 변수끼리 이름이 동일해도 스코프가 다르면, 서로 다르게 인식됨
- **블록 레벨 스코프 🆚 함수 레벨 스코프**
  - 블록 레벨 스코프: 코드 블록 기준
  - 함수 레벨 스코프: 함수 블록 기준 (✅자바스크립트)
- **동적 스코프** 🆚 **렉시컬 스코프(정적 스코프)**

  - 동적 스코프: 함수 호출 위치에 따라 상위 스코프가 결정됨
  - 렉시컬 스코프: 함수 선언 위치에 따라 상위 스코프가 결정됨 (✅자바스크립트)

  ```jsx
  var x = 1;

  function foo() {
    var x = 10;
    bar(); // 함수 호출 위치는 상위 스코프 결정에 영향을 주지 않음
  }

  // 함수 bar의 상위 스코프는 전역 스코프
  function bar() {
    console.log(x);
  }

  foo(); // 1
  bar(); // 1
  ```

- **스코프 체이닝이란?**
  - 참조 대상이 현재 스코프에 없을 때, 실행 컨텍스트의 스코프 체인을 타고 올라가 참조 대상을 상위 스코프에서 찾는 것
- **참고**
  - [[poiemaweb] 스코프](https://poiemaweb.com/js-scope)

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

- **가비지 컬렉터란?**
  - 메모리 할당 상태를 추적하고, 불필요하게 할당된 메모리를 회수하는 청소부
- **가비지 컬렉션 알고리즘**

  - Reference-counting: 참조되지 않는 객체의 메모리를 회수함 ⇒ 순환 참조 문제 발생

    ```jsx
    function f() {
      const x = {};
      const y = {};
      x.a = y; // x는 y를 참조합니다.
      y.a = x; // y는 x를 참조합니다.

      return 'azerty';
    }

    f();

    // 함수 호출 완료 시 x, y는 불필요한 객체이므로 할당된 메모리가 회수되어야 함
    // 하지만 **x, y가 서로 참조하고 있어(순환 구조) 메모리를 회수하지 못함**
    ```

  - Mark-and-sweep: `global`에서 연결된 모든 객체(=도달 가능한 객체)를 `mark`하고, `mark`되지 않은 객체를 메모리에서 `sweep` ⇒ 순환 참조 문제 해결

- 함께 보면 좋은 내용
  - `WeakMap`, `WeakSet`의 약한 참조

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.

<aside>
💡 자바스크립트에서는 배열의 요소가 갖는 메모리 크기가 서로 달라도 되고, 배열 요소가 메모리 상에 연속적으로 이어져있지 않을 수 있다(=희소배열일 수 있다).
이처럼 자바스크립트의 배열은 배열을 흉내낸 객체에 가깝다.

</aside>

### 코드 예시

```jsx
const arr = []; // - (a)
arr.push(1); // ---- (b)
arr.pop(); // ------ (c)
```

### (a)

1. 스택에 변수 `arr`의 메모리 공간이 할당되고, 힙에 빈 배열 `[]`가 저장됨
2. `arr`의 메모리 공간에 `[]`의 주소값이 담김 (=할당)

### (b)

1. 힙에 `1`이 저장됨
2. 빈 배열 `[]`의 끝에 `1`의 메모리 주소가 담김

### (c)

1. 배열 `[1]`이 더이상 `1`의 메모리 주소를 참조하지 않음
2. GC에 의해 `1`의 메모리 할당이 해제됨

## 정욱

## 1. 자바스크립트 엔진의 동작 방법

모든 자바스크립트 엔진은 자바스크립트로 작성된 코드를 추상 구문 트리로 변환하는 파서, 추상 구문 트리를 해석하여 바이트 코드를 생성하는 인터프리터, 바이트 코드를 통해 더욱 효율적이고 원활하게 실행하기 위해 최적화된 기계어를 생성하는 최적화 컴파일러를 포함한다. 인터프리터가 동작하며 프로그램이 실행되는 동안 자주 실행되는 코드가 프로파일링되어 최적화 컴파일러로 보내지게 되며, 그렇게 최적화된 기계어가 생성되어 프로그램의 성능을 높일 수 있다. 만약 최적화가 잘못되었다면 원래 있던 바이트 코드를 사용한다.

(https://mathiasbynens.be/notes/shapes-ics)

## 2. 이벤트 루프

이벤트 루프는 자바스크립트에서 비동기 작업을 가능케 하는 핵심 개념으로, 코드의 실행과 이벤트 처리 및 제어 흐름을 관리한다.

### 호출 스택

자바스크립트 인터프리터는 현재 실행 중인 함수를 추적하기 위해 호출 스택을 사용하며, 호출 스택은 실행 컨텍스트를 저장한다. 현재 실행 중인 함수에서 새로운 함수를 실행할 경우, 스택에 실행된 함수의 실행 컨텍스트를 최상단에 저장하며, 함수의 실행이 끝날 경우 스택에서 실행 컨텍스트를 삭제한다.

### 태스크 큐

비동기 작업이 완료된 후 실행될 콜백 함수들은 태스크 큐에 저장된다. 이 콜백 함수들은 어떤 비동기 함수의 콜백으로 제공되었는지에 따라, 마이크로태스크 큐 또는 매크로태스크 큐에 들어가게 된다. 마이크로태스크 큐는 매크로테스크 큐보다 처리되는 우선순위가 높다.

### 누구의 콜백 함수가 어떤 큐에 들어갈까?

| Macro                                                                                  | Micro                                                       |
| -------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O 함수, UI 렌더링 함수 | process.nextTick, Promise, Object.observe, MutationObserver |

### 자바스크립트는 싱글 스레드 기반인데 어떻게 비동기 처리를 할 수 있나요?

이벤트 루프는 호출 스택과 태스크 큐를 항상 주시하며, 호출 스택이 비어있다면 먼저 마이크로태스크 큐의 콜백 함수를 호출 스택에 넣어주고, 호출 스택과 마이크로태스크 큐 모두 비어있다면 매크로태스크 큐의 콜백 함수를 호출 스택에 넣어준다. 비록 단일 호출 스택을 사용하지만, 이벤트 루프와 태스크 큐의 존재 덕분에 자바스크립트는 비동기적으로 작업을 처리할 수 있다.

## 3. 호이스팅(hoisting)에 대해 설명해주세요

호이스팅이란 인터프리터가 코드를 실행하기 전 추상 구문 트리로 변환되는 ‘파싱’ 과정에서, 함수/변수 또는 import 선언이 자신이 선언된 스코프의 최상단으로 이동하는 동작을 뜻한다.

### 값 호이스팅, 함수 호이스팅

`var` 키워드를 통해 선언된 변수는 자신이 선언된 스코프 상에서 실제로 선언되기 전에도 접근이 가능하나, 그 값은 항상 `undefined`이다.

함수 선언문을 통해 선언된 함수는 그 전체가 호이스팅되기 때문에 함수가 코드 상에서 어디에 선언되었든 상관없이 호출할 수 있지만, 함수 표현식을 통해 변수에 초기화된 함수는 해당 변수에 실제로 함수가 할당되기 전에 호출할 수 없다.

### TDZ(Temporal Dead Zone, 일시적 사각지대)

`let`, `const`, `class` 키워드를 통해 선언된 변수는 코드 상에서 실제로 선언되고 초기화가 완료되는 시점 이전에 접근을 시도할 경우 `ReferenceError`를 발생시킨다. 이 때, 변수가 속한 스코프의 맨 위부터 초기화 완료 시점까지의 부분을 TDZ라고 부른다. ‘일시적’이라고 부르는 이유는, 사각지대가 코드의 실행 순서에 의해 만들어지기 때문이다.

일각에서는 이러한 TDZ의 존재때문에 `let`, `const`, `class`는 호이스팅되지 않는 것으로 보기도 하는데, 사실 호이스팅이라는 용어 자체가 ECMAScript 표준에 등재된 것은 아니기 때문에 틀리다고 볼 수는 없다.

## 4. 실행 컨텍스트

실행 컨텍스트란 코드를 실행하기 위해 필요한 모든 정보를 모아놓은 객체이다. 크게 전역/함수 컨텍스트의 두 가지로 나누어지며, 전역 컨텍스트는 프로그램이 실행될 때, 함수 컨텍스트는 함수가 호출될 때마다 새롭게 만들어져 호출 스택에 추가된다.

### 실행 컨텍스트가 관리하는 정보

실행 컨텍스트가 관리하는 정보는 ECMAScipt 버전이 업데이트될 때마다 그 세부 내용이 조금씩 달라지며, 이하의 내용은 모두 글을 작성하는 현재의 최신 표준인 ECMAscript 2024에 기반하여 서술한다.

| 정보                   | 용도                                                                                                                                      |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| code evalutation state | 이 실행 컨텍스트와 연관된 코드의 상태를 변경하기 위해 필요한 정보                                                                         |
| Function               | 이 실행 컨텍스트가 함수 객체의 코드를 평가하고 있는 경우 해당 함수 객체를 값으로 가지며, 스크립트나 모듈의 코드를 평가하고 있는 경우 null |
| Realm                  | 코드가 실행되는 환경을 나타내며, 전역 환경, 실행을 위해 로드된 코드, 관련 상태와 리소스, 이외 여러가지 내부 객체                          |
| ScriptOrModule         | 관련된 코드가 어떤 스크립트 또는 모듈에 있는지에 대한 정보                                                                                |
| LexicalEnvironment     | 현재 실행 컨텍스트 내에서 코드를 통해 만들어진 식별자 참조를 확인하기 위한 정보                                                           |
| VariableEnvironment    | 현재 실행 컨텍스트 내에서 var 선언문을 통해 만들어진 식별자 참조를 확인하기 위한 정보                                                     |
| PrivateEnvironment     | class 키워드로 선언된 클래스의 인스턴스일 때, private으로 선언된 프로퍼티나 메서드에 대한 참조를 확인하기 위한 정보                       |

### 환경 레코드(Environment Record)

실행 컨텍스트를 구성하는 요소 중 하나로, `Lexical/Variable/PrivateEnvironment` 모두 환경 레코드 타입의 일종이다. 현재 실행 컨텍스트에서 변수/함수 식별자와 그 값을 관리하는 데에 사용되며, 외부 환경을 참조하기 위한 `[[Outer]]` 필드를 가지고 있다. 해당 필드를 통해 외부 환경의 식별자를 탐색할 수 있게 되며, 곧 스코프 체이닝을 가능케 한다.

## 5. 스코프

스코프란 식별자의 접근 규칙에 따른 유효 범위를 뜻한다. 자바스크립트의 스코프는 크게 전역/지역의 두 가지로 나눌 수 있으며, 조금 더 세분화하자면 전역/모듈/함수/블록의 네 가지로도 나눌 수 있다.

스코프는 다음과 같은 주요 규칙을 가진다:

1. 계층적인 구조를 가지고 있어, 안쪽 스코프에서 바깥쪽 스코프로 접근할 수 있지만 그 반대는 불가능하다.
2. 스코프는 중첩이 가능하다.
3. 지역 스코프에서 선언한 변수는 전역 스코프에서 선언한 변수보다 그 우선순위가 높다.

### 스코프 체인

자신의 스코프에서 식별자를 찾지 못한 경우 `LexicalEnvironment`의 `[[Outer]]`를 통해 접근할 수 있는 가장 가까운 스코프에서 다시 식별자를 찾게 되며, 그래도 식별자를 찾지 못한다면 이 과정을 반복한다. 이 과정은 중첩된 스코프의 최상위에 도달할 때까지 계속된다. 자신을 제외하고, 자신에게서 제일 가까운 스코프에서 최상위 스코프인 전역 스코프까지 각 스코프가 사슬처럼 연결되어 있는 형태를 스코프 체인이라고 지칭한다.

### 렉시컬 스코프

함수의 스코프는 해당 함수가 어디에서 호출되었는지가 아닌, 어디에 선언되어있는지에 따라 결정된다. 이러한 스코프의 결정 방법을 렉시컬 스코프라고 지칭한다.

### `var` vs. `let`/`const`

`let` 또는 `const`를 통해 선언된 식별자는 `LexicalEnvironment`에 기록되며, 블록 레벨 스코프에 속한다. 그러나 `var`를 통해 기록된 식별자는 `VariableEnvironment`에 기록되며, 함수 레벨 스코프에 속한다.

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

가비지 컬렉션의 핵심은 ‘어떠한 메모리가 더 이상 필요없어지는 때를 찾는 것’이지만, 이것은 비결정적 문제이기 때문에 해결하기 매우 어렵다. 자바스크립트는 도달 가능성(reachability)이라는 개념을 통해 메모리 관리를 수행하며, 가비지 컬렉터가 모든 객체를 모니터링하고 있다가 ‘도달할 수 없는’ 객체를 삭제한다.

### Reference Counting

가장 단순하게 구현할 수 있는 알고리즘이며, ‘도달 가능성’이라는 개념 이전에 가비지 컬렉션을 수행하던 방식이다. 어떠한 다른 객체도 참조하지 않는 객체를 더 이상 필요하지 않다고 판단하여, 수집할 수 있는 것으로 판단한다. 그러나 이 방법은 둘 이상의 객체 간에 순환 참조가 일어났을 때, 이 객체들을 필요하지 않다고 판단할 수 없게 되어 메모리 누수가 일어날 수 있다는 단점이 있다.

### Mark and Sweep

도달 가능성을 염두에 둔 알고리즘이며, 현재 모든 최신 브라우저가 채택하고 있는 알고리즘이다. 최상위에 존재하는 전역 객체를 포함하는 객체의 집합인 `roots`부터 시작하여 `roots`가 참조하는 객체들, 그 객체들이 참조하는 객체들 등을 찾는다. 이렇게 도달할 수 있는 모든 객체들을 찾고, 도달할 수 없는 모든 객체를 수집한다.

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.

자바스크립트의 배열은 일반적으로 익숙한 ‘밀집 배열(dense array)’이 아니라 일반적인 배열의 동작을 흉내낸 특수한 객체이기 때문에, 모든 요소가 똑같은 공간을 차지하지 않을 수 있으며 또한 연속적으로 위치하지 않을 수 있다.

### 추가

자바스크립트의 배열에 값을 추가하는 것은 곧 자바스크립트 객체에 프로퍼티를 추가하는 것이다. 따라서 해당하는 인덱스를 키로 하고 추가한 요소를 값으로 하는 프로퍼티가 배열 객체에 추가되며, 그와 동시에 `length` 프로퍼티가 현재 배열 객체가 가지고 있는 가장 큰 인덱스 값보다 1만큼 큰 값으로 갱신된다.

```jsx
const arr = [];
arr[3] = 'New Value';

// result: 4
console.log(arr.length);

arr.push('Second');

// result: 5
console.log(arr.length);
```

### 삭제

추가와 마찬가지로, 자바스크립트의 배열 값을 삭제하는 것은 자바스크립트 객체의 프로퍼티를 삭제하는 것이다. 해당하는 인덱스(키)-요소(값) 프로퍼티가 삭제되며, `length` 프로퍼티를 내부적으로 감소시키는 메소드를 사용하지 않는 한 `length` 프로퍼티는 자동으로 갱신되지 않는다.

```jsx
const arr = [1, 2, 3, 4, 5];
arr.pop();

// result: 4
console.log(arr.length);

delete arr[2];

// result: 4
console.log(arr.length);
```

## 영은

## 1. 자바스크립트 엔진의 동작 방법

**자바스크립트 엔진**

- JavaScript 코드를 주로 코드를 해석하고 실행하는 역할
  →엔진은 코드를 평가단계와 실행단계로 나눠서 처리함
- 주로 브라우저나 서버 측 환경에서 사용되며, 각각의 환경에서 동작하는 방식은 약간씩 다를 수 있다.
  ⇒ 자바스크립트는 싱글 스레드 방식으로 한번에 하나의 태스크만 실행한다. 이때 **싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진**이다.
  즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.
- **힙**(변수나 상수들이 사용되는 메모리가 저장되는 부분) & **콜스텍**(함수 호출의 전반적인 상태를 추적하여 프로그램의 실행 흐름을 관리하는 스텍 자료구조)으로 구성
  ※ 콜스텍을 실행컨텍스트 스텍이라고 부르기도 한다.
- 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다.

**동작방법**

코드를 구문 분석하여 추상 구문 트리(AST)를 생성→ 바이트 코드로 변환 → 바이트 코드가 실행되어 JavaScript 코드의 동작을 수행→ 마지막으로 더이상 사용하지 않는 메모리를 해제하는 과정을 통해 메모리 누수를 방지

**↔ 런타임 환경**

코드가 실행되는 환경을 제공하는 소프트웨어

**⇒ 자바스크립트 엔진은 런타임 환경의 구성요소라고 볼 수있음**

## 2. 이벤트 루프

> 브라우저가 제공하는 기능으로 현재 콜스텍과 태스크큐를 반복적으로 확인하면서 태스크큐에 대기중인 함수가 있다면 콜스텍이 비었을때 이동시키는 역할을 한다.
> ⇒ 비동기 처리를 할 수 있는 핵심적인 기능

- Task queue란? (Micro vs. Macro)

> setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

- 마이크로태스크 큐
  - 태스크 큐와는 별도의 큐
  - 프로미스의 후속 처리 메서드의 콜백 함수 일시 저장
  - 마이크로태스크 큐는 태스크큐보다 우선순위가 높다.
    → 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수
    먼저 가져와 실행한다.

## 3. 호이스팅(hoisting)에 대해 설명해주세요

선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

- **발생하는 이유**
  앞서 언급했듯, 자바스크립트 엔진은 소스코드를 평가와 실행단계로 나눠 처리 한다. 전역 실행 컨텍스트가 생성되고 var키워드와 전역에 선언한 함수는 **런타임 이전에 실행과 초기화가 완료**돼 **선언문 이전에도 참조 할 수 있어**서 마치 선언문이 끌어올려진거 처럼 느끼게 됨
  let과 const로 선언된 변수와 표현식은 객체 환경 레코드가 아닌 선언적 환경 레코드라는 개념적인 블록에 저장돼, 전역객체의 프로퍼티로 참조 할 수 없다. 즉 런타임 실행 흐름이 선언문에 도달하기까지 일시적 사각지대(TDZ)에 빠지게 된다. →모든 선언문은 런타임 이전 단계에서 먼저 실행되는것은 변함이 없어 호이스팅은 되지만 TDZ에 빠져 참조는 할 수 없다.

## 4. 실행 컨텍스트 ⭐⭐⭐

> **식별자(변수, 함수, 클래스 등의 이름)를 등록**하고 관리하는 **스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘**으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
>
> 실행컨텍스트만 이해해도 스코프, 호이스팅, 클로저,비동기 처리 방식 등을 이해할 수 있다!

**구성요소**

- **실행컨텍스트 스택**
  코드의 실행순서를 스택 자료구조로 관리한다. 소스코드가 평가 되면 실행컨텍스트가 생성되고,최상위에 쌓인다. 즉, 스택의 최상위에 있는 것은 현재 실행중인 코드다. 실행이 완료되면 팝되어 스텍에서 제거 된다.
  ⇒ 스텍에서 제거 된다고 해서 렉시컬 환경까지 소멸하는 것은 아니다 어딘가에서 참조되고 있다면 렉시컬 환경은 남아있다. (클로저의 원리)
  ⇒ 누군가에 의해 참조되지 않을때 렉시컬 환경은 비로소 가비지컬렉터에 의해 소멸한다.
- **렉시컬 환경**
  > 스코프 체인을 통해 식별자를 찾기 위한 환경
  > 환경레코드 : 식별자&바인딩된 값 관리
  - 전역환경레코드
    - 객체 환경레코드 : 연결된 바인딩 오브젝트를 통해 var로 선언된 변수와 전역에 선언된 함수를 전역객체의 프로퍼티와 메서드가 됨
    - 선언적 환경레코드 : let, const로 선언한 변수와 함수 표현식을 등록하고 관리
    - [[GlobalThisValue]] : this바인딩하는 내부 슬롯
  - 함수환경레코드
    - 매개변수, arguments객체, 함수내부에서 선언한 지역변수와 중첩 함수를 등록하고 관리.
      외부렉시컬 환경에 대한 참조 : 상위스코프에 대한 참조를 기록 ⇒ 이를 통해 스코프 체인 구현
  - 전역에서는 스코프체인의 종점이라 null이 할당됨

## 5. 스코프

> 식별자가 유효한 범위

- 스코프 체인 / 스코프 체이닝

> 함수의 중첩에 의해 계층적 구조를 갖는 것 :: 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역스코프의 최상위 스코프는 전역스코프다

- 렉시컬 스코프

> 자바스크립트에서 스코프는 렉시컬 스코프를 따른다. 이는 함수가 호출된 시점이 아니라 정의된 시점에 스코프를 결정하는 것을 말한다.

- 블록 레벨 스코프

> ES6에서 **`let`** 및 **`const`** 키워드의 도입으로 생긴 스코프로 중괄호(**`{}`**)로 둘러싸인 코드 블록 내에서 변수가 유효한 스코프를 의미
> ex. if문, for문, while문 등

- 함수 레벨 스코프

함수 내에서 선언된 변수가 해당 함수 내에서만 유효한 스코프를 가지는 것을 의미

함수 외부에서는 해당 변수에 접근할 수 없다.

ES6이전에도 있었음.

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

> 가비지 콜렉터 11는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.

질문의 의도를 잘 파악하지 못해서 답을 못하겠어용,, 다른분들 답변보고 정리할게용
