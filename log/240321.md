
## 보경

**Virtual DOM**

실제 DOM을 추상화 한  DOM의 사본을 JS 객체 형태로 메모리 안에 저장해서 실제 DOM 과 비교하고 동기화하는 프로그래밍 개념

**Virtual DOM 사용 이유**

DOM에 어떤 변화가 생기면 CRP(Critical Rendering Path)가 반복된다. 어떤 변화가 동시에 N번 생기면 CRP도 N번 반복하게 되는데 CRP과정을 거치면서 화면을 다시 렌더링하는 것은 비용이 많이 드는 작업이다. 따라서 변경사항을 VDOM(JS객체)에 적용시켜 불필요한 CRP 과정을 없애준다. 최종적으로 변경된 VDOM을 실제 DOM과 동기화 하면 N번의 과정을 1번으로 줄일수 있다.

VDOM을 사용하지 않는다면 N번의 변화를 묶어서 DOM fragment에 적용한 뒤 실제 DOM과 동기화가 가능하다.

하지만 VDOM을 사용해서 위 과정을 개발자가 할 필요 없이 자동화하고 추상화시켜 생산성을 증가시킨다.

VDOM 사용시 VDOM에서 계산하고 다시 DOM과 동기화를 해야하므로 DOM보다 빠르지는 않지만 일반적인 프로젝트에서 사용할 만큼 충분히 빠르다.

**Virtual DOM 작동 원리**

1. State나 Props가 변경되면 전체 UI를 VDOM에 렌더링한다.
2. 이전 VDOM과 업데이트 후의 VDOM을 비교한다.
3. 변화된 부분만 실제 DOM에 적용해  CRP가 한 번 실행되도록 한다.

**리액트의 Diffing Algorithm(비교 알고리즘)**

두 개의 트리를 비교할 때 두 엘리먼트의 루트 엘리먼트부터 비교합니다. 이후의 동작은 루트 엘리먼트의 타입에 따라 달라집니다.

- **엘리먼트의 타입이 다른 경우**
    - 이전 트리를 버리고 완전히 새로운 트리를 구축
- **엘리먼트의 타입이 같은 경우**
    - 두 엘리먼트의 속성을 비교해 변경된 속성만 갱신한다.
- **자식 요소가 바뀌는 경우**
    - 첫번째 자식부터 재귀적으로 비교를 하게되는데 첫 요소가 변화하면 다른요소들이 동일한 경우에도 모두 비교를 진행한다. 이 경우 성능저하가 야기됨 ⇒ key Props 사용하여 해결
    - Key Props을 명시해 형제간의 요소들을 고유하게 식별할 수 있게 해준다.

## 미림

### 등장 배경

- 실제 DOM 조작의 비효율성
    - 실제 DOM을 직접 조작하면, 리플로우&리페인팅이 빈번하게 일어남 ⇒ 성능 저하
    - 웹 발전에 따라 복잡한 웹 애플리케이션이 등장하며, 이러한 문제점이 극대화됨
- SPA의 등장
    - 새로 렌더링하려면 페이지 전체를 새로 로드해야 함 & 화면 깜빡임 현상 문제
    - ⇒ SPA로 페이지의 콘텐츠를 동적으로 업데이트
    - ⇒ 데이터와 UI 상태를 효율적으로 관리하는 방법이 필요해짐

### 가상 DOM 소개

- **개념**
    - JS 객체로 구현한 **실제 DOM의 모형**
    - 실제 DOM과 동일한 구조를 가지며, 메모리에만 존재
- **장점**
    - 1️⃣가벼움 ⇒ 조작하는 데 부담이 덜 함
    - 2️⃣비교(`diffing`) 알고리즘 최적화 ⇒ 변경 사항을 더 빠르게 감지
    - 3️⃣변경 사항 일괄 처리(`Batch 처리`) ⇒ 리플로우&리페인팅 최소화
        - 가상 DOM의 이전 상태와 새로운 상태를 비교하고, 한 번에 실제 DOM 에 반영
        - 실제 DOM을 직접 조작하면, 변경이 있는 순간마다 렌더링 됨

### 가상 DOM은 만능인가? (feat. Svelte)

- 가상 DOM 없이도 렌더링 문제 해결 가능 & 가상 DOM이 제일 빠른 건 X
- React, Vue는 라이브러리/프레임워크 🆚 Svelte는 컴파일러
- React는 브라우저 런타임에서 가상 DOM을 처리함 ⇒ 브라우저에 부담이 됨
🆚 Svelte는 빌드할 때 미리 컴파일해서 브라우저에 줌 ⇒ 브라우저는 띄우기만 하면 됨
- Svelte의 방식이 가상 DOM을 쓰는 것보다 빠름

### React의 `diffing` 알고리즘

- 이전과 새로운 버전의 가상 DOM 트리를 재귀적으로, 최상위 노드부터 내려가며 비교
- **루트 요소 유형이 다른 경우** ⇒ 이전 트리를 버리고 완전히 새로운 트리를 구축
    - 즉 루트 요소 아래 모든 컴포넌트가 언마운트되고, 새로 다시 마운트 됨
- **요소의 속성이 다른 경우** ⇒ 변경된 속성만 갱신
- `**key` 속성이 일치하지 않는 경우** ⇒ 일치하지 않는 요소만 갱신
    - `key`는 불변하고, 예상 가능하며, 고유해야 함
    - `key`는 컬렉션 요소(ex. 리스트) 렌더링 시 갱신이 필요한 요소를 추적함
        
        ```diff
        // 리스트 맨 앞에 요소를 추가할 때, key의 유무 차이
        
        <ul>
        -  <li>봉준호</li>
        -  <li>손흥민</li>
        +  <li>BTS</li>    // 봉준호 !== BTS   => 갱신
        +  <li>봉준호</li> // 손흥민 !== 봉준호 => 갱신
        +  <li>손흥민</li> // 손흥민            => 트리에 추가
        </ul>
        
        <ul>
        +  <li key='bts'>BTS</li>
           <li key='bong'>봉준호</li>
           <li key='sonny'>손흥민</li>
        </ul>
        ```
        

### React에서 DOM 요소에 직접 접근해선 안 되는 이유

- React의 성능 최적화 방해
    - React는 가상 DOM을 사용해 변경 사항을 일괄 처리하고, 최소한의 DOM 조작만 수행하는데, 이를 반함
- 일관성이 떨어짐
    - 뭐는 가상 DOM, 뭐는 실제 DOM으로 조작하면 일관성이 없음
    - React가 가상 DOM을 재구성할 때 직접 DOM을 수정하면 동기화되지 않을 수 있음
- 보안 문제
    - XSS(Cross Site Scripting): 악성 스크립트를 삽입해 정보를 탈취하거나 사이트를 손상시키는 공격
    - React는 컴포넌트 간 props를 통해 데이터를 전달하므로 악의적인 입력으로부터 비교적 안전함
    - 직접 DOM을 수정하는 건, 이러한 React의 보안 메커니즘을 우회하는 것

### 함께 보면 좋은 내용

- `Shadow DOM`: 웹 컴포넌트의 범위 지정 변수 및 CSS용으로 설계된 브라우저 기술
- `React Fiber`: React 16의 새로운 재조정 엔진, virtual DOM의 증분 렌더링을 활성화

### 참고

- [React 공식 문서 - 재조정 (Reconciliation)](https://ko.legacy.reactjs.org/docs/reconciliation.html)
- [DOM은 뭐고 가상 DOM은 뭔가요? (+ Svelte와 React의 차이)](https://www.youtube.com/watch?v=1ojA5mLWts8)

## 영은

**가상 DOM(Virtual DOM)**

실제 DOM의 가벼운 복제본으로, UI를 자바스크립트 객체 형태의 값으로 표현한 것
가상돔은 메모리 상에서 동작하며 실제 렌더링 되지 않는다

**Virtual DOM은 트리가 바뀌었는지 어떻게 비교하나요?**

- 컴포넌트의 상태나 속성이 변경되면 React는 가상 DOM을 새로 생성.
- 이전 가상 DOM과 현재 가상 DOM을 비교하여 변경된 부분을 찾는다.
- 변경된 부분만을 실제 DOM에 반영하여 업데이트.

**React의 `key`는 무엇인가요?**

- **`key`**는 동적인 요소를 **렌더링할 때 각 요소를 고유하게 식별**하는 데 사용.
- 일반적으로 배열로 렌더링되는 요소들을 생성할 때 사용.

⇒ 리액트가 요소를 옳바르게 업데이트, 재사용 또는 제거할 때 도움이 된다.

**사용하지 않았을때 문제점**

- **예기치 못한 UI 동작**: key를 제공하지 않으면 리액트가 요소의 고유성을 식별하지 못하고 예기치 못한 UI 동작이 발생할 수 있다. 
ex) 요소의 순서가 변경되었을 때 리액트가 올바르게 업데이트하지 못할 수 있다.
- 콘솔 경고 : 키를 지정해주지 않았다고 경고창이 계속 뜸
- **성능저하 :** React는 요소의 변경 여부를 파악하기 위해 전체 배열을 다시 렌더링하게 된다.

**key 규칙**

- **key는 형제 간에 고유** 
하지만 같은 key를 *다른* 배열의 JSX 노드에 사용가능
- **key는 변경되어서는 안됨**
- **+)렌더링 중에는 key를 생성하지 x**
⇒ 렌더링 중에 생성하면 렌더링 간에 key가 일치하지 않아 모든 컴포넌트와 DOM이 매번 다시 생성될 수 있다.

번외! key와 className, Id와의 차이점은?
고유성을 부여할 수 있는 기능은 id가 있는데 굳이 key를 따로 지어주는걸까에서 나온 의문

- key는 “배열 안”에서만 고유한 값이며, 전체 범위에서는 고유할 필요가 없음! so, 배열렌더링시 key를 통해 고유성을 주면 속도나 성능면에서 이점이겠죠!
- 또한 React에서 key는 힌트를 제공하지만 컴포넌트로 전달하지 X. 컴포넌트에서 key와 동일한 값이 필요하면 다른 이름의 prop으로 명시적으로 전달

또 다른 번외! key라는 명칭에서 알 수 있듯, 자료 구조 “해시 테이블”에서 온 단어 입니다.

- js에서 key는 객체와 프로퍼티, 값 중 프로퍼티에 해당합니다.
- 즉, key를 통해, 배열의 자료 구조를 → 탐색 시간 복잡도가 1인 해시 테이블로 전환해주는 것이라고 볼 수 있다.
- **더 과감하게 정리하자면, key는 데이터 베이스와 연결하기 위해 엘레먼트 배열을 “객체”로 만들어주는 기능이라고도 볼 수 있겠다.**

**React 사용 시 DOM 요소에 직접 접근하는 방식이 왜 권장되지 않는가?**

가상DOM을 사용해 DOM 조작을 최소화하여 변경사항들을 효율적으로 처리 → 브라우저에 부담을 덜 주는 장점이 있는데 굳이 직접 돔을 조작하여 위험할 필요가 없다. ⇒ 그냥 리액트 사용 이유,,를 부정하는 것이니까?
