## 보경

## **ARP(Address Resolution Protocol)**

네트워크 상에서 가상주소인 IP 주소를 사용하여 네트워크 장비를 고유하게 식별하는 실제 주소인 MAC 주소를 찾는 프로토콜 

## IP란

TCP/IP모델의 여러 프로토콜 중 하나로 인터넷에 연결된 모든 장치에 고유한 IP 주소를 할당하여 서로 데이터를 주고받을 수 있도록 하는 프로토콜

**IP 동작과정**

IP는 작은 패킷단위로 나눈 데이터와 IP 헤더를 결합해 데이터를 전송한다. 이 때 데이터를 송신하고 수신하는 장치를 호스트라고 지칭한다. 만약 목적지가 다른 네트워크에 있다면 송신 호스트는 라우터를 통해 다른 네트워크로 데이터를 전송할 수 있다.

- 유니캐스트 : 단 하나의 호스트에 데이터를 전송하는 것
- 브로드캐스트 : 같은 네트워크상의 모든 호스트에 데이터를  전송하는 것
- 멀티캐스트 : 특정 그룹에 포함되는 호스트에 데이터를 전송하는 것

**라우팅테이블**

라우터가 다른 네트워크로 데이터를 전송할 때 참고하는 리스트로 라우팅 테이블에 등록되는 정보를 루트정보(경로정보)라고 한다. 라우터는 원홉통신을 하기 때문에 이웃 라우터의 정보만 가지고 있으며 인식할수 없는 네트워크로 가는 IP 패킷은 모두 폐기 되기 때문에 경로정보를 빠짐없이 등록해 둬야 한다.

## **IP주소**

IP를 사용해 통신에 참여하는 모든 장치를 식별하는 주소. IP주소를 통해 통신할 상대를 지정할 수 있다. 

**IP 주소의 체계**

과거에는 IP를 A, B, C, D, E  다섯 개의 클래스로 구분하는 클래스 기반 할당방식을 사용했으나 이는 사용하는 주소보다 버리는 주소가 많다는 단점이 있다.

**DHCP(Dynamic Host Configuration Protocol)**

네트워크 장치가 IP주소나 기타 통신에 매개변수들을 자동으로 할당받고 네트워크 설정을 구성하는 네트워크 관리 프로토콜

**NAT(Network Address Translation)**

하나의 네트워크에서 다른 네트워크로 패킷을 전달할 때 IP 주소를 변환하는 기술. IP주소는 이용범위에 따라 사설 IP주소와 공인 IP 주소로 분류되는데 사설 IP로는 응답을 받을 수 없다. 인터넷은 목적지가 사설 IP주소로 된 패킷은 폐기하기 때문이다. 따라서 사설네트워크에서 인터넷 통신을 하기 위해서는 NAT를 사용한다.

## HTTP(Hypertext Transfer Protocol)

웹에서 데이터를 주고받는데 사용되는 표준 프로토콜로 TCP 통신을 이용하며 요청과 응답을 주고받으며 데이터파일이 전송된다.

[**HTTP 버전별 특징**](https://zu-techlog.tistory.com/113)

- HTTP 1.0
    - 하나의 연결당 하나의 요청 처리 → 서버로부터 파일을 가져올 때마다 3웨이 핸드셰이킹을 열어야됨
- HTTP 1.1
    - keep-alive 옵션이 표준화가 되어 하나의 연결당 여러 번의 송수신 가능 → 하나의 연결에 다수의 리소스가 포함되어 있으면 대기시간(HOL blocking)이 길어짐
    - 헤더가 무거움
- HTTP 2
    - 여러개의 스트림을 사용하여 송수신하는 멀티플렉싱 기법을 사용해 HOL을 해결
    - HTTPS 위에서 동작
- HTTP 3
    - UDP 기반의 프로토콜로 사용

## HTTPS(Hypertext Transfer Protocol)

HTTP에 SSL/TLS 프로토콜을 추가해 암호화된 네트워크 연결을 보장해주는 프로토콜

## HTTP 요청

- response 라인 :메소드 url, 버전
- 메세지 헤더 : 웹브라우저의 종류와 버전 등
- 공백라인 : 구분용도
- 엔티티 바디 : 특정 데이터를 보낼 때

## HTTP response

- response 라인 : http 버전, 상태코드, 상태 설명
- 메세지 헤더 : 데이터 형식, 갱신 날짜
- 공백라인 : 구분용도
- 엔티티 바디 : 응답 데이터나 html 파일

## 미림

# 2.4 IP 주소

### **홉바이홉 통신과 ARP**

- `IP 주소`: **네트워크에 연결된** 각 장치들을 인식하기 위한 가상의 주소(네트워크에 연결되지 않았으면 IP 주소도 당연히 없는 것임)
- `MAC 주소`: 네트워크 인터페이스(ex. 단말기, 라우터 등)가 가지는 고유한 주소(물리적 주소)
- `홉바이홉 통신`: 네트워크(인터넷) 계층에서 패킷이 전송될 때, 라우터에 의해 라우팅되는 것
    - 각 라우터는 라우팅 테이블을 가지며, 여기에 IP 주소 리스트가 적혀 있음
- `ARP`: 라우팅할 때 IP 주소와 MAC 주소를 맵핑하고 변환하기 위한 프로토콜
    - ARP 캐시에 IP 주소와 MAC 주소 맵핑 관계가 캐싱되어 있음. 없으면 아래처럼 받아옴
    - “이 IP 주소 누구니?” 방송 요청 ⇒ “난데 내 MAC주소는 이거야” 응답 ⇒ 캐시에 저장

### IP주소 체계

- `IPv4`: 32비트를 8비트 단위로 점을 찍어 표기 (ex. `127.0.0.1`)
    - 표현할 수 있는 주소공간에 한계(32비트)가 있어 `IPv6`, `NAT`, `DHCP`가 등장함
- `IPv6`: 128비트를 16비트 단위로 콜론을 찍어 표기 (p109 오류)
    - 0000을 하나의 0으로 축약하거나 없애고 ‘:’만 남기기도 함
    - 예시: `2001:0DB8:0000:0000:0000:0000:0028:57ab` == `2001:DB8::28:57ab`
- `DHCP`: Dynamic Host Configuration Protocol. host가 네트워크에 연결할 때 동적으로 남는 IP 주소를 할당받도록 하는 프로토콜
- `NAT`: Network Address Translation. 패킷의 IP 주소 정보를 다른 IP 주소로 수정하는 기술
    - LAN 내 여러 host에 대해 사설 IP를 쓰게 하고, 외부 네트워크(ex. WAN)와 패킷을 주고받을 때는 하나의 공인 IP 주소를 사용함
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/33d7a3bd-8bc0-4ff5-83ac-736e703ac4e9/Untitled.png)
    

# 2.5 HTTP

애플리케이션 계층에서 클라이언트와 서버 간 통신을 위한 프로토콜

### HTTP/1.0

- 한 연결 당 하나의 요청만 처리 ⇒ 요청할 때마다 연결해야 함 ⇒ 매번 TCP 3-way handshake 해야 해서 RTT 증가
- RTT 감소를 위한 최적화 방법: 이미지 스플리팅, 코드 압축 등

### HTTP/1.1

- `Persistent`: 연결을 지속하여 기존 연결을 재사용 (keep-alive)
- `Pipelining`: 클라이언트가 서버의 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있음 (응답 순서는 요청 순서대로 오는 게 보장됨)
- `HOL Blocking`: 첫 번째 응답 RTT가 크면, 그 다음 응답들도 그만큼 지연되는 문제
- `큰 헤더 크기`: 헤더에 쿠키 등 많은 메타 데이터가 들어가 크기가 큰 문제

### HTTP/2

- `멀티플렉싱`: 하나의 TCP 연결에서 여러 스트림을 사용해 동시에 여러 요청/응답을 주고받음 ⇒ HTTP/1.1의 HOL Blocking 문제 해결
- `헤더 압축`: *HPACK 압축 알고리즘으로 헤더를 압축 (*허프만 코딩 알고리즘 사용)
- `서버 푸시`: 클라이언트가 요청하지 않은 리소스를 미리 전송할 수 있음

### HTTPS

- **데이터 전송 전에 패킷을 암호화**하여 HTTP의 보안을 강화한 프로토콜
- `SSL/TLS`: 전송 계층에서 보안을 제공하는 프로토콜로 보안 세션을 기반으로 데이터를 암호화함
- HTTPS 구축 방법
    - CA 인증서 발급하여 직접 서버 구축
    - 서버 앞단에 HTTPS를 제공하는 로드밸런서 두기 (ex. AWS ELB)
    - 서버 앞단에 HTTPS를 제공하는 CDN 두기 (ex. AWS CloudFront)

### HTTP/3

- `QUIC`: TCP 대신 UDP를 기반으로 하는 QUIC 프로토콜 사용 ⇒ 3-way handshake 과정 X ⇒빠른 연결, latency 감소
- `멀티플렉싱`
- `내장된 보안`: TLS 1.3이 기본적으로 통합됨

---

Q. 라우팅(routing)의 원형은 라우트(route)인데, 같은 스펠링에 다른 발음으로 “경로”을 의미하는 “루트”가 있다. 라우팅의 라우트와 루트는 의미가 서로 다른 것인가?

A. 네트워크에서의 라우트, 물리적 이동에서의 루트 둘 다 “경로”라는 공통된 의미를 가지고 있다. 발음이 다른 것 뿐…

## 정욱

## 4. IP 주소

### IP(Internet Protocol)

패킷 교환 방식 네트워크에서 사용하도록 설계된 통신 프로토콜이다. 헤더에 기록된 고정 길이의 출발지 및 도착지 주소 간에 패킷(또는 데이터그램)이라는 단위의 데이터를 송수신할 수 있는 기능을 제공한다. IP는 크게 ‘주소 지정’과 ‘패킷 분할 및 병합’의 두 가지 기능을 구현한다. 출발지에서 도착지로 패킷을 보내는 기능만을 제공하도록 제한되어있기 때문에 별도로 신뢰성을 보장할 수 있는 방법이 없으며(비신뢰성), 패킷 교환 방식 네트워크에서 사용하도록 설계되었기 때문에 별도로 연결을 설정하고 유지하지 않는다(비연결성).

2024년 현재 IP 체계는 IPv4와 IPv6의 2가지 버전이 주로 사용되며, 두 버전의 가장 큰 차이는 주소를 나타내기 위해 사용하는 비트의 개수와 그 표현 방식이다.

|  | IPv4 | IPv6 |
| --- | --- | --- |
| 출발지/도착지 비트 수 | 32비트 | 128비트 |
| 표현 가능한 주소 개수 | 약 4.20 × 10^9 가지 | 약 3.40 × 10^38 가지 |
| 표현 방식 | 온점(.)으로 구분된 0~255 사이의 십진수 4개(ex. 192.168.0.1) | 콜론(:)으로 구분된 4자리의 16진수 8개(ex. 2001:0db8:85a3:0000:0000:8a2e:0370:7334) |

<aside>
💡 비트 수에 따라 표현 가능한 주소 개수가 늘어나는 모습은 CPU 레지스터나 메인보드의 주소 버스, 운영체제의 워드 크기가 커짐에 따라 한 번에 처리할 수 있는 데이터의 양이나 인식 가능한 RAM 용량이 늘어나는 것과 비슷한 형태임을 알 수 있다!

</aside>

### IPv4 주소 지정

인터넷 프로토콜 스위트(TCP/IP) 도입 초반에는 IP 주소를 5가지의 클래스로 나누어 배분하는 Classful 방식을 사용하였으나, 이는 충분히 유연하지 못한 방식이었다. 예를 들어, 디바이스가 300개인 조직은 254개의 호스트를 지원하는 클래스 C 주소를 사용할 수 없어 65,534개의 호스트를 지원하는 클래스 B 주소를 신청한 후 65,234개를 비워둬야 했다. 이는 주소 공간의 낭비를 야기하여 사용 가능한 IP 주소를 빠르게 소진하는 원인이 되었다.

이러한 단점을 해소하기 위해 1993년 이후부터는 CIDR(Classless Inter-Domain Routing) 방식을 사용하고 있다. 예를 들어 `192.168.0.1/24`와 같은 형식으로 표기하며, `/` 뒤의 수를 활용하여 네트워크 영역을 구분할 수 있다. CIDR 값이 24이므로 앞에서부터 24비트는 네트워크 ID, 남은 8비트를 호스트 ID로 해석하여 해당 네트워크 내의 호스트 ID가 `192.168.0.0` ~ `192.168.0.255`까지임을 알 수 있다.

### NAT(Network Address Translation)

IP 주소 고갈은 IPv4의 근본적인 문제로, 이를 완벽히 해결하는 방법은 IPv6를 사용하는 것뿐이다. 그러나 IPv4 주소의 특정 범위를 사설 네트워크에서만 사용할 수 있도록 한정시켜 인터넷의 공인 IP 주소를 절약하고, 외부 공격으로부터 사용자의 네트워크를 보호할 수 있게 해준다. 이때 사설 네트워크에 속한 여러 호스트가 하나의 공인 IP 주소를 통해 인터넷에 접속할 수 있도록, IP 패킷의 헤더를 수정하여 네트워크 트래픽을 주고받는 기법을 NAT라고 한다.

### DHCP(Dynamic Host Configuration Protocol)

클라이언트-서버 아키텍처를 이용하여 네트워크에 연결된 호스트의 IP 주소와 기타 설정들을 자동으로 할당해주는 프로토콜이다. DHCP 서버는 가용 IP 주소 및 기본 게이트웨이, 도메인명, 네임서버, 타임서버 등을 관리하며, 일반적으로 운영체제에 내장된 DHCP 클라이언트가 질의한 요청에 대해 응답하여 정보를 제공해준다. 이때, IP 주소는 영구적으로 할당되지 않으며 일정 기간 이후에도 사용하고자 한다면 연장, 사용을 종료하고 싶다면 반납 절차를 수행해야 한다.

## 5. HTTP

HTTP는 **신뢰성 있는(Reliable) ‘전송 계층’ 또는 ‘세션 계층’ 연결을 통해 동작(Connection-oriented)**하는 프로토콜이다. HTTP/2까지는 **TCP**, HTTP/3부터는 **QUIC**를 기반으로 동작한다.

### TCP(Transmission Control Protocol)

전송 계층(OSI 4계층)에 위치하는 프로토콜로, 네트워크에 연결된 두 호스트 내 프로세스 간에 신뢰성 있는 연결 지향적 서비스를 제공한다. 전송 계층은 네트워크 데이터를 특정 애플리케이션으로 보내도록 지정하는 방법을 제공하는 인터페이스 역할을 한다. 전송 계층과 애플리케이션 간의 통로 역할을 하는 내부 주소를 **‘포트(Port)’**라고 부른다.

1. 신뢰성 있다(Reliable): PDU의 순서가 바뀌거나, 손실 또는 중복이 없도록 보장함
2. 연결지향적이다(Connection-oriented): 데이터 통신이 이루어지기 전에 세션 또는 반영구적 연결이 설정됨

TCP에는 데이터 처리 속도를 조절하여 수신자의 처리 속도보다 빨리 데이터를 보내지 못하도록 제어하는 **‘흐름 제어(Flow control)’**와 네트워크 내 대기 패킷 수를 줄여 혼잡을 방지하거나 제어하는 **‘혼잡 제어(Congestion control)’** 기능이 있다.

### TCP 3-Way Handshake / 4-Way Handshake

HTTP 프로토콜로 통신을 시작하기 앞서, 통신하려는 두 주체인 양쪽 호스트(보통 브라우저와 서버)가 **‘TCP 3방향 핸드셰이크’** 과정을 통해 TCP 소켓 연결을 수립한다. 실제 요청 이전에 3개의 추가적인 세그먼트가 성공적으로 수신되어야 하기 때문에 이러한 이름이 붙었다.

1. **SYN**: 호스트(일반적으로 브라우저)가 **SYN**chronize 세그먼트를 서버로 보낸다.
2. **SYN-ACK**: 서버는 **SYN**을 수신하고 **SYN**chronize-**ACK**nowledgement 세그먼트를 다시 보낸다.
3. **ACK**: 호스트는 **SYN-ACK**을 수신하고 **ACK**nowledge 세그먼트를 다시 보낸다. 서버가 **ACK**를 수신하면 TCP 소켓 연결이 설정된다.

TCP 연결을 안전하게 종료하기 위해서, 통신을 진행하던 두 주체인 양쪽 호스트는 **‘TCP 4방향 핸드셰이크’** 과정을 진행해야 한다. 연결이 종료되기 전에 4개의 세그먼트가 성공적으로 수신되어야 하기 때문에 이러한 이름이 붙었다.

1. **FIN**: 연결을 먼저 요청한 호스트(이하 클라이언트)가 연결을 요청받은 호스트(이하 서버)에게 **FIN**ish 세그먼트를 보낸다.
2. **ACK**: 서버는 **FIN**을 수신하고 확인했다는 의미의 **ACK** 세그먼트를 클라이언트에게 보낸다. 아직 남은 데이터가 있다면 마저 전송을 마친다.
3. **FIN**: 데이터 전송이 끝났다면 이번엔 서버가 클라이언트에게 FIN 세그먼트를 보낸다.
4. **ACK**: 클라이언트는 **FIN**을 수신하고 확인했다는 의미의 ACK 세그먼트를 보낸 후, 아직 받지 못한 데이터가 있을 수 있으므로 기다린다. 서버는 **ACK**를 수신한 후 소켓을 닫으며, 클라이언트는 정해진 시간이 지난 후 소켓을 닫는다.

### TLS(Transport Layer Security)

개인 정보와 데이터 보완을 용이하게 하기 위해 설계된 암호화 프로토콜로, SSL(Secure Sockets Layer)에서 발전하였다. 제3자로부터 전송되는 데이터를 숨기는 **암호화**, 정보를 교환하는 당사자가 요청된 당사자임을 보장하는 **인증**, 데이터가 위변조되지 않았음을 확인하는 **무결성**을 달성한다. HTTP

### TLS Handshake

TLS 암호화를 사용하는 통신 세션을 수립하기 위해서는 TLS 핸드셰이크를 수행해야 한다. TLS 핸드셰이크는 TCP 3방향 핸드셰이크 과정이 진행되어 TCP 연결이 수립된 후 발생한다.

1. **ClientHello**: 클라이언트가 서버로 Hello 메시지를 전송한다.
    - 클라이언트가 지원하는 TLS 버전 및 암호화 방식, 대칭키를 만들기 위한 ‘클라이언트 무작위 값’ 등을 함께 보낸다.
2. **ServerHello**: 클라이언트의 Hello에 대한 응답으로 서버 클라이언트에게 또한 Hello 메시지를 전송한다.
    - 서버의 TLS 인증서 및 암호화 방식, ‘서버 무작위 값’ 등을 함께 보낸다.
3. **ClientKeyExchange**: 클라이언트가 인증서 발행 기관을 통해 인증서가 무결한지 검증했다면, 클라이언트와 서버의 무작위 값을 조합하여 ‘예비 마스터 암호(premaster secret)’를 만든 후 자신의 공개키로 암호화하여 서버로 전송한다. 이 값을 사용하여 세션에 사용될 대칭키를 생성한다.
4. **ChangeCipherSpec**: 이후 이루어지는 모든 통신은 핸드셰이크 과정에서 합의된 알고리즘과 대칭키를 이용하여 암호화된다.

### QUIC

기존 HTTPS 통신은 TCP와 TLS 세션 수립을 위해 두 번의 핸드셰이크 과정이 필요하며, 이 과정에서 불필요한 왕복이 일어나므로 RTT(Round Trip Time, 왕복 시간)를 줄이기 위해 비효율적인 단계를 줄일 필요가 있다. QUIC은 전송 프로토콜로 UDP를 채택하여 그 위에 구현한 프로토콜로, TCP에 존재하는 여러 신뢰성 및 흐름/혼잡 제어 등의 기능을 제공한다.
