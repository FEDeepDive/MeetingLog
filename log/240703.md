## 보경

## 미림

# 복잡도

- `시간복잡도`: 알고리즘을 실행하는 데 걸리는 시간 (주로 빅오표기법으로 표기)
- `공간복잡도`: 알고리즘을 실행하는 데 필요한 공간의 양
- `빅오표기법`: 입력 범위가 n일 때 알고리즘의 증가율 (최고차항만 남기고 모두 제거)
- 목적: 복잡도를 통해 알고리즘의 효율을 따질 수 있음

# 선형 자료구조

선형 자료구조란, 데이터를 일렬로(linearly, sequentially) 저장하는 자료구조를 의미한다.

### 배열

- **같은 타입**의 값들을 **순서대로** 나열한 구조
- 배열을 구성하는 `요소`는 배열에서 위치를 가리키는 `인덱스`와 대응됨 (ex. 배열의 n번째 요소)
- 값은 중복 가능

### 연결 리스트

- 값들을 노드로 감싸고, 노드와 노드를 포인터로 연결한 구조
- 각각의 **`노드`**는 `데이터`와 다른 노드를 가리키는 **`포인터`**를 가짐
- 구분
    - 단일 연결 리스트: `next` 포인터를 가짐
    - 이중 연결 리스트: `prev`, `next` 포인터를 가짐
    - 원형 연결 리스트: 리스트의 마지막 노드 `tail`의 `next` 포인터가 첫 노드 `head`를 가리킴
- JS로 구현 (단일 연결 리스트)
    
    ```jsx
    // 연결 리스트를 구성하는 노드
    class Node {
      constructor(data) {
        this.data = data;
        this.next= null; // 다음 노드를 가리키기 위한 포인터
      }
    }
    
    // 단일 연결 리스트
    class SingleLinkedList {
      constructor() {
        this.head = null;
        this.tail = null;
      }
      
      // 연결 리스트 맨 뒤에 노드를 추가 (O(1))
      push(data) {
        const newNode = new Node(data);
        
        if (!this.head) {
          this.head = newNode;
          this.tail = newNode;
        } else {
    	    this.tail.next = newNode;
    	    this.tail = newNode;
    	  }
    	  
    	  return this;
      }
      
      // 연결 리스트 맨 뒤의 노드를 삭제 (O(1))
      pop() {
        if (!this.head) return undefined;
        
        if (this.length === 1) {
          const lastNode = this.head;
    	    this.head = null;
    	    this.tail = null;
    	    return lastNode;
        }
        
        let currentNode = this.head;
        let secondToLastNode = this.head;
        while(currentNode.next) {
    	    secondToLastNode = currentNode;
          currentNode = currentNode.next;
        }
        this.tail = secondToLastNode;
        this.tail.next = null;
        
        return currentNode;
      }
    }
    ```
    

### 스택

- 가장 마지막에 추가된 값이 가장 먼저 삭제되는 성질(LIFO)을 갖는 구조

### 큐

- 가장 먼저 추가된 값이 가장 먼저 삭제되는 성질(FIFO)을 갖는 구조

### 💡 시간복잡도 비교 표

|  | 배열 | 연결 리스트 | 스택 | 큐 |
| --- | --- | --- | --- | --- |
| 요소 접근 | O(1) | O(n) | O(n) | O(n) |
| 탐색 | O(n) | O(n) | O(n) | O(n) |
| 삽입 | O(n) | O(1) | O(1) | O(1) |
| 삭제 | O(n) | O(1) | O(1) | O(1 |

## 정욱

## 1. 복잡도

### 계산 복잡도와 점근 표기법

**`계산 복잡도(Computational complexity)`**는 **`알고리즘을 실행하는 데 필요한 자원의 양`**을 의미하며, 이는 실행 환경에 따라 다르게 측정될 수 있기 때문에 일반적으로 입력의 크기 `n`에 대한 함수 `n → f(n)` 형태로 표현한다.

계산 복잡도는 입력의 크기가 커질수록 중요해지기 때문에 `n`이 충분히 큰 경우에만 의미 있는 비교를 할 수 있다. `n`이 충분히 클 경우 복잡도를 단순하게 나타낼 수 있는 방법이 여러 가지 있는데, 이러한 표기법을 통틀어 `점근적 표기법(Asymptotic notation)`이라고 부른다.

일반적으로는 `n`이 무한대에 점점 가까워지더라도 넘을 수 없는 한계인 **`점근적 상한(Asymptotic upper bound)`**을 나타낼 때 사용되는 `빅 오 표기법(Big-O notation)`이 주로 사용된다.

### 시간 복잡도

인간이 일반적으로 사용하는 시간 단위는 미시적으로는 기계의 선택, 거시적으로는 기술의 진화에 영향을 매우 크게 받기 때문에 복잡도 계산에서는 사용할 수 없다. 따라서 실행할 때 입력의 크기에 영향을 받지 않는 일정한 길이의 시간이 걸리는 기본 연산(또는 단계)이 있다고 가정하여, 이 기본 연산의 횟수를 세는 것으로 대신한다.

| 많이 다루어지는 시간 복잡도 | 예시 |
| --- | --- |
| 상수 시간 - O(1) | 정수의 홀/짝 여부 판별, 배열 요소 접근 |
| 로그 시간 - O(log n) | 이진 탐색 |
| 선형 시간 - O(n) | 정렬되지 않은 자료 구조에서 특정 원소 탐색 |
| 선형 로그 시간 - O(n log n) | 병합 정렬, 힙 정렬, 고속 푸리에 변환 |
| 이차(또는 제곱) 시간 - O(n²) | 버블 정렬, 삽입 정렬 |
| 지수 시간 - O(2ⁿ) | 조합(Combination) |

### 공간 복잡도

문제를 해결하는 데 필요한 메모리 공간의 양으로, 알고리즘의 실행이 완전히 종료될 떄까지 필요한 메모리를 뜻한다. 공간 복잡도와 시간 복잡도는 일반적으로 반비례하는 경향이 있다.

## 2. 선형 자료 구조

자료들 간의 앞/뒤 관계가 일대일의 선형 관계를 가지고 있어, 각 자료가 연속적으로 나열되는 자료 구조를 뜻한다.

### 배열(Array) vs. 연결 리스트(Linked list)

|  | 배열 | 연결 리스트 |
| --- | --- | --- |
| 특징 | 정해진 크기만큼 자료가 일렬로 저장되는 정적 자료구조로, 각 자료를 가리키는 번호인 인덱스(index)를 가진다. | 크기가 정해지지 않으며 각 자료가 연속적으로 저장될 필요가 없는 동적 자료구조로, 다음 자료가 저장된 위치를 함께 가진다. |
| 접근 시간 복잡도 | O(1)  | O(n) |
| 탐색 시간 복잡도 | O(n)  | O(n)  |
| 삽입 시간 복잡도 | O(n) | O(1) |
| 삭제 시간 복잡도 | O(n)  | O(1) |

### 스택(Stack) vs. 큐(Queue)

|  | 스택 | 큐 |
| --- | --- | --- |
| 특징 | Last In First Out(LIFO, 후입선출), 자료가 추가된 순서의 역순으로 처리되어야 할 때 사용함 | First In First Out(FIFO, 선입선출), 자료가 추가된 순서를 유지하며 처리되어야 할 때 사용함 |
| 삽입/삭제 연산명 | push, pop  | enqueue, dequeue |
| 주요 사용처 | 함수 콜 스택, 깊이 우선 탐색, 실행 취소, 브라우저 방문 기록 등 | 스케줄링(태스크 큐, 메시지 큐 등) 너비 우선 탐색 등 |

> 이름 때문에 혼동할 수 있지만, `우선순위 큐(Priority queue)`는 FIFO 방식으로 동작하지 않기 때문에 일반적인 의미의 큐에 포함된다고 볼 수 없다!
> 

<aside>
💡 배열과 연결 리스트를 이용하여 스택/큐 등을 구현할 수 있지만, 그 반대는 불가하다. 이는 곧 배열과 연결 리스트가 선형 자료구조의 근간을 이루는 기초 구성 요소이며, 스택/큐 등은 그 응용으로 생각할 수 있지 않을까? 배열과 연결 리스트, 스택과 큐 등을 같은 선상에서 다루는 것이 옳은 방향일까?

</aside>

## 영은

### 시간 복잡도

입력 크기에 대해 어떤 알고리즘이 실행되는데 걸리는 시간.
데이터가 많아질수록 얼마나 급격히 시간이 증가하는지. 
인풋 크기에 비례하는 알고리즘의 실행 시간

효율적인 코드로 개선하는데 쓰이는 척도가 된다.

### 빅오 표기법

식에서 가장 영향력이 높은 애 빼고 다 지운 표기 법, 최악의 시간

### 공간 복잡도

인풋 크기에 비례해서 알고리즘이 사용하는 메모리 공간

### 선형 자료구조

요소가 일렬로 나열된 자료구조
ex. 배열, 연결 리스트( 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트), 스택, 큐 등

**연결리스트 문제**

**다음 중 링크드 리스트에 관한 내용으로 옳지 않은 내용을 고르시오.**

**1.** 링크드 리스트는 배열과 같이 데이터를 순서대로 저장해주는 자료 구조다.

**2.** 링크드 리스트는 각 노드가 다음 노드에 대한 레퍼런스만 저장하는지, 아니면 다음과 전 노드에 대한 레퍼런스를 모두 저장하는지에 따라 싱글리 링크드 리스트와 더블리 링크드 리스트로 구별할 수 있다.

**3.** 링크드 리스트 노드들은 메모리에 연속적이거나 순서대로 저장되지는 않는다. 메모리 이곳저곳 아무 데나 저장돼 있을 수 있다.

**4.** 싱글리 링크드 리스트는 배열과 같이 처음부터 크기를 정해야 되고, 이보다 더 많은 데이터를 저장할 수 없다.

**5.** 파이썬에서는 노드 클래스를 정의하고, 인스턴스들을 만들어서 연결하면 링크드 리스트를 구현할 수 있다.

- 정답
    
    <aside>
    4️⃣ 싱글리 링크드 리스트는 처음에 크기를 정하지 않아도 그냥 새로운 노드를 만들어서 기존 노드들에 연결만 시켜주면 계속해서 새로운 데이터를 더해줄 수 있다.
    
    </aside>
    

**다음 중 싱글리 링크드 리스트와 더블리 링크드 리스트 연산들에 대한 내용 중 틀린 것을 고르시오.**

**1.**싱글리 링크드 리스트의 tail 노드를 삭제하려면 tail 노드 전 노드에 접근해서 tail 노드를 삭제하는 데 총  𝑂(𝑛)*O*(*n*)의 시간이 걸린다.

**2.**더블리 링크드 리스트는 맨 앞과 맨 뒤에 삽입이나 삭제하는 4 개의 연산들을 모두 𝑂(1)*O*(1)으로 할 수 있다.

**3.**싱글리와 더블리 링크드 리스트의 삽입과 삭제 연산은 𝑂(1)*O*(1)이 걸리기 때문에 새로운 데이터를 계속 저장해주는 연산은 무조건적으로 동적 배열보다 효율적이라고 할 수 있다.

**4.**링크드 리스트의 탐색 연산은 동적 배열과 같이 처음부터 끝까지 모든 데이터를 하나씩 보는 선형 탐색 방법을 쓴다.

**5.**가장 앞 순서에 데이터를 많이 삽입해야 되는 경우에는 싱글리 링크드 리스트가 동적 배열보다 더 효율적이다.

- 정답
    
    <aside>
    3️⃣ 싱글리와 더블리 링크드 리스트 일반적인 경우의 삽입 삭제 연산들은 파라미터로 노드를 받습니다. 이 노드를 가지고 있으면 삽입과 삭제 연산을 𝑂(1)*O*(1)으로 할 수 있는 거죠. 하지만 실질적으로는 이 노드를 가지고 오는데 최악의 경우 𝑂(𝑛)*O*(*n*)이 걸립니다. 그러니까 필요한 노드를 가지고 온 후, 삽입 삭제 연산들을 하는 총 시간을 따지고 보면 𝑂(𝑛)*O*(*n*)이 걸리는 거죠.
    
    필요한 노드를 한 번에 바로 가지고 올 수 있는 경우나, 이미 필요한 노드를 가지고 있는 경우를 제외하고는 동적 배열보다 항상 효율적이라고 할 수는 없습니다.
    
    </aside>
    

**배열 문제**

**다음 중 옳지 않은 내용을 고르세요.**

**1.**배열은 정의할 때부터 수용 가능 항목 수가 정해져 있고, 바꿀 수 없다.

**2.**배열은 인덱스를 통해서 데이터를 저장 및 접근하는 자료 구조다.

**3.**배열을 만들면 컴퓨터 메모리에서 사용 가능한 공간에 값들이 순서대로, 그리고 연속적으로 저장된다.

배열의 범위를 벗어나는 인덱스를 사용할 수 있고 사용해도 된다.
**4.** 배열의 범위를 벗어나는 인덱스를 사용할 수 있고 사용해도 된다.

**5.**배열의 특정 인덱스에 접근해서 항목을 받아오거나 수정하는 데 드는 시간 복잡도는 𝑂(1)*O*(1) 이다.

- 정답
    
    <aside>
    4️⃣ 배열은 처음 정해 놓은 범위를 벗어나는 인덱스를 사용하면 안됨
    
    </aside>
    

**배열 `int_array`의 주소가 10000이고, 정수 자료형의 크기가 4 바이트이면, `int_array[300]`의 주소를 계산하세요.**

- 정답
    
    <aside>
    👉 11200
    
    배열은 데이터를 연속적이고 순차적으로 저장해 놓기 때문에
    
    1. 배열의 시작 주소
    2. 저장하는 자료형의 크기
    3. 인덱스
    
    이 세 가지만 알면 원하는 인덱스의 주소를 계산할 수 있습니다.
    
    > 배열 시작의 주소 + (인덱스 * 저장하는 데이터 자료형 크기)
    > 
    
    이렇게 원하는 인덱스의 주소를 𝑂(1)*O*(1)으로 계산하면 되고, 이 주소로 해당 메모리에 접근할 수 있습니다.
    
    </aside>
    

**다음 중 동적 배열을 사용하는 게 가장 부적절한 경우를 고르세요.**

**1.**순위 정보를 담아 놓고, 저장해 놓은 데이터에 접근해야 될 때.

**2.**게임 프로그램에서 캐릭터가 죽을 때마다 게임 이벤트 기록을 추가해야 될 때.

온라인 상담소에서 접수가 들어오는 순서대로 저장하고, 가장 앞에 있는 문의부터 처리하고 지워야 될 때.

**3.**온라인 상담소에서 접수가 들어오는 순서대로 저장하고, 가장 앞에 있는 문의부터 처리하고 지워야 될 때.

- 정답
    
    <aside>
    3️⃣
    
    </aside>
