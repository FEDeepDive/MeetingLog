## 보경

## 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

**웹접근성이란?**

- 웹 콘텐츠나 웹 기술에 대한 모든 사용자의 동등한 접근을 보장하는 것

**웹 접근성을 높이는 방법**

- 시각적으로 숨겨진 콘텐츠에 대한 대체 텍스트 제공하기
- 콘텐츠의 명도나 색상 대비 사용
- 이미지의 alt 속성 넣기
- role 속성 부여
- 적절한 텍스트 링크 제공
- 텍스트 크기 조절
- 비디오태그 자막 삽입
- **키보드로 모든 기능 사용 가능하게 하기**

## 검색 엔진 최적화(Search Engine Optimization, SEO)에 대해 알고 있나요?

(정리하며서 느낀건데 검색엔진 최적화가 뭔지보다는 색인이 잘되는 코드를 짜는게 개발자 입장으로서 더 중요할듯)

**검색 엔진 최적화(Search Engine Optimization, SEO)**

웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정

**검색엔진 최적화를 위해 개발자가 해야할 작업**

- SSR 도입하기
- 크롤링 봇이 인지하기 쉬운 적절한 시멘틱 태그를 사용
- 메타 태그 잘 활용하기(description, og, robots )
- 표준적인 하나의 URL 설정
- 이미지의 alt 속성 기재하기

## 이벤트

**이벤트 객체**

- 이벤트에 관련된 다양한 정보를 가진 객체
- 이벤트가 발생하면 생성되며, 이벤트 핸들러의 첫번째 인수로 전달된다.
- **`type`**, **`target`**, **`currentTarget`**, **`bubbles`** 등의 프로퍼티를 갖는다.

**이벤트 핸들러**

이벤트가 발생했을 때 호출될 함수

**이벤트 바인딩**

이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

**이벤트 타입**

- 이벤트의 종류를 나타내는 문자열
- 마우스, 키보드, 포커스, 폼 등이 있다.

**이벤트 타겟**

- **`e.target`** : 이벤트를 발생시킨 엘리먼트
- **`e.currentTarget`** : 현재 이벤트가 발생된 엘리먼트

**이벤트 전파(Propagation)**

브라우저는 특정 화면 요소(DOM 요소 노드)에서 이벤트가 발생했을 때 그 이벤트객체가 DOM 트리를 통해 전파되는 것

**이벤트 전파의 단계**

- 캡쳐링 단계(capturing phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계(target) : 이벤트가 이벤트 타깃에 도달
- 버블링 단계(bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

**이벤트 전파를 막는법**

- **`e.preventDefault()`** : 브라우저 고유의 동작을 중단시킴 즉 기본 이벤트를 막아줌( ex) a 태그의 href 이동, form 태그의 새로고침)
- **`e.stopPropagation()`** : 해당 이벤트가 다음 상위 요소로 전파되는 것을 막아줌(사용자가 발생한 이벤트를 막음)
- **`e.stopImmediPropagation()`** : **`e.stopPropagation()`** 와 동일하나 이벤트가 발생한 동일한 요소의 다른 이벤트들까지막아줌

**이벤트 위임(delegation)**

버블링의 특성을 활용하여 자식 요소마다 이벤트를 등록하지 않고 부모 요소에 이벤트를 등록하여 이벤트를 위임하는 방법.
위임 사용 이유 ) DOM 요소가 동적으로 추가되거나 삭제될 때마다 이벤트 리스너를 추가하거나 삭제한다면, 코드의 효율성이 떨어지므로 이벤트 위임 사용.
단 버블링이 되지 않는 이벤트는 사용불가. 버블링이 되지 않는 이벤트는 캡쳐링 단계에서 이벤트를 처리하는 요소들인데 보통 잘 사용 안함

## 미림

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

- **웹 접근성이란?**
    - 장애인, 고령자 등이 웹사이트에서 제공하는 정보를 비장애인과 동등하게 접근하고 이용할 수 있도록 보장하는 것
    - 여기서 장애인이란, 일반적으로 생각하는 장애뿐만 아니라, 웹에 접근하는 데 영향을 주는 일시적인 장애 상태(ex. 팔이 부러진 사람)와 환경적 제약(ex. 밝은 햇빛)을 포괄함
- **웹 접근성을 높이는 방법**
    - 콘텐츠의 의미, 용도를 나타내는 텍스트를 제공한다 (ex. 레이블, 대체 텍스트, 제목)
    - 미디어 콘텐츠에는 **대체 텍스트**를 제공한다
    - 마크업의 **오타, 오류를 방지**한다
    - 의미가 있는 이미지를 배경 이미지(background-image)로 제공하지 않는다
    - **콘텐츠 내용은 색상에 의존하지 않는다** (ex. 그래프, 차트, 필수 입력 사항 등)
    - 소리가 있는 콘텐츠에 **자막/수화/원고**을 제공한다
    - 소리가 있는 콘텐츠는 **자동 재생을 금지하고**, 사용자가 의도했을 때 재생되게 한다
    - 모든 기능은 **키보드만으로 조작**이 가능해야 한다 (마우스 커서 궤적이 중요한 콘텐츠 제외)
    - 사용자 입력과 버튼 등의 조작은 충분한 크기로 서로 여백을 두고 제공한다
    - 시간 제한이 있는 콘텐츠가 있다면, 사전에 알리고, **시간 연장 수단을 제공**한다
- 참고
    - [주니어 디자이너가 꼭 알아야 할 '웹 접근성'](https://yozm.wishket.com/magazine/detail/1942/)
    - [네이버 널리](https://nuli.navercorp.com/)

## 6. 검색 엔진 최적화(Search Engine Optimization, SEO)에 대해 알고 있나요?

```
💡 검색 엔진 최적화(SEO)는 검색 엔진이 자료를 수집하는 방식에 맞게 웹 페이지를 구성하는 것을 말합니다. 검색 엔진 최적화를 통해 사용자가 원하는 콘텐츠를 쉽게 찾을 수 있게 하고, 웹 페이지가 검색 결과 상위에 나올 가능성을 높일 수 있습니다.

```

- **개념**
    - 검색 엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성하는 것
- **목적**
    - 사용자(+검색 엔진)가 원하는 콘텐츠를 쉽게 찾을 수 있도록 함
    - 웹 페이지가 검색 결과의 상위에 나올 가능성을 높이기 위함
- **최적화 방법**
    - 유의미한 URL 사용
        - good: `https://www.example.com/pets/cats`
        - bad: `https://www.example.com/2/6772756D`
    - 유용한 콘텐츠 제공
        - 시맨틱 태그 사용
        - 탐색에 도움이 되는 텍스트 제공 (ex. 대체 텍스트, 캡션 등)
        - 고유한 콘텐츠 (다른 사람이 이미 게시하지 않은)
        - 최신 콘텐츠
        - \*신뢰 가능한 콘텐츠
    
    ```
    💡 구글 검색 엔진 봇은 출처 링크가 포함되어 있으면 신뢰 가능한 콘텐츠로 판단하지만, 네이버는 오히려 스팸으로 간주한다.
    
    ```
    
    ```
    💡 검색엔진 봇이 모든 `meta` 태그를 유의미하다고 인식하는 것은 아니다.
    
    ```
    

## 7. 이벤트

### 이벤트 바인딩

- 어떤 요소의 이벤트에 이벤트 핸들러 함수를 연결하는 것
- 바인딩 방법
    - 1️⃣인라인 이벤트 핸들러
        
        ```html
        <div onclick="handleClick()"></div>
        
        <script>
          function handleClick() {
            console.log(this); // window
            console.log(event.currentTarget); // <div onclick='handleClick()'></div>
          }
        </script>
        
        ```
        
        - `html`과 `javascript`의 관심사가 분리되지 않는 문제
        - 이벤트 핸들러 내부 `this`가 `window`를 가리킴 ⇒ 의도하지 않은 문제가 발생할 수 있음
        - 🚨더이상 쓰이지 않음!
    - 2️⃣이벤트 핸들러 프로퍼티
        
        ```html
        <div></div>
        
        <script>
          const div = querySelector('div');
          div.onclick = function handleClickA() {}; // 무시됨
          div.onclick = function handleClickB() {}; // 덮어씀
        </script>
        
        ```
        
        - 마지막에 등록한 프로퍼티가 기존 값을 덮어씀
        - 크로스 브라우저 호환성이 높음 (IE 8만큼 옛날 브라우저에서도 지원됨)
    - 3️⃣`addEventListener()` 메서드
        
        ```html
        <div></div>
        
        <script>
          const div = querySelector('div');
          div.addEventListener('click', handleClickA);
          div.addEventListener('click', handleClickB);
        
          div.removeEventListener('click', handleClickB);
        </script>
        
        ```
        
        - 깉은 타입에 대한 여러 리스너를 하나의 요소에 등록할 수 있음
        - `removeEventListener()`를 이용해 연결된 이벤트 리스너를 해제할 수 있음

### 이벤트 전파: 캡처링 vs. 버블링

같은 이벤트 타입의 두 이벤트 핸들러가 한 요소에 작동했을 때 일어나는 메커니즘

- **캡처링**: `최상위 요소`부터 `실제로 선택된 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **버블링**: `실제로 선택된 요소`부터 `최상위 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **이벤트 전파 막기**: `event.stopPropagation()`을 이용해 이벤트 전파를 막을 수 있음

```
💡 버블링과 캡처링 이벤트가 동시에 존재하는 경우, 캡처링이 먼저 실행되고 그 후 버블링이 실행된다.

```

```
💡 거의 모든 이벤트는 버블링 되지만, `focus` 이벤트와 같이 버블링되지 않는 이벤트도 있다.
캡처링을 강제로 발생시키려면 `addEventListener`의 `capture` 옵션을 `true`로 설정해야 한다.

```

```html
<div>
  <button>
    <span>Click Me!</span>
  </button>
</div>

<script>
  const div = document.querySelector('div');
  const btn = document.querySelector('button');

  div.addEventListener('click', (e) => alert('div 캡처링'), true); //-----(a)
  div.addEventListener('click', (e) => alert('div 버블링')); //-----------(b)
  btn.addEventListener('click', (e) => alert('button 캡처링'), true); //--(c)
  btn.addEventListener('click', (e) => alert('button 버블링')); //--------(d)
</script>

```

예를 들어 위 코드에서 `<button>` 클릭 시, 이벤트 캡처링이 먼저 일어나고, 그 다음 버블링이 일어나, (a) → (c) → (d) → (b) 순서로 실행된다. 등록된 이벤트가 없는 `<span>`을 클릭해도 마찬가지이다.

### `event.target` vs. `event.currentTarget`

- `event.target`: 이벤트가 시작되게끔 트리거 역할을 한 요소
- `event.currentTarget`: 이벤트 핸들러가 할당된, 실질적으로 이벤트를 발생시킨 요소(=이벤트 핸들러 내의 `this`)

### 이벤트 위임 (Event Delegation)

- 여러 개의 자식 요소에 동일한 구조의 이벤트 핸들러를 할당하고 싶을 때, 모든 자식 요소에 이벤트 핸들러를 할당하지 않는 대신 **부모 요소에 이벤트 핸들러를 할당**하고 **`event.target`으로 자식 요소를 컨트롤**하는 방법
- 이벤트 위임은 이벤트 버블링에 의한 이벤트 전파를 이용한 디자인 패턴임

## 정욱

# 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

### 웹 접근성

모든 사용자가 특정 환경이나 신체적 장애에 상관없이 웹사이트나 웹 애플리케이션에서 제공하는 모든 정보에 동등하게 접근하고 이용할 수 있도록 보장해주는 것이다. W3C가 관리하는 [웹 콘텐츠 접근성 지침](https://www.w3.org/TR/WCAG21/)은 4가지 원칙의 범주로 분류하여 제공되고 있으며, 이러한 지침을 준수하기 위해 노력하면 웹 접근성을 높일 수 있다.

AOA11Y 채널

| 인식의 용이성(Perceivable) | 정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다. |
| --- | --- |
| 운용의 용이성(Operable) | 사용자 인터페이스 구성요소 및 네비게이션은 운용 가능해야 한다. |
| 이해의 용이성(Understandable) | 사용자 인터페이스의 정보와 운용은 이해 가능해야 한다. |
| 견고성(Robust) | 콘텐츠는 보조 기술을 포함한 다양한 사용자 에이전트가 해석할 수 있을 정도로 견고해야 한다. |

### 적용할 수 있는 여러 가지 방법들

1. 이미지, 로고, 그림 등의 그래픽을 인식할 수 없는 사용자나, 표현할 수 없는 기기를 위해 대체 텍스트 사용하기
2. 텍스트나 이미지를 더 쉽게 읽고 이해할 수 있게 만들기 위해 높은 색상 대비 사용하기
3. 헤더 태그(`h1` ~ `h6`)를 사용해 문서 정리하기
4. `form` 입력 요소에 레이블 적용하기
5. 개발자가 의도한 사용자 인터페이스 상호작용이나 구조적인 정보를 스크린 리더와 같은 보조 기술에 전달하여, 시각/인지 장애인들에게 비장애인들과 동일한 사용자 경험을 제공하는 WAI-ARIA 활용하기

# 6. 검색 엔진 최적화(Search Engine Optimization, SEO)에 대해 알고 있나요?

검색 엔진 최적화는 웹사이트가 검색 엔진에서 상위에 노출될 수 있도록 최적화하는 과정을 말한다.

### `robots.txt`

검색 엔진 크롤러의 동작을 제어하여 트래픽을 관리할 수 있는 설정 파일이다. 크롤러의 중복 페이지 수집을 막고, 불필요한 페이지의 크롤링을 제외하여 의미있는 콘텐츠를 크롤링할 수 있도록 설정할 수 있다.

### `sitemap.xml`

일반적인 크롤링 과정에서 쉽게 발견되지 않는 페이지도 문제없이 크롤링되고 색인될 수 있게, 웹사이트 내 모든 페이지의 목록을 나열한 파일이다.

### OpenGraph

HTML 문서의 메타정보를 구조화된 형태로 쉽게 표시할 수 있도록 페이스북에서 정의한 프로토콜이다.

### SSR을 활용한 SEO

Client Side Rendering의 경우, 최초로 로드된 HTML 파일의 내용이 비어있어 웹 크롤러가 페이지에 접속해도 의미있는 정보를 얻을 수 없다. SSR을 적용하면 서버에서 의미있는 콘텐츠를 먼저 렌더링해서 전달할 수 있기 때문에, 크롤러가 웹 페이지의 콘텐츠와 메타 태그 등의 정보를 읽을 수 있어 SEO에 유리해진다.

# 7. 이벤트

프로그래밍에서 이벤트란, 시스템에서 일어나는 사건을 말한다. 시스템은 어떠한 사건이 일어나면 그에 맞는 형태의 `신호`를 생성하고, 이에 따라 자동으로 `특정한 코드`가 실행될 수 있게 하는 방법을 제공한다. 여기서 `신호`를 ‘이벤트’, `특정한 코드`를 ‘이벤트 핸들러(또는 이벤트 리스너)’라고 한다. 웹 프론트엔드 프로그래밍에서 이벤트는 일반적으로 브라우저 이벤트를 의미하며, 자세한 종류는 MDN의 [이벤트 레퍼런스](https://developer.mozilla.org/en-US/docs/Web/Events) 문서나 [이벤트 인터페이스 목록](https://developer.mozilla.org/en-US/docs/Web/API/Event#interfaces_based_on_event)을 통해 확인할 수 있다.

### 이벤트 바인딩

`특정한 코드`를 이벤트가 발생했을 때 실행시키기 위해서 해당 이벤트에 ‘등록’하게 되며, 이러한 행위는 곧 이벤트와 이벤트 핸들러를 하나로 ‘묶어서’ 다룬다고 볼 수 있기 때문에 이를 ‘이벤트 바인딩’이라고 부른다. 브라우저 상의 이벤트와 이벤트 핸들러를 바인딩하는 방법은 크게 3가지가 있다.

1. HTML 요소의 이벤트 속성 값을 이벤트 핸들러의 호출 결과로 지정해주기
2. DOM 요소의 이벤트 프로퍼티 값에 이벤트 핸들러를 사용하는 함수를 지정해주기
3. `EventTarget` 인터페이스를 구현하는 DOM 요소 객체들의 `addEventListener` 함수에 이벤트 핸들러를 인수로 전달하기

1번 방식은 HTML과 JS의 혼용이 이루어지고, 2번 방식은 한 번에 하나의 이벤트 핸들러만 등록된다는 단점이 있기 때문에 3번이 더 권장되는 방식이다!

### 이벤트 전파

하나의 요소에 이벤트가 발생하면 가장 최상단의 조상 요소를 만날 때까지 거슬러올라가며 요소 각각에 할당된 이벤트 핸들러가 동작한다. 이러한 동작이 마치 거품이 아래에서 위로 올라오는 모양과 닮아있기 때문에 이벤트 버블링이라고 부른다. `onfocus` 등의 특수한 이벤트 외의 거의 모든 이벤트는 버블링된다.

이와 반대로, 최상단 요소부터 이벤트가 발생한 요소를 찾아 내려가는 과정을 캡처링이라고 한다. `addEventListener` 함수로 이벤트 핸들러를 등록할 때 추가 인자로 `{ capture: true }`를 제공해주면 캡처링 과정에서도 이벤트 핸들러가 동작한다.

이벤트가 발생한 요소를 가리키고 싶은 경우, `Event` 인터페이스의 두 가지 속성 `event.target`과 `event.currentTarget`을 사용할 수 있다.

| event.target | event.currentTarget |
| --- | --- |
| 실제로 이벤트를 발생시킨 요소 | 이벤트 핸들러가 등록된 요소이며, event.target에서부터 이벤트 버블링이 일어나기 때문에 event.target과 서로 다른 값일 수 있음 |

이벤트 버블링의 존재 덕분에, 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 부모 요소에 한 번만 이벤트 핸들러를 바인딩한 후, `event.target` 속성을 통해 자식 요소 중 실제로 어떤 요소가 이벤트를 발생시켰는지 구분하는 **이벤트 위임** 방식을 사용할 수 있다.

이벤트 전파를 막기 위해서는 `Event` 인터페이스의 `stopPropagation()` 함수를 사용하면 된다. 같은 이벤트 에 등록된 다른 핸들러의 동작도 함께 막고 싶다면 `stopImmediatePropagation()` 함수를 사용하면 된다.
