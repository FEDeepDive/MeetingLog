## 보경

리액트에서 UI 를 구성하는 작은 코드 조각인 컴포넌트를 선언하기 위한 두가지 방법

**클래스형 컴포넌트**

- 상태와 생명주기 메서드를 정의하여 사용한다.
- 함수가 아닌 클래스기 때문에 render() 함수를 통해 JSX 를 반환한다.
- 생명주기 메서드를 사용할 수 있어 각 단계별로 더 많은 제어를 할 수 있다.
- 클래스의 개념을 이해하고 사용해야하며, 코드가 더 길어지고 컴파일시 크기가 함수형에 비해 크다.

```tsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

**함수형 컴포넌트**

- 리액트 hook을 사용해 상태를 관리하고 부수효과를 처리
- return 문을 사용한다.
- 클래스형 컴포넌트에 비해 간결하고 가독성이 좋다.

```tsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

## 미림

## **1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점**

|  | 클래스 컴포넌트 | 함수 컴포넌트 |
| --- | --- | --- |
| 선언 방식 | React.Component를 상속한 Class로 선언 | 일반적인 함수 문법으로 선언 |
| State 사용 | this.state와 생명주기 메서드 | useState, useReducer, uesEffect 등 Hooks |
| Props 사용 | this.props로 접근 | 매개변수로 받은 props로 접근 |
| 렌더링 방식 | render() 메서드로 렌더링할 요소를 반환함 | 렌더링할 요소를 직접 반환함 |
| 코드 복잡도 | 복잡하고 코드가 긺 | 간결하고 코드가 짧음 |
| 코드 응집도 | 코드 구조가 생명주기에 맞춰짐 | 코드 구조가 관심사별로 분리됨 |
| 코드 가독성 | 렌더링 요소를 한눈에 파악하기 어려움 | 렌더링 요소를 한눈에 파악하기 쉬움 |
| 러닝커브 | 높음 (Class, this 이해 필요) | 낮음 |
| 재사용성 | stateful 로직 재사용이 어려움 (HOC로 해결 but 코드가 계속 중첩돼 복잡해짐) | 커스텀 훅을 통한 높은 재사용성 |
- [클래스 컴포넌트 사용 예시 참고](https://react.vlpt.us/basic/24-class-component.html)

## 정욱

## 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점

### 클래스 컴포넌트

React가 처음 등장했을 때부터 사용된 컴포넌트 형태. `Component` 클래스를 상속받아 구현할 수 있으며, `render` 메소드를 오버라이딩하여 원하는 JSX를 반환하도록 구현한다. props와 state를 가지고 있으며, `this` 키워드를 통해 `props`에 접근할 수 있고 `state` 변수를 통해 상태에 접근하거나 `setState` 메소드를 통해 상태를 변경할 수 있다.

### 함수 컴포넌트

React 16.8 버전부터 등장한 컴포넌트 형태. React 18.2 버전이 최신 버전인 현재 가장 기본적인 형태로 받아들여지고 있다. `props`를 입력으로 받아 JSX를 반환하는 일반적인 JavaScript 함수이며, hooks를 통해 React의 여러 기능들을 사용할 수 있다.

### 장단…점?

클래스 컴포넌트는 하위 호환성 유지와 에러 경계 컴포넌트를 작성하기 위해 남아있을 뿐, 공식 문서에서도 함수형 컴포넌트를 작성하기를 권장하고 있다. 장단점을 논할 이유가 없다고 생각한다.

## 영은

**클래스 컴포넌트를 사용하게 된 이유**

- 처음 출시된 시기에 ES6의 클래스 문법이 최신 기술이었다.
⇒ 자연스레 객체지향 프로그래밍의 개념을 따라가기 위해 클래스를 사용하여 컴포넌트를 정의하게 되었다.
- **라이프사이클 메서드**를 사용하여 컴포넌트의 생명주기를 관리하는 것이 편리했다.

**클래스 컴포넌트의 문제점**

- 불필요한 보일러플레이트 코드가 많았다
(라이프사이클 메서드를 정의, constructor 메서드에 초기 상태 설정 등)
⇒ 초반에는 편리하다 생각했지만 더욱 효율적인 방법을 찾기 시작
- 작성해야 할 코드의 양이 많아 가독성이 떨어지는 문제가 있었다.
- **`this`**는 동적으로 바인딩되기 때문에 코드를 이해하기 어렵다. (역시 가독성문제)

이를 개선하기 위해 React 16.8에서 Hooks가 도입
⇒ 함수 컴포넌트에서 상태와 라이프사이클 관리가 가능해졌다.
⇒ 함수 컴포넌트의 사용이 증가되었다.

**본격 클래스 컴포넌트와 함수 컴포넌트의 차이점**

| 특징 | 클래스 컴포넌트 | 함수 컴포넌트 |
| --- | --- | --- |
| 구현 방식 | React.Component를 확장하여 만든다. | 단순한 JavaScript 함수로 정의한다. |
| 내부 상태 관리 | state를 사용한다. | useState 훅을 사용한다. |
| 라이프사이클 메서드 | 사용 가능하다. | 사용 불가능하나, useEffect 등의 훅을 대체해 사용할 수 있다. |
| this 키워드 사용 | 사용 가능하다. | 사용 불가능하다. |
| 코드량 및 가독성 | 코드량이 많고 가독성이 낮을 수 있다. | 코드량이 적고 가독성이 높을 수 있다. |
| 성능 | 렌더링 최적화가 어려울 수 있다. | Hooks를 통해 더 나은 성능 최적화가 가능하다. |