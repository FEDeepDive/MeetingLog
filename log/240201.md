## 보경

## 5. 프로토타입

프로토타입은 JavaScript에서 객체의 상속 구조를 정의하는 방법. 모든 객체는 `Object.prototype`이라는 프로토타입을 상속받고, 이 프로토타입에 정의된 속성과 메서드를 사용가능하다.

**장단점**

- 상속을 구현하는 간단하고 효율적인 방법이며 동적 프로그래밍을 가능하게 한다.
- 상속 관계가 복잡해지면 코드이해에 어려움이 있을 수 있고, 메모리 누수가 발생할 수 있다.

**실제 사용 예**

- 클래스 기반 프로그래밍 구현
- 객체의 필드와 메서드를 정의
- 동적 프로그래밍을 구현

**프로토타입 체인**

- 프로토타입 체인의 최상위에 위치하는 객체는 언제나 **`Object.prototype`** 이며 프로토타입의 프로토타입 또한 **`Object.prototype`**

## 6. (Weak)Map vs. (Weak)Set

ES6 에서 새로 도입된 조금 특별한 객체로 데이터를 효율적으로 저장하고 관리하는데 사용된다. 

**Map과 Set의 특징**

- Map과 Set은 요소 순서에 의미가 없어 인덱스로 요소에 접근할 수 없다.
- 이터러블 하기 때문에 **`for .. of`** 문으로 순회 가능하다.

**`Map`**

- **`Map`**은 키와 값의 쌍으로 이루어진 컬렉션 객체
- 키 값으로 문자열만 허용하는 객체와 달리 모든 값을 키로 사용할 수 있다.
- 요소를 추가하거나 삭제할 때 **`get`**, **`set`**, **`delete`**, **`clear`** 의 메소드들을 사용한다.
- 객체의 프로퍼티를 자주 변경해야 할 때 유용하다.

**`Set`**

- **`Set`**은 중복되지 않은 값들의 집합으로 이루어진 자료 구조
- 유일한 갑슬 가지는 목록을 만들거나 중복을 제거할 때 유용하다.

**`WeakMap`과 `WeakSet`**

- 키나 값이 반드시 객체여야하는 Map과 Set

## 7. `Date` 객체

표준 빌트인 객체인 **`Date`** 는 날짜와 시간을 표현하는데 사용되는 빌트인 객체이자 생성자 함수. **`new`** 연산자 없이 **`Date`** 생성자 함수 호출시 날짜와 시간 정보를 나타내는 문자열을 반환한다.

**(굳이 필요한지모르겠음)**

- **Date 객체의 속성**
    - year: 연도
    - month: 월
    - day: 일
    - hour: 시
    - minute: 분
    - second: 초
    - milliseconds: 밀리초
- **Date 객체의 정적메서드**
    - now()
    - parse()
- **Date 객체의 인스턴스메서드**

## 미림

## 5. 프로토타입

### 1. 프로토타입 개념

- 프로토타입이란, **자신의 원형(prototype)이 되는 객체**를 의미
- “프로토타입 객체”라고도 함
- **자바스크립트에서 모든 객체는 프로토타입을 가짐**

### 2. 프로토타입 동작 원리

```js
function Person() {}
var joon = new Person();
var jisoo = new Person();

```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/13495178-d1e2-408b-93d1-d9c2cce2d467/Untitled.png)

- Person 함수는 Person 프로토타입 객체를 `prototype` 프로퍼티로 참조한다.
- Person 프로토타입 객체는 Person 함수를 `constructor` 프로퍼티로 참조한다.
- **Person 프로토타입 객체는 Person 함수로 생성된 모든 객체(=인스턴스)의 원형이 되는 객체**이다.
- Person 함수로 생성된 모든 객체(=인스턴스)는 프로토타입(원형)인 Person 프로토타입 객체를 `__proto__` 프로퍼티로 참조한다.

### 3. 프로토타입 관련 프로퍼티

|  | [[Prototype]] | __proto__ | prototype | constructor |
| --- | --- | --- | --- | --- |
| 소유 객체 | 모든 객체 | 모든 객체 | 함수 객체 (생성자가 될 수 있는) | 모든 프로토타입 객체 (함수객체.prototype) |
| 값 | 자신의 프로토타입 객체 | 자신의 프로토타입 객체 | 인스턴스의 프로토타입 객체 | 자신을 생성한 함수 객체 (=생성자) |
| 비교 예시 |  | 나.__proto__ === 생성자함수.prototype | 나.prototype === 인스턴스.__proto__ | 나.constructor === 생성자함수 |
|  |  |  |  |  |
| 부연 설명 | JS 엔진의 구현 알고리즘을 설명하기 위해 있는 내부 슬롯 | [[Prototype]]에 접근하기 위한 접근자 프로퍼티 ([[Prototype]] getter, setter) |  |  |
| 주의사항 | 은닉 속성임. 접근 시 오류. ⇒ __proto__로 간접적 접근 O | ES6에서 표준화됨 but 사용이 권장되지 않음 | 생성자가 될 수 없는 non-constructor(화살표 함수, ES6 메서드 축약 표현으로 정의한 메서드)는 prototype 프로퍼티를 갖지 않음 |  |

```js
function Person(name) {
  this.name = name;
}
const me = new Person('Lee');

// ✅ __proto__와 prototype 프로퍼티
console.dir(me.__proto__); // Person 프로토타입 객체
console.dir(Person.prototype); // Person 프로토타입 객체
console.log(me.__proto__ === Person.prototype); // true

// ✅ constructor 프로퍼티
console.dir(Person.constructor); // Function

// Person 프로토타입 객체를 생성한 생성자 함수는 Person
console.dir(me.__proto__.constructor); // Person
console.dir(Person.prototype.constructor); // Person

// me는 constructor 프로퍼티를 갖지 않음 => 자신의 프로토타입에서 constructor를 찾음 (체인)
console.dir(me.constructor); // Person

// 🚨 콘솔에 찍었을 때 Object 나온다고해서 다 같은 Object가 아님 주의 !
console.dir(me.__proto__); // "Object" 라고 찍히지만, Person 프로토타입 객체를 의미함
console.dir(me.__proto__ === Object); // 그러므로 당연히 false
console.dir(Object); // Object 생성자 함수가 찍힘

```

### 4. 프로토타입 체인

```
💡 특정 객체의 프로퍼티/메서드를 **읽으려고 할 때**, 객체가 해당 프로퍼티/메서드를 직접 가지고 있지 않으면, 프로토타입 객체의 프로퍼티/메서드를 **차례대로** 검색하는 성질

```

```
🚨 없는 프로퍼티/메서드를 쓰려고 할 때에는 동적으로 할당되기 때문에 프로토타입 체인이 동작하지 않는다.

```

- 객체가 특정 프로퍼티/메서드를 **직접** 가지고 있는가?
- 없으면, **프로토타입 객체가** 해당 프로퍼티/메서드를 가지고 있는가?
- 없으면, **프로토타입 객체의 프로토타입 객체가** 해당 프로퍼티/메서드를 가지고 있는가? (반복)

```
💡 프로토타입 체인의 끝은 `Object.prototype` 객체이다.

```

### 5. 프로토타입 상속

```
💡 객체의 프로토타입 객체를 직접 할당하여 생성자 없이 상속을 구현하는 방법

```

```js
const parent = { name: 'Kim', age: 50 };
const child = {};

child.__proto__ = parent; // 프로토타입 객체로 부모를 할당
console.log(child); // {}
console.log(child.name); // Kim (프로토타입 체인 작동 => parent.name)

child.age = 20;
console.log(child); // { age: 20 }
console.log(child.age); // 20

```

### 6. 프로토타입 객체의 확장 및 활용

객체, 배열, 문자열 등 내장 함수를 추가해주지 않았는데도 사용할 수 있는 이유는 객체의 프로토타입 객체에 이미 메서드가 추가되어 있기 때문이다. (ex. `Array.prototype.sort()`)

아래 예제처럼 프로토타입 객체에 직접 메서드를 추가하여 확장할 수 있다.

```js
function Person(name, age) {
  this.name = name;
}

const personA = new Person('Kim');
const personB = new Person('Lee');

Person.prototype.sayHi = function () {
  console.log(`Hi. I am ${this.name}.`);
};

personA.sayHi(); // Hi. I am Kim.
personB.sayHi(); // Hi. I am Lee.

```

### 번외) 프로토타입 기반 언어 vs. 클래스 기반 언어

- **프로토타입 기반 언어**
    - 구성원을 유사성에 따라 나눔 ⇒ 구성원들 중 가장 전형적인, 즉 같은 특성을 가장 많이 공유하는 구성원을 원형(Prototype)으로 둠
    - 같은 구성원이어도 상황문맥(context)에 따라 구성원이 갖는 의미, 쓰임새가 달라질 수 O
    - Javascript, Lua 등
- **클래스 기반 언어**
    - 구성원을 분류(Classification)함 ⇒ 같은 클래스에 속하면 같은 특성을 가짐
    - Java, C++, C#, Python, PHP, Ruby 등

### 참고

- [JavaScript:프로토타입(prototype) 이해](https://www.nextree.co.kr/p7323/)
- [poiemaweb JS Prototype](https://poiemaweb.com/js-prototype)
- [Must Know About Frontend - Prototype](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/prototype.md)

## 6. (Weak)Map vs. (Weak)Set

```
💡 Map은 객체와 비슷한 키-값 컬렉션입니다. 객체와 달리 키의 타입을 구분하며 모든 타입을 키로 사용할 수 있습니다. Set은 중복이 없는 값 컬렉션입니다.
```

```
💡 WeakMap은 객체 또는 등록되지 않은 심볼만 키로 사용할 수 있고, WeakSet은 객체만 값으로 사용할 수 있습니다.
**WeakMap, WeakSet이 Map, Set과 다른 점은 객체를 약하게 참조한다는 것**입니다. 어떤 객체가 Map, Set에 포함되어 있으면 객체는 삭제되지 못합니다. 반면 객체가 WeakMap 또는 WeakSet에만 포함되어 있다면 객체는 가비지 컬렉션의 대상이 됩니다. 이러한 특징 때문에 WeakMap, WeakSet에서는 전체 요소를 대상으로 한 메서드나 프로퍼티를 사용할 수 없습니다.

```

### Map

- **개념**
    - 타입을 구분하는 키-값 컬렉션
- **특징**
    - 키의 타입이 구분됨 (🆚객체는 모든 키를 String으로 변환함)
    - 모든 타입이 키가 될 수 있음 (🆚객체는 객체 키를 쓰면 `"[object Object]"`가 됨)
        - 원시 값, 객체, `null`, `undefined`, `NaN`까지도 키로 사용할 수 있음
    - 삽입 순서가 보장됨 (🆚객체도 삽입 순서를 기억하지만(ES6), 항상 순서가 보장되는 건 아님)
    - 이터러블 (🆚객체는 아님) ⇒ `for..of` 사용 가능, `forEach` 내장 메서드 지원
    - 키 중복 불가
- **사용 방법**
    
    ```js
    const map = new Map();
    const person = { name: 'Kim' };
    
    map.set(person, 20); // object 타입 키
    map.set('1', 'string 1'); // string 타입 키
    map.set(1, 'number 1'); // number 타입 키
    map.set(null, 'null'); // null 타입 키
    
    console.log(map.get('1')); // 'string 1'
    console.log(map.get(1)); // 'number 1'
    
    map.forEach((value, key, map) => {
      console.log(key, value); // 삽입 순서대로 출력
    });
    
    ```
    

### Set

- **개념**
    - 중복이 없는 값 컬렉션
- **특징**
    - 값 중복 불가
    - 이터러블 ⇒ `for..of` 사용 가능, `forEach` 내장 메서드 지원

### WeakMap

- **개념**
    - **객체-값** 또는 **심볼-값 컬렉션**
    - 객체를 "약하게" 잡아두는 Map
    - 주로 부수적인 데이터 저장 시 활용
- **특징 (Map과 차이점)**
    - **객체를 약하게 참조** ⇒ 객체가 위크맵의 키 외에 누구에게도 참조되지 않으면 삭제됨 (🆚맵의 키로 사용한 객체는 아무도 참조하지 않아도 맵의 키로 포함된 동안 삭제되지 않음)
    - **객체 또는 등록되지 않은 심볼만 키가 될 수 있음** (🆚맵은 무슨 타입이든 가능)
    - 열거 불가능 (🆚맵은 가능)
    - 일부 메서드가 제한됨
        - 사용 가능한 메서드: `set()`, `get()`, `delete()`, `has()`
        - 약한 참조 유지를 위해 전체 요소에 대한 기능(ex. `size`, 순회)이 제한됨
- **약한 참조 예시**
    
    ```js
    /** 📢사전 지식
     * 객체는 힙 영역에 저장됨
     * 식별자에 객체를 할당한다는 건, 사실 객체의 힙 주소를 저장하는 것임
     *
     * 객체는 아무도 자신을 참조하지 않으면 자동으로 삭제됨
     * 객체 식별자 값이 null이 되어 객체에 도달할 방법이 없어도,
     * 배열의 요소, 맵의 키 등에서 객체를 참조하고 있으면 객체는 삭제되지 않음
     */
    
    const map = new Map();
    const weakMap = new WeakMap();
    
    let a = { name: 'a' };
    let b = { name: 'b' };
    map.set(a, 'this is a');
    weakMap.set(b, 'this is b');
    
    /***********************************************************************/
    a = null;
    // a가 가리키던 객체에 도달할 방법이 없지만
    // 해당 객체가 Map의 키로 사용되고 있기에, 가비지 컬렉션의 대상이 되지 못함❌
    console.log(map); // 키로 객체 {name:'a'}를 가지고 있음
    
    /***********************************************************************/
    b = null;
    // b가 가리키던 객체에 도달할 방법이 없음
    // 해당 객체가 WeakMap의 키로 사용되고 있지만, 가비지 컬렉션의 대상이 됨⭕
    console.log(weakMap); // 비어 있음 (객체가 당장 삭제되지 않았어도 삭제가 예정됨)
    
    ```
    

### WeakSet

- **개념**
    - 중복이 없는 **객체 컬렉션**
    - 객체를 "약하게" 잡아두는 Set
    - 주로 부수적인 데이터 저장 시 활용
- **특징 (Set과 차이점)**
    - **객체를 약하게 참조** ⇒ 객체가 위크셋 외에 누구에게도 참조되지 않으면 삭제됨 (🆚셋에 포함된 객체는 아무도 참조하지 않아도 셋에 포함된 동안 삭제되지 않음)
    - **객체만 키가 될 수 있음** (🆚셋은 무슨 타입이든 가능)
    - 열거 불가능 (🆚셋은 가능)
    - 일부 메서드가 제한됨
        - 사용 가능한 메서드: `add()`, `delete()`, `has()`
        - 약한 참조 유지를 위해 전체 요소에 대한 기능(ex. `size`, 순회)이 제한됨

### 참고

- [맵과 셋](https://ko.javascript.info/map-set)
- [위크맵과 위크셋](https://ko.javascript.info/weakmap-weakset)

## 7. `Date` 객체

- **개념**
    - 날짜/시간 관련 객체
- **주요 사용 방법**
    
    ```js
    // 날짜 저장
    var date1 = new Date('2024-01-31'); // Mon Jan 31 2024 09:00:00 GMT+0900
    var date2 = new Date(2024, 0, 31); // Mon Jan 31 2024 00:00:00 GMT+0900
    var date3 = new Date(1988, 4, 5); // Thu May 05 1988 00:00:00 GMT+0900
    
    // 주요 메서드
    date1.getDay(); // Mon
    date1.getDate(); // 31
    date1.getYear(); // 124 (getYear 메서드는 '2000년 문제'로 문제가 있으니 사용 X)
    date3.getYear(); // 88 (1900~1999년 사이 연도는 두 자릿수로 출력해줌)
    date1.getFullYear(); // 2024 (getFullYear 메서드가 권장됨)
    
    // 경과한 시간(ms) 계산
    var start = Date.now(); // 1970년 1월 1일 0시 0분 0초부터 지금까지 경과된 밀리초
    var end = Date.now();
    var time = end - start; // 경과한 시간(ms) 계산 가능
    
    ```
    
    - `year`: 네 자리 숫자
    - `month`: `0`(1월)~`11`(12월) 사이 숫자
    - `date`: 일
    - `day`: 요일

## 정욱

## 5. 프로토타입

프로토타입은 자바스크립트가 객체지향을 지원하기 위해 채택한 방식이다. 자바스크립트의 모든 객체는 프로토타입 객체를 가지며, 프로토타입 객체로부터 메서드와 속성들을 상속받는다. 상위 프로토타입 객체 또한 그 자신의 상위 프로토타입 객체로부터 상속받으며, 이렇게 이어지는 형태를 프로토타입 체인이라고 한다. 객체에서 프로퍼티에 접근할 때, 해당하는 프로퍼티가 없다면 프로토타입 체인을 따라 상위 프로토타입을 거쳐가며 프로퍼티를 찾는다.

### 프로토타입의 장단점

프로토타입 기반 객체지향은 클래스 기반 객체지향에 비해 메모리 측면에서 효율적일 수 있다. 클래스 기반 객체지향의 경우, 부모 클래스의 모든 속성과 메서드가 자식 클래스에 복사되어 각각 메모리에 올라가는 반면 프로토타입 기반 객체지향의 경우 상위 프로토타입에 대한 참조만 가지고 있어도 되기 때문이다.

그러나 프로토타입 기반 객체지향은 동적으로 프로퍼티를 변경할 수 있기 때문에, 정적으로 속성과 메서드를 결정해야 하는 클래스 기반 객체지향에 비해 예측성과 신뢰성 측면에서 부족한 부분이 있을 수 있다. 또한 프로토타입에 비해 클래스에 익숙한 작업자가 프로토타입을 이해하기 힘들 수 있다는 단점도 존재한다.

### 프로토타입의 사용처

프로토타입의 장점인 메모리 효율을 고려하자면, 수많은 개수의 자식 객체를 만들어야 할 때 메모리를 아끼기 위해 프로토타입 사용을 고려할 수 있다. 또한, 프로토타입은 이미 존재하는 객체에 큰 변경을 가하지 않고도 새로운 기능을 추가할 때 유용하게 사용할 수 있다. 

## 6. (Weak)Map vs. (Weak)Set

### Map

ES6에서 도입된 키-값 쌍을 저장할 수 있는 자료구조다. `@@iterator` 메서드를 구현하고 있기 때문에 `for … of` 문을 통해 순회 가능하고, 삽입된 순서를 기억하며. 각 `Map`의 모든 키는 고유하다는 특징이 있다.

ES6 이전에는 일반적인 객체를 `Map`과 비슷하게 사용하곤 하였다. 객체는 프로퍼티라는 이름의 키-값 쌍을 가질 수 있기 때문에 그러한 접근이 가능하지만, 키의 타입을 문자열 또는 `symbol` 타입밖에 사용할 수 없고, 프로토타입이 있기 때문에 기본 키(기본값 속성)가 존재하여 의도치 않은 동작의 원인이 될 수 있는 등의 문제점이 존재한다. `Map`은 어떠한 타입의 키든 사용할 수 있으며, 메서드를 통해 현재 저장된 아이템의 수를 쉽게 얻을 수 있는 등의 장점이 있다.

### Set

ES6에서 도입된 집합 자료구조로, 중복된 데이터를 허용하지 않는다는 특징이 있다. `Map`과 마찬가지로 `@@iterator` 메서드를 구현하고 있기 때문에 `for ... of` 문을 통해 순회 가능하며, 삽입된 순서를 기억한다. 흔히 배열의 중복된 값을 제거할 때 주로 사용되는 경우가 많다.

### Weak{Map | Set}

Weak 접두어가 붙은 각 자료구조들은 가비지 컬렉션될 수 있는 것들, 즉 객체 타입 또는 전역 심볼 레지스트리에 등록되지 않은 `symbol` 타입만을 키로 사용할 수 있다. 키가 가비지 컬렉션될 수 있기 때문에, 해당 키에 연결된 값 또한 가비지 컬렉션될 수 있다. Weak한 자료구조들은 순회가 불가능하며, `keys()`, `values()`, `entries()` 등 반복자를 반환하는 메서드를 가지고 있지 않다. Weak한 자료구조들은 부수적인 데이터, 예를 들어 서드파티 라이브러리 객체나 캐시를 저장하는 데 유용하게 사용될 수 있다.

## 7. `Date` 객체

`Date`는 자바스크립트에서 특정한 날짜 및 시각을 표현할 때 사용하는 빌트인 객체이다. 생성된 `Date` 객체는 1970년 1월 1일 00시 00분부터 현재까지의 시간 차이를 밀리초로 나타내는 정수값을 내부적으로 가진다. `Date` 객체는 날짜 또는 시각을 얻거나 시간대끼리 변환하는 메서드를 많이 가지고 있다.

## 영은

## 5. 프로토타입

- 프로토타입이란 무엇인가요?

> 프로토타입은 JavaScript에서 객체 간 **상속을 구현하는 메커니즘 중 하나.** 모든 객체는 자신의 프로토타입에 대한 링크를 가지고 있다. 객체의 속성을 찾을 때 해당 객체에 속성이 없으면 **프로토타입 체인**을 따라 **부모 객체의 프로토타입에서 속성**을 찾는다. 이런 식으로 계속 올라가면 최종적으로 null을 가리키는 프로토타입에 도달하게 된다.
> 
- 프로토타입의 장단점은 무엇인가요?

**장점:**

1. **유연성과 동적성:** 프로토타입 상속 모델은 동적이고 유연하다. 런타임에 객체의 프로토타입을 변경하거나 새로운 속성을 추가할 수 있어서 코드의 변경이 쉽다.
2. **메모리 효율성:** 프로토타입을 사용하면 여러 객체 간에 속성이나 메서드를 공유할 수 있어 메모리를 효율적으로 사용할 수 있다. 모든 인스턴스가 동일한 프로토타입을 참조하기 때문에 중복된 데이터가 생성되지 않는다.
3. **상속의 간편함:** 객체 간의 상속을 간단하게 처리할 수 있다. 부모 객체의 프로토타입에 정의된 메서드와 속성은 하위 객체에서 쉽게 상속받을 수 있다.

**단점:**

1. **복잡성 및 이해 어려움:** 프로토타입 체인이 복잡해질수록 코드를 이해하고 디버깅하기 어려울 수 있습니다. 특히 큰 프로젝트에서는 체인을 파악하기 어려울 수 있다.
2. **속도에 대한 우려:** 프로토타입 체인을 따라 속성을 찾는 데에는 시간이 걸릴 수 있습니다. 체인이 길어질수록 속도에 영향을 미칠 수 있으므로 성능에 대한 고려가 필요하다.
3. **내장 프로토타입 확장의 위험성:** 내장 객체의 프로토타입을 확장하면 라이브러리 간의 충돌이나 예상치 못한 부작용이 발생할 수 있습니다. 이는 코드의 예측성을 낮출 수 있다.
4. **클래스 기반 언어와의 차이:** 클래스 기반 언어에서 익숙한 개발자들에게는 프로토타입 기반의 상속 모델이 혼란스러울 수 있다.
- 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?
    
    > 프로토타입은 JavaScript에서 객체 간의 상속을 구현하는 데 사용되며, 주로 상속, 동적 변경 및 확장, 프로토타입 기반의 디자인 패턴 구현, 그리고 라이브러리 및 프레임워크에서 모듈화와 재사용성을 향상시키기 위해 활용됩니다. 객체의 프로토타입을 통해 속성과 메서드를 공유하고, 런타임에 동적으로 변경하여 유연성을 제공하며, JavaScript 생태계에서 널리 사용되는 디자인 패턴과 라이브러리에서 중요한 역할을 합니다.
    > 

## 6. (Weak)Map vs. (Weak)Set

### **Map**

> **`Map`**은 키-값 쌍을 저장하는 자료구조이다. 일반객체와 다르게 **메소드를 통해서 값을 추가하거나 접근**할 수 있다. **중복된 키를 허용하지 않아 데이터를 빠르게 검색**할 수 있다. 보통 키-값 관리에 활용된다.
> 

**특징**

- **키는 중복될 수 없으며**, 각 키에 대응하는 값이 있다.
- 순서가 있는 컬렉션으로, 순회할 때 삽입된 순서대로 요소에 접근할 수 있다.
- **모든 자료형을 키**로 사용할 수 있다.

```js
// 다양한 자료형을 키와 값으로 사용한 Map
let myMap = new Map();

// 객체를 키로 사용
let objKey = {};
myMap.set(objKey, 'Value for Object Key');

// 함수를 키로 사용
let funcKey = function() {};
myMap.set(funcKey, 'Value for Function Key');

// 문자열을 키로 사용
myMap.set('stringKey', 'Value for String Key');

// 숫자를 키로 사용
myMap.set(42, 'Value for Numeric Key');

// **심지어 배열도 키로 사용 가능**
let arrayKey = [1, 2, 3];
myMap.set(arrayKey, 'Value for Array Key');

// 키에 대한 값들 출력
myMap.forEach((value, key) => {
  console.log(`${key} => ${value}`);
});

/* 출력 결과
[object Object] => Value for Object Key
function() {} => Value for Function Key
stringKey => Value for String Key
42 => Value for Numeric Key
1,2,3 => Value for Array Key
*/
```

**Map 메소드**

- **set(key, value):** 새로운 키-값 쌍 추가 또는 기존 키의 값 업데이트
- **get(key):** 주어진 키에 해당하는 값 반환
- **has(key):** 주어진 키의 존재 여부 확인
- **delete(key):** 주어진 키와 해당 값 삭제
- **clear():** 모든 키-값 쌍 삭제
- **forEach(callbackFn):** 각 키-값 쌍에 대해 콜백 함수 실행

**WeakMap**

- 키에 대한 **약한 참조**를 유지
- 키가 다른 곳에서 더 이상 사용되지 않을 때, 해당 **키-값 쌍이 자동으로 제거**될 수 있음
- 이터러블 하지 않음
- 키-값 쌍을 확인하는 메소드가 제공되지 않음

<aside>
💡 **`Map`**은 **메모리 관리에 주의**해야 한다. 때문에 특정상황에서 **`WeakMap`** 을 유용하게 사용될 수 있다. **`WeakMap`**은 주로 객체 간의 사적인(private) 상태를 저장하거나 메모리 누수를 방지하기 위해 사용된다고 한다.

</aside>

### Set

> Set은 **중복을 허용하지 않는 값의 집합을 저장**하는데 사용된다. 데이터 중복을 방지하고, 값의 존재 여부를 빠르게 확인하는 데에 유용하다.
> 

**Set메서드**

- **add(value):** 값 추가
- **has(value):** 값의 존재 여부 확인
- **delete(value):** 값 삭제
- **clear():** 모든 값 삭제
- **forEach(callbackFn):** 각 값에 대해 콜백 함수 실행

**WeakSet**

- 객체의 집합을 저장, 약한 참조를 사용하여 객체에 대한 참조가 사라지면 자동으로 삭제됨.
- 가비지 컬렉션에 영향을 주지 않고 메모리를 효율적으로 관리할 수 있음.
→객체의 일부분이라도 참조하면서 메모리 누수를 방지하면서 관리할 때 사용됨.
- 특정 객체가 어떤 작업을 완료했는지 추적하고 싶을 때 사용될 수 있음.

| - | Map | WeakMap | Set | WeakSet |
| --- | --- | --- | --- | --- |
| 자동 메모리 관리 | X | O (참조가 없으면 자동 삭제) | X | O (참조가 없으면 자동 삭제) |
| 이터러블 | O | X | O | X |
| 키/값 유무 | 키와 값 모두 저장 | 키와 값 모두 저장 | 값만 저장 | 값만 저장 |
| 사용 예시 | 키-값 관리, 중복 제거 | 객체에 대한 사적인(private) 상태 저장 | 중복 제거, 값 존재 여부 확인 | 객체에 대한 약한 참조 저장 |
| 주의사항 | 메모리 관리에 주의 필요 | 키가 객체에 대한 약한 참조를 유지하므로, 해당 객체에 대한 참조가 사라지면 값도 자동 삭제됨 | 메모리 관리에 주의 필요 | 키가 객체에 대한 약한 참조를 유지하므로, 해당 객체에 대한 참조가 사라지면 값도 자동 삭제됨 |

+일반객체와의 차이도 넣고 싶어서 표 추가 

| - | 일반 객체 | Map | Set | WeakMap | WeakSet |
| --- | --- | --- | --- | --- | --- |
| 자료형 | 모든 자료형 가능 (키-값 쌍) | 키와 값 모두 모든 자료형 가능 | 값만 모든 자료형 가능 | 키와 값 모두 모든 자료형 가능 | 값만 객체 가능 |
| 중복 허용 | 중복 허용 | 중복된 키 불가능 | 중복된 값 불가능 | 중복된 키 불가능 | 중복된 값 불가능 |
| 키와 값의 유지 여부 | 강한 참조를 유지 | 강한 참조를 유지 | 강한 참조를 유지 | 약한 참조로 인해 객체에 대한 참조가 사라지면 자동 삭제 | 약한 참조로 인해 객체에 대한 참조가 사라지면 자동 삭제 |
| 순서 | 순서가 보장되지 않음 | 키의 순서가 보장됨 | 값의 삽입 순서가 보장됨 | 키의 순서가 보장되지 않음 | 값의 삽입 순서가 보장됨 |
| 크기 속성 | 직접 확인 불가 (Object.keys 등 사용) | size 속성으로 직접 확인 가능 | size 속성으로 직접 확인 가능 | 없음 | 없음 |
| 값의 검색 | 객체[key] 형식 사용 | get 메서드로 키에 대한 값을 얻음 | has 메서드로 값의 존재 여부 확인 | get 메서드로 키에 대한 값을 얻음 | has 메서드로 값의 존재 여부 확인 |
| 메서드 사용 | 없음 | get, set, has, delete, clear, forEach | add, has, delete, clear, forEach | get, set, has, delete | add, has, delete |

## 7. `Date` 객체

> 날짜와 시간을 다루기 위한 내장 객체 중 하나다. 1970년 1월 1일 00:00:00 UTC(세계 협정 시간)를 기준으로 한 밀리초로 시간을 표현, 현재 시간이나 특정 날짜 및 시간을 나타내는 데 사용된다.  `new Date()` 로 객체를 생성해 사용한다.
> 

⇒ 요즘 웹 개발에서는 보통 반복적이고 복잡한 작업을 단순화하며, 개발자가 더 쉽게 기능을 구현하기 위해 라이브러리를 사용한다.