## 보경

## 1. 쿠키 세션 토큰

### **쿠키의 등장 배경과 HTTP의 특징**

- **`HTTP`** 란 웹에서 데이터를 주고받기 위한 프로토콜인데 이 **`HTTP`** 는 비연결성, 무상태성이라는 특징을 가지고 있다.
- 비연결성(**`Connectionless`**) : 클라이언트가 서버에게 요청을 보내고 서버가 응답하면 접속을 종료한다.
- 무상태성(**`Stateless`**) : 통신이 끝나면 상태 정보를 유지하지 않는다.
- 즉 서버가 클라이언트의 정보를 계속 가지고 있지 않기 때문에 페이지 이동을 할 때마다 사용자의 로그인 정보나 사용자가 입력한 값이 초기화 되는 문제가 있다.
- 따라서 이를 해결하기 위해 데이터를 브라우저에 저장할 수 있는 쿠키가 만들어졌다.
- 서버는 쿠키, 세션, 토큰 세가지 방식으로 클라이언트의 상태를 기억하고 식별/인증한다.

### **쿠키(Cookie)**

서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각으로 Key - Value 형식의 문자열 형태이며 브라우저에 저장된다.

**쿠키 인증 방식**

1. 최초 통신(처음접속)에는 쿠키 값이 없으므로 클라이언트(브라우저)가 서버에 접속할 떄 요청을 보낸다.
2. 서버는 클라이언트(브라우저)의 요청 헤더에 쿠키가 없음을 판별하고, 통신 상태(UserID, PW, 조작상태, 방문횟수 등)를 저장한 쿠키를 응답헤더의 Set-Cookie에 담아 응답한다.
3. 클라이언트인 브라우저는 받은 쿠키를 생성/보존한다.
4. 두번째 연결부터 클라이언트는 요청을 보낼 때마다 HTTP Header에 쿠키를 실어보낸다.
5. 서버는 쿠키에 담긴 정보를 바탕으로 클라이언트를 식별한다.

**쿠키의 종류(파기시점에 따라 두개로 나뉘어짐)**

- 영구 쿠키(Permanent Cookie) : 만료기간을 명시해 지정된 기간동안 쿠키 유지
- 세션 쿠키(Seesion Cookie) : 만료기간에 대한 정보를 명시하지 않을 경우 세션 쿠키가 되는데 세션이 있는 동안만 저장. 브라우저 종료시 데이터가 삭제됨

**쿠키의 특징**

- 쿠키의 값을 그대로 보내기에 보안에 취약하며 유출 및 조작 당할 위험이 존재한다.
- 웹 브라우저마다 쿠키게 대한 지원 형태가 달라 브라우저간 공유가 불가능하다.

**쿠키 사용 예시**

- 팝업 보지 않기
- 사용자의 이용 스크롤링이나 뷰 설정 값

### **세션(Session)**

쿠키의 보안적 이슈를 해결하기 위해서 만들어진 방법으로 클라이언트의 민감한 인증 정보를 서버측에 저장하고 관리하는 방법

**세션 인증 방법**

1. 클라이언트가 서버에 접속할 때 서버로부터 세션ID를 발급받는다.
2. 클라이언트는 서버가 발급해준 세션 ID를 쿠키를 이용해 저장한다.
3. 따라서 클라이언트는 서버에 요청을 할 때마다 세션 ID를 함께 전달하게 되고 서버는 쿠키에 담긴 세션 ID를 토대로 클라이언트를 식별한다.

**세션의 특징**

- 클라이언트는 세션 ID만 알고 있고, 서버가 정보를 저장하기 때문에 보안에 좋다.
- 하지만 해커가 악의적으로 세션 ID 자체를 탈취하여 클라이언트인척 할 수 있다.
- 서버에 거쳐서 정보를 받아야 하기 때문에 속도가 느리며 사용자가 많아질수록 부하가 심해진다.

**세션 사용 예시**

- 로그인 정보 유지

### **토큰(Token)**

서버에 접속암호화 된 접근 권한

**토큰 인증 방법**

1. 사용자(클라이언트)가 로그인을 한다.
2. 서버 측에서 사용자(클라이언트)에게 유일한 Access Token을 발급한다.
3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달한다.
4. 서버는 전달받은 토큰을 검증하고 사용자에 맞는 데이터를 응답한다.

**토큰의 특징**

- 세션/쿠키는 별도의 저장소 관리가 필요하지만, JWT는 발급한 후 검증만 하면되기 때문에 추가 저장소가 필요하지 않다.
- 이미 발급된 JWT에 대해서는 유효기간이 만료전까지 계속 사용이 가능하므로 토큰을 탈취당하면 대처가 어려워짐(access token 의 유효기간을 짧게 하고 refresh token을 새로 발급받아 해결)
- 토큰 자체의 길이가 길이가 길기 때문에 인증이 필요한 요청이 많을수록 서버의 자원낭비가 발생한다.

**JWT 토큰(Json Web Token)**

인증에 필요한 정보들을 암호화 시킨 JSON 형태의 토큰

**JWT 구조**

.을 구분자로 나누어지는 세가지 문자열의 조합으로 **.** 을 기준으로 Header, Payload, Signature을 의미한다.

- Header : 토큰의 타입이나 서명생성에 사용된 알고리즘(해시알고리즘)
- Payload : 토큰에서 사용할 정보의 조각들로 해독이 가능하기 때문에 중요한 정보는 포함하면 안됨
- Signature : Header, Payload를 디코딩하고 합쳐서 개인키로 암호화된 전자서명

### **브라우저 저장소란?**

서버가 아닌 클라이언트 내에서 데이터를 저장할 수 있도록 하는 저장소로 쿠키와 웹 스트리지로 이루어져 있다.

**웹 스토리지(Web Storage)**

- 쿠키의 성능, 보안, 용량의 단점을 보완하기 위해 HTML 5부터 제공되는 스펙
- 로컬스토리지와 세션 스토리지로 이루어져 있다.
- 문자열로 정보를 저장하는 쿠키와 달리 객체 형태로 정보를 저장
- 저장공간(5MB)이 쿠키보다 크다.

**로컬 스토리지(Local Storage)**

- 브라우저를 종료해도 데이터를 영구적으로 보관
- 명시적으로 삭제해주지 않으면 로컬 스토리지의 데이터는 영구적
- **`windows`** 전역 객체의 **`LocalStorage`** 컬렉션을 통해 저장 및 조회를 할 수 있음
- 도메인마다 같으면 모든 브라우저 간에 전역적으로 데이터가 공유됨

**세션 스토리지(Session Storage)**

- 브라우저를 종료하면 데이터가 삭제됨
- 세션이 유지되는 동안만 존재함
- **`windows`** 전역 객체의 **`SessionStorage`** 컬렉션을 통해 저장 및 조회를 할 수 있음
- 도메인이 같더라도 브라우저가 다르면 각각의 세션 스토리지가 형성되어 있기 때문에 데이터 공유가 되지 않음

**쿠키와 웹 스토리지의 비교**

|             | 쿠키                                | 웹 스토리지              |
| ----------- | ----------------------------------- | ------------------------ |
| 서버로 전송 | 서버 요청 마다 요청헤더에 실어 전송 | 클라이언트에 데이터 저장 |
| 데이터 형태 | 문자열                              | 구조화 된 객체           |
| 용량        | 총 300개                            |

하나의 도메인당 20개
하나의 쿠키강 4kb | 제한 X |
| 제거 시점 | 만료 일자를 강제로 지정해야 하므로 언젠간 삭제됨 | 한 번 저장한 데이터는 영구적으로 존재 가능 |

## 2. 성능 최적화 방법

웹 성능 지표

- [https://velog.io/@ktthee/웹사이트-성능-지표](https://velog.io/@ktthee/%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EC%A7%80%ED%91%9C)

[**Core Web Vitals**](https://web.dev/articles/vitals?hl=ko)

구글이 웹사이트 성능 최적화를 위해 중요하다고 판단한 세 가지 지표

- **[Largest Contentful Paint (LCP)](https://web.dev/lcp/)** : 로딩의 성능. 사용자에게 좋은 경험을 제공하기 위해서는, 적어도 2.5초 이내로 첫페이지 로딩이 이루어져야 한다.
- **[First Input Delay (FID)](https://web.dev/fid/)** : 상호작용성. 좋은 사용자 환경을 제공하기 위해서는, 페이지의 FID가 100ms 미만이어야 한다.
- **[Cumulative Layout Shift(CLS)](https://web.dev/cls/)** : 시각적 안정성. 좋은 사용자 환경을 제공하기 위해서는, 페이지가 0.1초 이하의 CLS를 유지해야 한다.

**Throttling vs Debounce**

이벤트를 2가지 방식으로 제어해 성능을 높이는 방법

|                   | Throttling                           | Debounce                                        |
| ----------------- | ------------------------------------ | ----------------------------------------------- |
| 정의              | 이벤트를 일정 주기마다 처리하는 방식 | 연속적으로 발생한 이벤트를 하나로 처리하는 방식 |
| 이벤트 발생 시점  | 일정 간격을 설정                     | 입력이 끝날때까지 무                            |
| 사용 예시         | 스크롤                               | 키워드 검색/자동완성기능                        |
| 컴포넌트 리사이징 |

**[CSS 애니메이션 VS JS 애니메이션](https://velog.io/@younghwanjoe/requestAnimationFrame%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-%EC%83%81)**

|                                | CSS 애니메이션                                                      | JS 애니메이션                             |
| ------------------------------ | ------------------------------------------------------------------- | ----------------------------------------- |
| 사용 범위                      | 간단한 애니메이션                                                   | CSS로 처리하기 복잡하고 무거운 애니메이션 |
| 사용 방법                      | transform, translate, @keyframe사용                                 | 외부 라이브러리 사용                      |
| 특징                           |                                                                     | Animation Frame Queue 에서 처리됨         |
| 장점                           | 가볍고 성능이 좋으며 쉽다.                                          |
| 외부라이브러리가 필요하지 않음 | 프레임을 정확히 제어할 수 있고, 복잡한 애니메이션과 상호작용이 쉬움 |
| 단점                           | 제한적인 기능                                                       |
| 복잡한 애니메이션 구현 어려움  | CSS에 비해서 성능이나 효율성이 좋지 않다.                           |

**이미지 스프라이트**

여러개의 이미지로 하나의 이미지로 만들어 놓아 이미지 다운로드 시간을 단축시키는 기법

## 미림

## 정욱

## 8. 쿠키/세션/토큰

HTTP는 기본적으로 무상태(Stateless) 프로토콜이기 때문에, 연결이 종료되는 순간 모든 상태 정보가 사라진다. 때문에 작업의 문맥을 유지하기 위해서 서버는 클라이언트가 이전 통신이 이루어졌을 때 보낸 정보를 다음 통신이 이루어질 때 알 수 없다. 그럼에도 정보를 유지하고 싶은 경우, 클라이언트 측에서 서버에게 요청을 보낼 때마다 추가로 정보를 포함시켜 전달할 수 있는데, 전달하는 방법은 크게 아래의 세 가지로 나뉜다:

### 쿠키

서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 브라우저는 해당 데이터를 저장해뒀다가, 동일한 서버에 다시 요청을 보낼 때 함께 전달한다. 이름/값/만료일(또는 최대 유지 시간)/도메인/전송 경로 등의 정보가 기록된 문자열 형태이다.

쿠키는 만료일 또는 최대 유지 시간이 지정되어 설정된 기간 동안 브라우저 상에서 유지되는 ‘영속적인 쿠키’와, 브라우저 또는 탭이 종료되면 사라지는 ‘세션 쿠키’의 두 가지로 구분된다.

쿠키는 브라우저에서 자바스크립트를 통해 접근할 수 있기 때문에, XSS(Cross-Site Scripting, 사이트 간 스크립팅)에 취약하다. `HttpOnly` 접미사를 붙여 브라우저에서 쿠키에 접근할 수 없도록 할 수 있다. 또한 쿠키는 HTTP 요청 헤더에 포함되어 전송되며, HTTP는 데이터를 암호화하는 보안 메커니즘이 없기 때문에 `Secure` 접미사를 붙여 HTTPS 통신에서만 쿠키를 전송하도록 설정할 수 있다. CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)를 막기 위해 설정할 수 있는 `SameSite` 속성도 존재한다.

### 세션

쿠키만을 이용해 모든 상태를 저장할 수도 있지만, 쿠키는 보안적으로 취약하여 민감한 정보를 저장하는 데에는 부적합하다. 또한 쿠키는 최대 크기와 최대 개수가 정해져 있어 저장할 수 있는 정보량의 제한이 있고, 매 요청마다 헤더에 포함되어 전달되기 때문에, 정보량이 많을수록 요청의 크기가 커져 네트워크 성능 부하가 심해진다.

이러한 문제점을 해결하기 위해, 서버 측에서 사용자의 인증 정보를 저장하고 관리하는 방식을 세션 방식이라고 한다. 서버가 클라이언트의 인증 요청에 대해 응답할 때, 인증 상태에 대한 자료구조를 저장하고 해당 자료구조를 식별할 수 있는 ID를 쿠키에 담아 전달한다. 이후 클라이언트가 요청을 보낼 때마다 쿠키가 함께 전달되므로, 서버는 ID의 유효성을 판단하여 클라이언트를 식별할 수 있다. 서버와의 상호작용을 통해서만 세션을 식별할 수 있기 때문에, 이러한 세션 ID를 opaque token(또는 reference token)이라고 부르기도 한다.

쿠키가 외부에 노출되더라도 세션 ID 자체에는 민감한 정보가 없으므로 쿠키만 사용하는 방식보다는 훨씬 안전하지만, 누군가 세션 ID를 탈취하여 해당 클라이언트인 척 위장할 가능성도 있다.

### 토큰

세션 방식을 사용하면 서버는 요청마다 함께 전달되는 세션 ID의 유효성을 판단할 수 있도록, 유효한 세션 ID를 메모리에 로드해놓는다. 때문에 서버에 동시 접속하는 사용자가 많아질수록 부하가 심해진다는 단점이 있다. 이를 해결하기 위해, 세션 ID 대신 토큰을 발급해줄 수 있다.

**JWT(JSON Web Token)**

URL에 들어갈 수 있는 문자로만 구성되었으며, 디지털 서명되어 자체적으로 위변조 여부를 확인할 수 있는 토큰이다. `header.payload.signature`의 형태를 가지고 있으며, `.`으로 구분된 각각이 JSON 구조로 정보를 저장하고 있다. 일반적으로 서버에 직접 요청할 때 사용하는 토큰과 해당 토큰을 재발급할 목적으로 사용하는 토큰의 두 가지를 한 번에 사용하는 액세스 토큰/리프레시 토큰 방식을 자주 사용한다.

### 브라우저 저장소

여러 가지 단점이 있는 쿠키 대신 사용할 수 있는 클라이언트의 데이터 저장 기능이다. HTTP 요청에 포함되지 않기 때문에 네트워크 부하가 없고, 용량의 제한이 없으며 구조화된 객체를 저장할 수 있다.

**`window.sessionStorage`**

탭이 닫히면 데이터가 초기화되며, 도메인이 동일하더라도 각 탭/브라우저 간에 데이터가 공유되지 않는다.

**`window.localStorage`**

탭을 닫거나 브라우저를 종료해도 데이터를 영구적으로 보관하며, 도메인만 동일하다면 모든 브라우저 간에 전역적으로 데이터가 공유된다.

## 9. 성능 최적화 방법

### Core Web Vitals

눈으로는 확인할 수 없는 웹사이트의 성능 차이를 확인하기 위해, 정량적인 지표를 측정하여 평가할 필요가 있다. 여러 가지 지표가 있지만, 구글에서 중요하다고 판단한 세 가지 지표 ‘Core Web Vitals’이 주로 사용된다.

**Largest Contentful Paint(LCP)**

페이지 로딩 속도를 측정하는 지표로, 사용자가 웹페이지를 로딩할 때 페이지의 가장 큰 콘텐츠 요소가 화면에 얼마나 빨리 렌더링되는지를 측정한다. LCP가 빠르면 빠를수록, 사용자가 더 빠르게 페이지를 이해할 수 있다.

**First Input Delay(FID)**

상호작용 반응성을 측정하는 지표로, 사용자가 웹페이지의 상호작용 요소를 클릭한 후, 실제로 브라우저가 반응을 시작하기까지 걸리는 시간을 측정한다. FID가 빠르면 빠를수록, 사용자 경험에 긍정적인 영향을 준다.

**Cumulative Layout Shift(CLS)**

콘텐츠 안정성을 측정하는 지표로, 웹페이지에서 요소들의 이동이나 크기 조정 등 레이아웃이 예상치 못하게 변경되는 빈도와 양을 측정한다. CLS가 낮으면 낮을수록, 사용자의 혼란을 줄이고 의도치 않은 동작이 줄어든다.

**Interaction to Next Paint(INP)**

2024년 3월 12일부터 FID를 대신하여 Core Web Vitals에 추가되는 지표로, 클릭/키보드 입력 등의 사용자 입력이 발생할 때 화면이 얼마나 빨리 변화하는지에 대한 응답성을 측정한다. FID는 첫 상호작용만을 측정하지만, INP는 페이지의 모든 상호작용을 측정하기 때문에 좀 더 신뢰성있는 지표라고 볼 수 있다.

### 스로틀(throttle) / 디바운스(debounce)

scroll, resize, input, mousemove 등의 이벤트는 짧은 시간 내에 연속해서 발생한다는 특징이 있다. 이러한 이벤트에 바인딩된 이벤트 핸들러는 과도하게 많이 호출되어 성능에 문제를 일으킬 수 있기 때문에, 이를 조절하기 위해 스로틀/디바운스라는 처리 기법이 소개되었다.

스로틀은 짧은 간격으로 이벤트가 연속으로 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 하는 것이며, 디바운스는 짧은 간격으로 이벤트가 발생했을 때 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후 한 번만 호출하는 것이다.

### `requestAnimationFrame()`

애니메이션과 그 외의 반복 작업을 수행하기 위해 브라우저가 제공하는 메서드로, 브라우저의 리페인트 주기에 맞춰 콜백 함수를 실행하도록 예약한다. 리페인트 주기는 브라우저의 화면 갱신 주기와 동일하기 때문에 애니메이션을 매끄럽게 실행할 수 있고, 사용자의 디바이스 성능과 배터리 수명을 고려하며, 비활성 상태 또는 백그라운드에서 실행되는 탭의 처리를 제한할 수 있으며, 다른 브라우저 작업과 동기화되어 실행되기 때문에 일반적으로 애니메이션 처리에 자주 사용되는 `setInterval()`이나 `setTimeout()`과 비교하여 효율적이다.

### CSS 애니메이션 vs JS 애니메이션

CSS 애니메이션은 CSS의 `transition`/`animation` 속성을 이용해 간단한 애니메이션을 적용할 때 사용할 수 있다. 반응형으로 애니메이션을 구현하기 좋으며, *컴포지터 스레드*라는 별도의 스레드에서 처리되기 때문에 기본 스레드에서 무거운 작업을 처리하고 있더라도 중단되지 않는다는 장점이 있다.

JS 애니메이션은 CSS로 처리하기 복잡한 애니메이션을 세밀하게 처리하고 싶을 때 사용할 수 있다. 예를 들어 `Framer Motion` 등의 외부 라이브러리를 통해 스프링 기반 애니메이션 등의 복잡한 애니메이션을 구현할 수 있다.

### 이미지 스프라이트

스프라이트(Sprite) 방식이란 여러 개의 작은 이미지를 하나의 이미지로 합쳐 한 번에 로드할 수 있도록 관리하는 방식을 의미한다. 각 이미지의 크기와 오프셋을 지정해 적절하게 이미지를 잘라서 보여줄 수 있다. 각각의 이미지를 하나씩 로드하는 것보다 속도가 빠르다는 장점이 있지만, 유지보수가 어려워질 수 있으며 합쳐진 이미지 파일을 불러오지 못한다면 해당 이미지를 사용 중인 모든 스프라이트를 볼 수 없게 된다는 단점이 있다.

## 영은

## 8. 쿠키/세션/토큰

|      | 저장 위치  | 관리 위치  | 보안성 | 만료 시간        | 주요 용도                                |
| ---- | ---------- | ---------- | ------ | ---------------- | ---------------------------------------- |
| 쿠키 | 클라이언트 | 클라이언트 | 낮음   | 설정 가능        | 사용자 인증, 상태 유지, 사용자 설정 저장 |
| 세션 | 서버       | 서버       | 높음   | 브라우저 종료 시 | 사용자 인증, 상태 유지                   |
| 토큰 | 클라이언트 | 서버       | 중간   | 설정 가능        | 사용자 인증, 권한 부여, API 요청 인증    |

**쿠키 :** 웹서버에서 클라이언트 컴퓨터에 보내는 작은 파일
**웹 브라우저 상**에 작은 ‘텍스트 파일’로 저장이 되는 **만료 기간이 존재하는 저장소**

- \*\*\*\*서버 요청 시마다 사용자 정보를 확인 할 수 있음.
- 사용자 인증이 유효한 시간을 지정할 수 있다.
  → 유효시간이 정해지면 브라우저가 종료되어도 인증이 유지,
  → 따로 설정하지 않으면 브라우저 종료시 삭제
- XSS 공격에 취약

**예시**

- 로그인 안한 상태에서 물건을 장바구니에 담기
- 웹페이지 언어 설정 저장 (영어, 한글 …)
- 아이디 자동 완성
- 공지 메시지 하루 안보기

---

**세션스토리지 :**  **브라우저의 탭 안에 유효한 저장소**이며**, 브라우저를 닫는 경우 소멸**이 되는 저장소

- 서버에 전송되지 않고 **클라이언트 내에서만 유효** (상대적인 자원 소모가 적다)
- **동일한 도메인과 탭에서만 유효하며**, 다른 도메인 혹은 브라우저 내에서는 유효하지 않음

**예시**

- 임시로 유지되는 입력 폼 정보
- 일회성 로그인

---

**토큰** : 클라이언트와 서버 간의 인증을 위한 문자열로, 주로 JWT(JSON Web Token)가 사용됨

- header와 payload 를 가지고 signaure를 생성하므로 데이터 위변조를 막을 수 있음

## 9. 성능 최적

- **throttle과 debounce**
  함수의 호출을 제어하여 성능을 최적화하는 방법
  - **throttle**
    **일정 주기마다 함수를 호출**하도록 하여 호출 빈도를 제어
  - **debounce**
    함수가 호출된 후 **일정 시간이 지난 후에 실행**되도록 하여, 연이은 이벤트의 발생을 제어
- **requestAnimationFrame**
  - 웹 애니메이션을 위한 메서드로, 브라우저에게 애니메이션을 수행하도록 요청
  - 브라우저의 리플로우와 리페인트 주기에 맞춰 실행되어 부드러운 애니메이션을 제공
  - setTimeout과 달리 **브라우저가 최적화**되어 있어서 60fps(1초당 60프레임)을 유지할 수 있습니다.
- **CSS 애니메이션과 JS 애니메이션**
  - CSS 애니메이션은 CSS 속성을 사용하여 애니메이션을 정의하고 제어.
    ⇒ 브라우저가 애니메이션을 최적화하므로 성능이 우수함.
  - JS 애니메이션은 자바스크립트를 사용하여 애니메이션을 만들고 제어.
    ⇒ 복잡한 애니메이션을 만들 수 있으나 성능에 영향을 줄 수 있다.
- **이미지 스프라이트**:
  - 여러 이미지를 하나의 이미지로 결합하여 서버 요청 수를 줄이고 성능을 향상시키는 기술
  - 웹 페이지 로딩 속도를 높이고 대역폭을 절약할 수 있다.
