## 보경

## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.

**미디어 쿼리란 ?**

CSS에서 미디어 유형이나 특정 장치의 특징에 따라 스타일을 선택적으로 적용하고 싶을 때 사용한다. **`@media`** 규칙을 사용하여 정의된다.

```css
@media media-type and (media-feature-rule) {
}
```

**미디어 타입 `media-type`**

CSS가 어떤 미디어에서 적용될지 지정하는 속성

- 주로 사용되는 미디어 타입 : **`all`**, **`print`**, **`screen`, `speech`**

**미디어 특성 `media-feature`**

CSS를 적용할 조건을 명시. **`min-`** / **`max-`** 접두사를 사용해 범위를 지정할 수 있음

- 주로 사용되는 미디어 특성 : **`**width`**, **`height`**, **`orientation`\*\*

**사용 예시**
보통 화면 크기에 따라 레이아웃을 조정하는데, 이때 화면 너비에 따라 이미지 크기, 특정 요소의 너비, 레이아웃등을 조정해 UX를 향상시킨다.

## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.

**길이(거리) 단위**

- **절대 길이 단위**
  물리적 길이로 고정적인 길이를 나타냄
  화면 출력이 아닌 인쇄물 같은 고정된 크기에 유용
  | 단위 | 설명 |
  | ---- | ---------------------------------------------- |
  | px | 화소 단위로 해상도에 따라 상대적인 크기를 갖음 |
- **상대 길이 단위**
  다른 무언가와 비교해 상대적인 길이를 나타냄
  | 단위 | 설명 |
  | ---- | ------------------------------------------------------------------------------------------------ |
  | em | 부모 요소의 font-size |
  | rem | 최상위 루트 요소 (HTML)의 font-size |
  | vw | 뷰포트의 초기너비 1%와 같습니다. |
  | vh | 뷰포트의 초기 높이 1%와 같습니다. |
  | vmin | vw와 vh 중 작은 것 |
  | vmax | vw와 vh 중 큰 것 |

**각도 단위**

**`<angle>`** 자료형으로 각도를 나타냄

| 단위 | 설명                    |
| ---- | ----------------------- |
| deg  | 360도 = 1개의 원        |
| grad | 400 그라디안 = 1개의 원 |
| rad  | 2π 라디안 = 1개의 원    |
| turn | 1턴 = 1개의 원          |

**시간 단위**

**`<time>`** 자료형으로 시간을 나타냄

| 단위 | 설명               |
| ---- | ------------------ |
| s    | 1초                |
| ms   | 1,000 밀리초 = 1초 |

**진동수 단위**

**`<frequency>`** 자료형으로 진동수를 나타냄

| 단위 | 설명                       |
| ---- | -------------------------- |
| Hz   | 1초당 발생 횟수            |
| kHz  | 1 킬로헤르츠 = 1000 헤르츠 |

**해상도 단위**

**`<resolution>`** [](https://developer.mozilla.org/en-US/docs/Web/CSS/resolution)로 표시되며 스크린과 같은 그래픽 표시에서 CSS 인치당, 센티미터당, 픽셀당 몇 개의 점을 포함할 수 있는지를 나타냄으로써 점 1개의 크기를 표현

| 단위    | 설명               |
| ------- | ------------------ |
| dpi     | 인치당 점의 수     |
| dpcm    | 센티미터당 점의 수 |
| dppx, x | 픽셀당 점의 수     |

- %는 CSS 속성의 값이 될 수 있는 것이지 단위는 아니다.

## 13. 선택자의 우선순위에 대해 설명해주세요.

**선택자 우선순위란 ?**

- 같은 요소에 적용되는 여러개의 스타일 규칙이 있을 때, 어떤 선언의 CSS 속성을 우선적으로 적용할 것인지 결정하는 방법

**선택자 우선순위를 결정하는 기준**

- 중요도 : !important 키워드를 사용해 가장 높은 우선순위
- 스타일의 출처 : 브라우저 기본 적용한 뒤, 사용자가 작성한 스타일을 적용함
- 명시도 : 선택자가 가리키는 것이 명확할수록 우선순위가 높음
  ```css
  인라인 스타일 > id 선택자 > class 선택자 > 태그 선택자
  ```
- 코드 순서 : 동일한 우선순위를 가진다면 나중에 선언된 규칙이 우선순위가 높음

**특별한 키워드(inherit, initial)**

- **inherit**
  Cascade 된 값이 상속을 방해할 때, inherit 키워드를 이용해 상위 요소로부터 값을 상속가능
  border나 padding과 같이 상속되지 않는 프로퍼티의 값을 강제로 상속가능

[](https://sypear.tistory.com/13#%C-%A-)

- **initial**
  적용한 스타일을 취소하고 싶은 경우 initial 키워드를 이용해 설정된 값을 기본값으로 재설정

[](https://sypear.tistory.com/13#%C-%A-)

<br/>

## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?

**`font`**, **`color`**, **`size`** 등 여러 군데에서 반복해서 사용되는 값이 있을 경우 사용. 중복을 피하고 코드를 간결하게 만들수 있다.

## 15. 쌓임 맥락(Stacking Context)이란?

**z-index란 ?**

- HTML 요소가 Z축방향으로 쌓이는 순서를 명시적 지정하는 속성
- 값이 클수록 요소가 상위에 쌓임
- 상속되지 않음
- **`position`** 속성이 **`static`** 이 아니거나, **`flexbox`** 내부에서만 적용된다.

**쌓임 맥락이란 ?**

- HTML 요소들이 화면에서 어떻게 쌓이는지 정의하는 개념
- 쌓임맥락은 다른 쌓임 맥락을 포함할 수 있고 나란히 있을수 있는 계층구조 가짐
- 각각의 쌓임 맥락은 독립적으로 적용됨

**쌓임맥락을 만드는방법**

- **루트 요소 :** 브라우저의 루트 요소(**`<html>`**)는 항상 쌓임 맥락 형성
- **`position: absolute` 또는 `position: relative`이고 `z-index`** 속성이 auto가 아닌 요소
- **`position: fixed` 또는 `position: sticky`로 설정된 요소**
- **`display: flex` 또는 `display: grid` 컨테이너의 자식 요소 중 `z-index`** 속성이 auto가 아닌 요
- **`opacity` 속성이 1보다 작은 값으로 설정된 요소**

## 미림

## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.

```
💡 미디어쿼리(Media Query)는 웹페이지의 스타일을 동적으로 변경할 수 있는 방법을 제공합니다. 미디어 유형과 미디어 기능에 따라 특정 스타일을 적용할 수 있습니다.

```

- **개념**
  - 웹페이지의 스타일을 동적으로 변경하게 함
  - 특정 조건에서 특정 스타일을 적용하는 방법을 제공
    - ⇒ 뷰포트에 따라 서로 다른 레이아웃 적용이 가능 ⇒ 반응형 웹 디자인에 쓰임
    - ⇒ 사용 기기, 환경에 따라 적절한 스타일을 적용 ⇒ UX, 접근성을 높일 수 O
- **동작 방식**
  - 기본 구문
    - 미디어 유형과 조건문을 만족할 때 특정 스타일을 적용할 수 있음
      ```css
      @media 미디어유형 and (미디어기능(=조건)) {
        /* 적용할 CSS 코드 */
      }
      ```
    - 미디어 유형과 미디어 기능은 각각 선택사항임
    - 미디어 유형
      - `all`: 모든 미디어 유형 (default)
      - `print`: 인쇄
      - `screen`: 스크린이 있는 기기 (데스크탑, 태블릿, 모바일, 스크린리더 등)
  - "논리곱" 미디어 쿼리
    - `and`를 사용해 미디어 기능을 결합할 수 있음
      ```css
      @media screen and (min-width: 600px) and (orientation: landscape) {
        body {
          color: blue;
        }
      }
      ```
  - "논리합" 미디어 쿼리
    - `쉼표(,)`를 사용해 `or`를 나타낼 수 있음
      ```css
      @media screen and (min-width: 600px),
        screen and (orientation: landscape) {
        body {
          color: blue;
        }
      }
      ```
  - "부정 논리" 미디어 쿼리
    - `not`을 사용해 쿼리를 부정할 수 있음
      ```css
      @media not all and (orientation: landscape) {
        body {
          color: blue;
        }
      }
      ```
- **예시**

  - 운영체제에 설정된 라이트모드/다크모드 감지
    ```css
    @media (prefers-color-scheme: dark) {
      /* 다크 모드 스타일 */
    }
    ```
  - 기기 별 스타일 적용

    ```css
    /* Style for devices with a maximum width of 768px (e.g., tablets) */
    @media only screen and (max-width: 768px) {
      /* Styles for tablets */
    }

    /* Style for devices with a maximum width of 480px (e.g., smartphones) */
    @media only screen and (max-width: 480px) {
      /* Styles for smartphones */
    }
    ```

## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.

- **주로 사용하는 상대 길이 단위**
  | 단위 | 설명 | 예시 |
  | ---- | ------------------------------------------ | ----------------------------------------------------------- |
  | em | 부모 요소의 font-size 기준 | 부모 요소의 font-size가 14px일 때, 1em = 14px |
  | rem | root 요소의 font-size 기준 | root 요소의 font-size가 14px일 때, 1rem = 14px |
  | vw | 뷰포트 width의 1% 기준 | 뷰포트 width가 800px일 때, 1vw = 8px |
  | vh | 뷰포트 height의 1% 기준 | 뷰포트 height가 800px일 때, 1vh = 8px |
  | vmin | 뷰포트 width와 height 중 작은 값의 1% 기준 | 뷰포트 크기가 100 \* 50px 일 때, 1vmin = 50 \* 0.01 = 0.1px |
  | vmax | 뷰포트 width와 height 중 큰 값의 1% 기준 | 뷰포트 크기가 100 \* 50px 일 때, 1vmax = 100 \* 0.01 = 1px |
  | ex | 요소 글꼴의 "x" 문자의 높이값 기준 | |
  | ch | 요소 글꼴의 "0" 문자의 너비값 기준 | |
- **주의사항**
  - `em` 단위의 경우, 부모-자식 요소 간 스타일 상속이 일어날 때마다 크기가 변동됨
    ```css
    .parent {
      font-size: 10px;
    }
    .child {
      font-size: 2em;
    }
    ```
    ```html
    <div class="parent">
      글꼴 크기는 10px
      <div class="child">
        글꼴 크기는 20px
        <div class="child">글꼴 크기는 40px</div>
      </div>
    </div>
    ```
- **참고**
  - [CSS의 7가지 단위 - rem, vh, vw, vmin, vmax, ex, ch](https://webclub.tistory.com/356)

## 13. 선택자의 우선순위에 대해 설명해주세요.

- **개념**
  - 하나의 요소가 여러 CSS 선언의 대산이 되는 경우, 어떤 스타일을 우선하여 적용할 것인지 결정
- **우선순위 점수(Specificity, 명시도)**

  1. `!important` 선언

     ```css
     p {
       color: blue !important;
     }
     ```

     - 인위적으로 명시도를 높임
     - 권장되지 않음

  2. 인라인 스타일
     - `style` 속성으로 HTML 요소에 직접 적용한 스타일
     - 요소가
  3. ID 선택자 (`#myElement`)
  4. Class 선택자(`.myClass`), 속성 선택자(`[type="text"]`), 가상 클래스(`:hover`)
  5. 유형 선택자(`div`), 가상 요소(`::before`)
  6. 전체 선택자(``), 결합자(`+`, `>`, `~` …), 부정 의사 클래스(`:not()`)

- **계산 방법**
  - 위 우선순위 점수에서 3, 4, 5, 6 항목에 해당하는 수를 각각 네 부분 (a, b, c, d)로 나타내 점수를 셈
  - 가장 높은 점수인 항목을 적용
- **주의사항**

  - 우선순위 점수가 동일한 경우, 나중에 선언된 규칙이 적용됨
  - 우선순위 점수는 스타일이 충돌할 때만 고려됨
  - [다른 요소와의 근접도는 우선순위 점수에 영향을 주지 않음](https://developer.mozilla.org/ko/docs/Web/CSS/Specificity#%ED%8A%B8%EB%A6%AC_%EA%B7%BC%EC%A0%91%EB%8F%84_%EB%AC%B4%EC%8B%9C)

- **참고**
  - [MDN CSS Specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)

## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?

```
💡 CSS 변수를 사용하면 코드를 유연하고 쉽게 유지보수할 수 있고, 코드의 가독성을 높일 수 있습니다. 또 스타일의 일관성을 보장하기 쉬워집니다.

```

- **재사용성**
  - 반복되는 값을 변수로 정의하여 여러 곳에서 재사용 가능
- **유지보수성**
  - 스타일 변경이 용이함
- **코드 가독성 & 시맨틱**
  - 변수 이름을 통해 의미를 부여할 수 있으며 가독성이 높아짐
  - ex) `#00ff00`보다 `-main-text-color`가 이해하기 쉬움
- **일관성**
  - 공통되는 스타일을 변수로 정의하여 통일된 스타일을 제공 가능
  - 예상하지 못한 결과 발생 방지
  - ex) 오타, 잘못된 속성값 등으로 인한 오류를 방지
- **동적 및 반응형 디자인**
  - [JS를 통해 변수를 동적으로 업데이트할 수 있음](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties#values_in_javascript)
  - [반응형 디자인을 할 때 코드 품질을 높임](https://www.daleseo.com/css-responsive-typography/) (중복 코드 제거 등)
- **테마 변경 용이**
  - [변수 집합을 정의하여 테마를 간편하게 변경 가능](https://www.daleseo.com/css-variables/)
  - ex) 라이트 모드/다크 모드 등
- **계산 및 표현식**
  - 변수를 활용해 스타일 내에서 동적으로 계산 가능
- **스코핑**
  - 글로벌/로컬 스코핑으로 체계적인 스타일 구조화, 유연성 제공

## 15. 쌓임 맥락(Stacking Context)이란?

- **개념**
  - 문서를 \*Z축을 사용한 3차원 공간으로 렌더링할 때, Z축 위에서의 요소의 위치(=앞/뒤)를 결정하는 방식
  - \*Z축: 사용자가 화면을 바라보는 방향으로 뻗어 있음
- **종류**
  - **기본 쌓임 맥락**
    - 요소들이 일반적인 문서 흐름대로 쌓이는 방식
  - **플로팅 쌓임 맥락**
    - `float` 속성이 적용된 요소들은 떠있는 것처럼 보임
  - **포지셔닝 쌓임 맥락**
    - `position` 속성이 `relative`, `absolute`, `fixed`인 요소들은 일반적인 문서 흐름에서 벗어남 & 다른 요소들을 덮을 수 있음
  - **플렉스 및 그리드 쌓임 맥락**
    - `display` 속성이 `flex`, `grid`인 부모 요소는 자식 요소들을 배치하는데 새로운 규칙을 제공함
  - **Z 인덱스**
    - `z-index`가 큰 값이 위에 쌓임

## 영은

## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.

**미디어 쿼리 구문 동작방식 및 구성 요소:**

- **미디어 타입(Media Type) 지정** `@media` 규칙으로 시작하여 미디어 쿼리를 정의 `media_type` 부분은 특정한 미디어 타입을 지정한다 ⇒여기 코드가 어떤 미디어를 위한 것인지 브라우저에 알려주는 미디어 유형 ex. `all`, `screen`, `print`
- **미디어 특성(Media Feature) 지정:** `and` 키워드를 사용하여 미디어 타입과 미디어 특성을 연결 `media_feature` 부분은 미디어의 특정한 특성을 지정 ex**.** `width`, `height`, `min-width`, `max-width`, `orientation`
- **조건 설정:** 조건을 설정하여 특정 미디어 특성에 대한 범위를 지정 ex. `min-width: 600px`

```
/* 600px 이하의 너비일 때 적용되는 스타일 */
@media screen and (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

/* 601px 이상의 너비일 때 적용되는 스타일 */
@media screen and (min-width: 601px) {
  body {
    background-color: lightgreen;
  }
}
```

조건이 충족되면 스타일 규칙 적용 뷰포트의 특정 조건에 따라 CSS 규칙을 적용하여 웹 페이지를 반응형으로 만들 수 있음.

## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.

1. **절대 길이 단위 (Absolute Length Units):**
   - **px (픽셀):** 가장 일반적으로 사용되는 단위로, 화면의 해상도에 따라 다르지만 고정된 크기.
   - **in (인치):** 1 인치에 해당하는 크기.
   - **cm (센티미터):** 1 센티미터에 해당하는 크기.
   - **mm (밀리미터):** 1 밀리미터에 해당하는 크기.
2. **상대 길이 단위 (Relative Length Units):**
   - **em:** **부모 요소의 폰트 크기**에 대한 상대적인 크기
   - **rem:** **루트 요소**(보통 **`<html>`**)의 폰트 크기에 대한 상대적인 크기.
   - **% (퍼센트):** **부모 요소**에 대한 상대적인 크기.
3. **Viewpoint Percentage Length Units:**
   - **vw (뷰포트 너비):** 뷰포트 너비의 백분율로 크기를 씀.
   - **vh (뷰포트 높이):** 뷰포트 높이의 백분율로 크기를 씀.
   - **vmin:** 뷰포트의 높이 또는 너비 중 작은 쪽에 대한 백분율 크기를 씀.
   - **vmax:** 뷰포트의 높이 또는 너비 중 큰 쪽에 대한 백분율 크기를 씀.
4. **상대적인 디스플레이 단위:**
   - **% (퍼센트):** 부모 요소에 대한 백분율로 요소의 크기를 씀.
   - **fr (fractional unit):** 그리드 레이아웃에서 사용되며, 사용 가능한 공간의 비율을 나타냄.
5. **색상 단위:**
   - **RGB, RGBA:** 빨강, 초록, 파랑의 색상을 나타냅니다. RGBA에서 A는 투명도를 나타냄.
   - **HEX:** RGB 색상을 16진수로 나타낸 것.
   - **HSL, HSLA:** 색상, 채도, 밝기(또는 투명도)를 나타냄.

## 13. 선택자의 우선순위에 대해 설명해주세요.

화면에 그려질 때 어떤 CSS를 적용시킬지에 대한 규칙

1. **인라인 스타일 (Inline Styles):** 가장 높은 우선순위를 가지며, 직접 **HTML 요소**의 **`style`** 속성에 정의된 스타일. 계산시 `1000` 으로 계산
2. **아이디 선택자 (ID Selectors):** ID 선택자로 선택된 요소에 적용된 스타일은 인라인 스타일 다음으로 높은 우선순위를 가짐. 계산시 `100` 으로 계산
3. **클래스 선택자 및 속성 선택자 (Class Selectors & Attribute Selectors):** 클래스 선택자와 속성 선택자로 선택된 요소에 적용된 스타일은 아이디 선택자 다음으로 높은 우선순위를 가짐. 계산시 `10` 으로 계산
4. **요소 선택자 및 가상 클래스 선택자 (Type Selectors & Pseudo-class Selectors):** 요소 선택자와 가상 클래스 선택자로 선택된 요소에 적용된 스타일은 클래스 선택자와 속성 선택자 다음으로 높은 우선순위를 가짐.계산시 `1` 으로 계산
5. **전체 선택자 (\*):** 가장 낮은 우선순위를 가지며, 모든 요소에 영향을 미침. 계산시 `0` 으로 계산 ⇒ 각 선택자 우선순위 값들을 더하면 높은 순서대로 전체 선택자 우선순위가 된다. 동일한 우선순위를 갖는 경우에는 나중에 정의된 스타일 규칙이 우선됨.

계산 시, 다 더해서 높은순서로 명시도를 계산하고(자세하게 적을 수록) 우선순위가 됨

이 외에도 **`!important`**를 사용하면 일반적인 선택자 우선순위 규칙을 무시하고 강제로 스타일을 적용 할 수 있다. 오용 시 코드의 유지보수를 어렵게 만들 수 있다. 무분별한 사용은 디버깅과 스타일 관리를 복잡하게 할 수 있으므로 신중하게 사용해야하고 최소한으로 사용해야 한다.

**우선순위** !important(나쁜습관) > 인라인 스타일 > 아이디 > 클래스,어트리뷰트 > 요소,가상클래스 > 전체선택자

## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?

```
💡 CSS 변수는 코드의 유지보수성과 일관성을 향상시키며,
동시에 동적인 스타일 조작이 가능한 강력한 도구로서의 역할을 수행
```

- **스타일 일관성과 유지보수성 향상**

한곳에서 스타일을 변수로 색상, 여백, 폰트 크기 등의 스타일 값을 효과적으로 관리할 수 있어 코드의 유지보수성을 향상시키며 디자인 변경이 필요할 때 효율적으로 대응할 수 있다. 또한 디자인의 일관성을 유지하는데 도움이 됨

- **동적인 스타일 조작 가능**

JavaScript를 통해 CSS 변수 값을 동적으로 변경할 수 있다. 사용자 상호작용에 따라 스타일을 동적으로 조작하거나, 테마 전환 등 다양한 동적 스타일링을 가능하게 한다. 이는 웹 애플리케이션의 인터랙티브한 요소를 개발하는 데 도움이 된다.

- **코드의 간결성 및 가독성 상승**

CSS 변수를 활용하면 코드가 더 간결하고 가독성이 좋아지며, 긴 속성 값을 간략하게 표현할 수 있다.

`nav p { 16px ;}` 보다 `nav p {--font-regular;}` 가 더 기억하기 쉬우며 가독성이 좋다

### 사용법

- **변수 선언** **`:root`** 또는 요소 안에서 선언될 수 있습니다. \**`:root`*는 문서의 최상위 요소를 가리키며, 전역 변수를 선언할 때 주로 사용된다.

```css
// 루트 선언 예시
:root {
  --primary-color: #3498db;
  --secondary-color: #e74c3c;
}
// 일반 요소 선언 예시
.container {
  --main-color: #3498db;
}
```

⇒ CSS 변수는 선언된 요소 내에서만 유효하며 상속되지 않는다고 함.

- **변수 사용** 선언된 변수는 **`var()`** 함수를 사용하여 적용한다. ex. `color: var(--text-color, #333);`
- **자바스크립트로 동적변경**

```jsx
document.documentElement.style.setProperty('--primary-color', '#FF5733');
```

- **미디어쿼리** 미디어 쿼리 내에서 변수를 사용하여 다양한 디바이스에 대응할 수 있다.

## 15. 쌓임 맥락(Stacking Context)이란?

사용자 기준에서 뷰포트 혹은 웹페이지를 바라보고 있을 때 가상의 Z축을 사용한 HTML 요소의 3차원 개념화이다. 간단히 설명하자면, `z-index`를 묶어서 생각하는 범위라고 할 수 있음.

개념 자체는 복잡하지 않지만 쌓임 맥락이 만들어지는 조건은 굉장히 복잡함

**조건**

- 문서의 루트 요소(`<html>`)
- `position`이 `absolute`이거나 `relative`이고, `z-index`가 `auto`가 아닌 경우
- `position`이 `fixed`이거나 `sticky`인 경우
- 플렉스박스(우리가 다음 챕터에서 배울 개념)나 그리드(우리가 다음 다음 챕터에서 배울 내용)의 자식 중 `z-index`가 `auto`가 아닌 경우
- `opacity`가 1보다 작은 요소

… 이 밖에도 더 있으니 mdn 참고! ⇒ [MDN\_쌓임맥락](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)

사실 이런 조건들은 웹 브라우저를 만드는 사람들이 꼼꼼하게 챙기면 되고, 프론트를 배우는 우리는 좀 더 실용적으로 접근하면 된다고 한다. 의도와 다르게 내가 원하는 대로 `z-index`가 동작하지 않거나, `z-index` 값이 너무 많아지고 복잡해져서 코드가 헷갈릴 때 사용한다.

**장점**

쌓임 맥락은 형제 쌓임 맥락과 완전히 분리된다. 쌓임을 처리할 땐 자손 요소만 고려한다.

⇒ 쌓임 맥락만 분명하다면 바깥은 신경 쓰지 않고 코드를 쉽게 쓸 수 있다

ex. 내비게이션 같은 걸 만들 때도 `z-index` 숫자를 무한정 크게 하지 않아도 깔끔하게 값을 쓸 수 있음.
