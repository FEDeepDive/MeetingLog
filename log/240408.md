## 보경

### 1. 고차 컴포넌트(HOC, Higher Order Component)

React에서 컴포넌트 로직을 재사용하기 위해 사용되는 디자인 패턴중 하나이다. 다른 컴포넌트를 인자로 전달받아 새로운 컴포넌트를 반환하는 함수이다로직을 재사용 하거나, props를 전달받아 컴포넌트르 확장하는 경우 사용되며 이를 통해 여러 컴포넌트에서 공통적으로 사용되는 로직을 한 곳에 추상화하고, 코드의 재사용성과 가독성을 향상시킨다.

### 2. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

**Redux**

- 가장 대표적인 상태 관리 라이브러리
- 단방향 데이터 흐름
- 중앙 집중식 상태 관리 방식
- 액션, 리듀서, 스토어를 기반으로 작동
- 확장성이 높고 다양한 기능 제공
- 복잡한 애플리케이션에 적합

**MobX**

- 간단하고 직관적인 API 제공
- 반응형 상태 관리 라이브러리로 자동으로 상태변화 감지 → 컴포넌트 업데이트
- 중앙 스토어 없이 객체 기반 상태 관리 가능
- 소규모 애플리케이션에 적합

**Recoil**:

- 페이스북에서 개발한 상태 관리 라이브러리
- atom 이라는 상태의 단위를 가지며 업데이트와 구독이 가능하다.
- 리액트 문법 친화적이며 동일한 atom 값에 대해 캐싱된다.

**Zustand**

- 발행/구독 모델을 기반으로 이루어져 있다.
- 스토어를 생성하는 함수 호출 시 클로저를 사용한다. 이로 인한 특징으로 상태를 변경, 조회, 구독하는 인터페이스를 통해서만 상태를 다루고, 실제 상태는 생명 주기에 따라 처음부터 끝까지 의도하지 않는 변경에 대해 막을 수 있다는 점이 있다.
- 주스탠드의 다른 특징으로 일시적 업데이트(Transient Update)가 있는데, 상태가 자주 바뀌더라도 매번 업데이트가 일어나지 않고 리렌더링을 제어할 수 있는 기능이다. 리액트에 종속되지 않은 도구여서 가능한 점이다.

**Jotai**

- 아토믹 접근을 가지고 만든 라이브러리
- atom 이라는 상태의 단위를 가짐
- 나머지는 zustand랑 비슷한듯

### 3. 클라이언트 상태와 서버 상태의 차이?

**클라이언트 상태**

- 서버에서 일어나는 일과는 아무 관련이 없는 상태로 프론트에서 관리됨
- 사용자의 브라우저나 애플리케이션 내에서 관리
- UI 상태, 사용자 입력, 임시 데이터 등의 상태

**서버 상태**

- 클라이언트에 표시하는 데 필요한 서버 데이터로 백엔드에서 관리됨
- 데이터베이스, 파일시스템, 캐시등에 저장되어 관리
- 사용자 정보, 게시물 정보, 상품 정보 등의 상태

ref) [https://velog.io/@okko8522/서버-상태-클라이언트-상태](https://velog.io/@okko8522/%EC%84%9C%EB%B2%84-%EC%83%81%ED%83%9C-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%83%81%ED%83%9C)

## 미림

## 4. 고차 컴포넌트

- **개념**
  - HOC(Higher Order Component)
  - 컴포넌트 **로직 재사용**을 위해, 해당 컴포넌트를 감싼 **새로운 컴포넌트**를 반환하는 함수
  - Hooks의 등장으로 로직 재사용이 간편해져 과거에 비해 잘 사용되지 않지만, 여전히 유용함
- **특징**
  - 컴포넌트를 인자로 받아 새로운 컴포넌트로 반환함
  - 원본 컴포넌트를 수정하지 않고 기능을 추가함 (순수 함수)
  - props로 컴포넌트에 데이터나 동작을 주입 가능
- **예시**
  - 특정 권한이 필요한 모든 컴포넌트에서 권한 확인하기 번거로움 (Hook을 사용해도 되지만, 그러면 컴포넌트 내부에 권한 확인 로직이 추가되는 단점) ⇒ `withAuthorization`라는 HOC를 만들어 컴포넌트를 인자로 받고, 권한이 있을 때만 컴포넌트를 렌더링하게 함. 권한이 필요한 컴포넌트는 권한이 있는 경우의 동작만 코드로 적고, `withAuthorization(component)`를 export

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

- Redux
  - ✅ 많이 쓰임 ⇒ 레퍼런스 많음
  - ✅ 미들웨어가 많음 ⇒ 어떤 작업을 직접 제어하기 유용함 (⇒ 큰 프로젝트에서 많이 사용)
  - ❌ 보일러플레이트 코드가 많이 필요
- Zustand
  - ✅ 가벼움
  - ✅ 러닝커브가 낮음
  - ✅ 코드가 간단함
  - ❌ 레퍼런스가 비교적 적음
- Recoil
  - ✅ JS 라이브러리가 아니라, React 전용 라이브러리 ⇒ React와 호환 굿
- Jotai
- React Query (TanStack Query)
  - ✅ 서버 상태 관리 (위 다른 라이브러리는 클라이언트 상태 관리)
  - ✅ 데이터 페칭, 캐싱, 최적화 등을 간편하게 사용할 수 있도록 지원함

## 6. 클라이언트 상태와 서버 상태의 차이?

- **클라이언트 상태**
  - 개념
    - 클라이언트(브라우저/기기)가 제어권을 가지고 있으며, 동기적으로 동작하는 상태
    - ⇒ 항상 최신 값을 가짐
  - 범위에 따른 분류
    - `로컬 상태`: 컴포넌트 내부에서 관리하는 상태
    - `글로벌 상태`: 상태관리 라이브러리, contextAPI 등을 사용해 전역적으로 관리하는 상태
  - 예시
    - UI 상태
    - 브라우저 쿠키
- **서버 상태**
  - 개념
    - 서버(DB)에서 관리되어, 비동기적으로 동작하는 상태
    - ⇒ 데이터 조회 시점의 상태(스냅샷)이므로, 최신 값과 다를 수 있음
  - 예시
    - 로딩중, 에러, 성공 등 API 응답 상태

## 정욱

## 4. 고차 컴포넌트

컴포넌트가 props를 입력으로 받아 UI를 반환하는 함수라면, 고차 컴포넌트는 컴포넌트를 입력으로 받아 새로운 컴포넌트를 반환하는 함수이다. 동일한 로직이 여러 컴포넌트에서 중복되는 경우, 이를 분리해내어 재사용할 수 있도록 하는 일종의 패턴이다.

계층적으로 나누어져 구성된 클라이언트 애플리케이션의 각 계층이 공통적으로 다루어야 하는 관심사를 해결하기 위해서 사용할 수 있다. 중복되는 로직의 재사용성을 높이고, 관심사 분리를 할 수 있다는 장점이 있지만 컴포넌트 계층 구조가 복잡해진다는 단점이 있다.

```jsx
// HOC에는 일반적으로 'with' 접두어가 붙음

// 클래스 컴포넌트 형태
function withConcern(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
    }

    componentDidMount() {
      const { propForThisConcern, ...propsForRender } = this.props;
      console.log('Log from mount');
      console.log(propForThisConcern);
    }

    render() {
      const { propForThisConcern, ...propsForRender } = this.props;
      return <WrappedComponent {...propsForRender} />;
    }
  };
}

// 함수 컴포넌트 형태
const withConcern = (WrappedComponent) => (props) => {
  const { propForThisConcern, ...propsForRender } = props;

  useEffect(() => {
    console.log('Log from first render');
    console.log(propForThisConcern);
  }, []);

  return <WrappedComponent {...propsForRender} />;
};
```

---

이해하기 좋았던 블로그 포스트: https://jeonghwan-kim.github.io/2022/05/28/react-high-order-component

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

### 클라이언트 상태 관리 라이브러리

Zustand, Jotai, Valtio, XState, Recoil, Redux, MobX

### 서버 상태 관리 라이브러리

Tanstack Query(React Query), SWR

## 6. 클라이언트 상태와 서버 상태의 차이?

### 클라이언트 상태

1. 내가 제어할 수 있는 위치(브라우저 또는 애플리케이션)에 존재함
2. 데이터를 쉽게 조회 및 수정할 수 있음
3. 데이터를 공유하지 않으며, 단일 사용자 환경에서만 유효함

### 서버 상태

1. 내가 제어하거나 소유하지 않는 위치에 존재함
2. 조회하거나 수정하기 위해 비동기 API를 필요로 함
3. 불특정 다수와 공유하며, 내가 모르는 사이에 변경될 수 있음
4. 최신 데이터가 아닐 수 있음

## 영은

## 4. 고차 컴포넌트

<aside>
💡  컴포넌트 로직을 재사용하기 위해 함수 컴포넌트를 감싸는 컴포넌트

</aside>

주로 함수를 매개변수로 받아서 기존의 클래스 컴포넌트를 수정하거나 래퍼 컴포넌트를 생성하여 클래스 컴포넌트를 감싸는 방식으로 동작

- 일반적으로 클래스 컴포넌트를 기반
- 고차 컴포넌트는 컴포넌트 간의 공통된 로직을 추상화했다고 함.
- 코드의 재사용성과 유지 보수성을 높이는데 사용됐다고 함

⇒ 컴포넌트 트리의 구조를 변경할 수 있고, 고차 컴포넌트를 여러 겹으로 중첩시키면 이해하기 어려운 코드가 되는 경우가독성이 안좋아 질 수 있었기에, ❗최신 React 코드에서 일반적으로 사용되지 않는다고 한다.

⇒ 문제 해결을 위해 리액트 훅스의 도입, 함수 컴포넌트의 도입

## 5.상태 관리 라이브러리 종류를 아는 대로 말해주세요.

**Flux**
데이터의 변경을 한 곳에서 하면서 흐름을 정리하는 facebook에서 만든 라이브러리

**Redux (2015)**
가장 인기 있는 상태 관리 라이브러리 중 하나로, 단방향 데이터 흐름을 제공하며, 상태를 중앙 집중화하여 관리

**recoil(2020)**
Facebook에서 개발한 최신 상태 관리 라이브러리로, 리액트 애플리케이션의 상태를 전역적으로 관리하는 데 사용

## 6.클라이언트 상태와 서버 상태의 차이?

둘을 구분하는 법 : 데이터의 출처! ⇒ 사용자의 컴퓨터나 장치 vs 서버

클라이언트 상태

<aside>
💡 웹사이트의 어떤 메뉴가 열렸는지 닫혔는지, 혹은 사용자가 어떤 버튼을 눌렀는지 아닌지와 같은 UI 상태 값이나, 유저가 입력 폼에 입력한 데이터 등 서버와는 상관없이 웹 브라우저 안에서만 사용하는 데이터

</aside>

서버 상태

<aside>
💡 클라이언트로부터 요청을 받아 처리하고, 결과를 다시 클라이언트에게 돌려주는 컴퓨터나 프로그램

</aside>

→ 보통 요청된 서비스나 데이터를 제공하기 위해 데이터베이스나 다른 시스템과 상호 작용
