## 보경

## 1. `this`

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수

**`this` 바인딩**

식별자와 값을 연결하는 과정으로 **`this`** 라는 식별자와 **`this`**가 가리키는 객체를 바인딩 하는 것. **`this`** 바인딩은 함수 호출 방식에 따라 동적으로 결정

**함수 호출 방식에 따른 `this` 바인딩**

| 함수 호출 방식 | this 바인딩 |
| --- | --- |
| 일반 함수 호출 | 전역 객체 |
| 메서드 호출 | 메서드를 호출한 객체 |
| 생성자 함수 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |

## 2. 클래스+`new`의 동작 방식?

클래스란 객체를 생성하기 위한 템플릿으로 객체의 상태나 행동을 정의함

**`new`** 키워드르 사용해서 클래스를 호출해 객체를 생성할 수 있다.

클래스는 표현식으로 정의할 수 있기 때문에 일급 객체이다.

## 3. 불변성

새로운 값을 생성하지 않고는 내용을 변경할 수 없는 값

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

자바스크립트의 데이터 타입은 크게 **`원시타입`**과 **`객체타입`**으로 구분됨

|  | 원시타입 | 객체타입 |
| --- | --- | --- |
| 변경 가능 여부 | 변경 불가능 | 변경 가능 |
| 변수 할당 | 실제 값이 저장 | 참조 값이 저장 |
| 다른 변수에 할당 | 값에 의한 전달 | 참조에 의한 전달 |
| 종류 | number, string, boolean, undefined, null, symbol, bigint | 객체, 함수, 배열 |

## 미림

## 1. `this`

```
💡 `this`는 함수 호출 방식에 따라 결정됩니다.
1️⃣일반 함수에서는 전역 객체, 2️⃣메서드에서는 메서드의 주인인 객체, 3️⃣생성자에서는 생성된 인스턴스, 4️⃣이벤트리스너에서는 `event.currentTarget`을 의미합니다.
```

- **함수 호출에 따라 결정되는 `this`**
    - JS에서 `this`는 함수 선언 시 정적으로 결정되는 게 아니라, **함수 호출 시 호출 상황에 따라 동적으로 결정됨**
- **함수 호출에 따른 바인딩 객체**
    - 1️⃣일반 함수 안에서 `this` ⇒ 전역 객체 (2️⃣에 근거)
        - 콜백 함수에서 `this` ⇒ 전역 객체
        - 함수 내부 함수에서 `this` ⇒ 전역 객체
    - 2️⃣메서드 안에서 `this` ⇒ 메서드 주인 객체
    - 3️⃣생성자 안에서 `this` ⇒ 생성한 인스턴스
    - 4️⃣`addEventListener()` 안에서 `this` ⇒ 이벤트를 발사한 요소 `event.currentTarget`
    - 🚨화살표 함수는 상위 요소의 `this`를 물려받음

## 2. 클래스

- **개념**
    - 객체(인스턴스)를 생성하기 위한 템플릿
    - ES6
- **특징**
    - 선언 전 사용 불가
        - 호이스팅이 안된다는 주장 vs. 호이스팅은 되는데 TDZ 제한이 있다는 주장(`let`처럼)
    - 접근 제한 기능(`#`: private)
    - 생성자(`constructor`)를 가짐
    - `extends`를 사용해 상속 가능
        - `super`를 사용해 부모 클래스의 메서드 호출 가능
    - `static`을 사용해 인스턴스화 없이 필드, 메서드 등을 사용 가능
- **번외) Prototype 상속**
    - 프로토타입을 이용해 상속 구현 가능
        - 현재 스코프에 프로퍼티가 없으면 원형 객체(프로토타입)에서 해당 프로퍼티를 찾음
        - ⇒ 이 성질을 이용해 클래스 기반 언어의 상속과 비슷한 효과를 냄
    - Prototype으로 상속 구현 시 다소 복잡함 ⇒ (ES6) Class로 간단하게 구현 가능
- **번외) `new`의 동작 방식**
    - `new` 연산자를 사용해 객체(인스턴스) 생성 가능
        
        ```jsx
        function User(name) {
          this.name = name;
        }
        
        let user = new User('Finn'); // 'new'를 붙여 함수 실행 => 생성자 함수라고 함
        ```
        
        ```jsx
        class User {
          this.name = name;
        }
        
        let user = new User("Finn"); // 'new'를 붙일 시 클래스의 constructor가 실행됨
        ```
        

## 3. 불변성

- **불변성이란?**
    - 값이 변경되지 않는 특성
- **원시 타입 vs. 객체**
    
    
    |  | 원시 타입(primitive) | 객체(Object) |
    | --- | --- | --- |
    | 특징 | 불변성(immutable) | 가변성(mutable) |
    | 해석 | 원시 타입의 값은 메모리에 그대로 남아있으며 절대 변형되지 않음 | 객체 내부 값 변경이 가능함. 변경 시, 객체를 참조하고 있는 다른 값들도 변경됨 |
    - 자세한 내용: [자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?](notion://www.notion.so/kyoung2/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md#4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%9E%90%EB%A3%8C%ED%98%95%20%EC%A4%91%EC%97%90%20%EA%B0%9D%EC%B2%B4%EC%99%80%20%EB%8B%A4%EB%A5%B8%20%ED%83%80%EC%9E%85%20%EA%B0%84%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EA%B0%80%20%EC%9E%88%EC%9D%84%EA%B9%8C?)
- **객체에서 불변성을 유지하는 방법**
    - `Object.freeze()`
        
        <aside>
        💡 `Object.freeze()`는 직속 객체만 얼림(얕은 동결)
        ⇒ 중첩된 객체의 경우 객체 하나하나를 얼려야 함(깊은 동결)
        
        </aside>
        
- **불변성 유지의 중요성**
    - 일관적인 상태 ⇒ 안정성

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

### 원시 타입과 객체 간 비교

|  | 원시 타입(Primitive Type) | 객체(Object) |
| --- | --- | --- |
| 변성 | 불변성(immutable). 즉 값 자체를 변경할 수 없음. | 가변성(mutable). |
| 저장 방식 | 메모리에 실제 값이 저장됨 | 메모리에 참조 값이 저장됨 |
| 복사 방식 | 값을 복사 (=값에 의한 전달) | 주소값을 복사 (=참조에 의한 전달) |

```jsx
// 원시 타입
var num = 80;
var copied = num; // 값이 복사되어, 서로 다른 메모리에 저장됨

num = 100; // 🚨 다른 값을 할당하는 건 불변성과 관련이 없음

console.log(num); // 100
console.log(copied); // 80

```

```jsx
// 객체 타입
const user1 = {
  name: 'Bob',
};
user1.age = 20; // 속성 추가/변경/삭제 가능

const user2 = user1; // user1이 참조한 객체의 메모리 주소 값을 복사해 동일한 객체 참조
user2.name = 'Alice';

console.log(user1.name); // Alice
console.log(user2.name); // Alice

```

### 참고

- [JavaScript 원시 값과 객체의 비교](https://velog.io/@najiexx/JavaScript-%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90-2aovlqxf)

## 정욱

## `this`

JavaScript의 `this` 예약어는 다른 언어와 달리, 함수의 호출 방식에 따라 `this`에 연결될 객체가 동적으로 결정될 수 있다.

### 일반적인 함수 호출

함수의 이름 뒤에 소괄호 쌍이 오는 ‘일반적인’ 형태로 함수가 호출되는 경우, 어떠한 실행 컨텍스트에서 실행되었는지에 따라, 또 엄격 모드 여부에 따라 `this`에 연결되는 객체가 달라진다.

| this? | 전역 실행 컨텍스트 | 함수 실행 컨텍스트 |
| --- | --- | --- |
| 엄격모드 | 전역 객체 | undefined |
| 비 엄격모드 | 전역 객체 | 전역 객체 |

전역 객체는 JavaScript가 실행되는 환경에 따라서 달라지는데, 브라우저에서 실행되는 경우 `window` 객체, Node.js 같은 서버사이드 런타임에서는 `global` 객체가 된다. 어떠한 경우에서든 전역 객체에 접근하고 싶은 경우, `globalThis` 프로퍼티에 접근하면 된다. 

### 메소드 형식 호출

어떠한 객체의 특정 프로퍼티가 함수일 경우, 속성 접근자를 활용해 함수명에 접근한 후 소괄호 쌍을 붙여주어 해당 객체의 메소드로 호출할 수 있다. 이 경우, `this`의 값은 해당 객체를 사용한다.

```jsx
const obj = { f: function() { console.log(this); } };

// 속성 접근자 두 가지: 점 표기법, 괄호 표기법
// result: Object { f: f() }
obj['f']();
obj.f();
```

### 생성자로써 호출

`new` 키워드를 사용하여 함수를 생성자로 사용하는 경우 함수 실행 전에 빈 객체가 생성되며, 해당 함수 내에서 `this`는 해당 객체에 연결된다. 이후 `this`를 통해 만든 프로퍼티나 메소드 또한 해당 객체에 추가된다.

### 화살표 함수

화살표 함수는 JS의 일반적인 함수와 다르게 정적으로 `this`에 연결될 객체가 결정된다. 즉, 자기 자신만의 `this` 값을 가지지 않으며 항상 자신의 상위 스코프에서 `this`를 상속받아 사용한다.

### `call()`, `apply()`, `bind()`

함수가 가지고 있는 `call()`, `apply()`, `bind()` 메소드를 사용하면 어떠한 값이 `this`에 연결될지 명확하게 지정해줄 수 있다. 해당 메소드들의 첫 번째 인자로 제공한 객체가 함수의 `this`에 연결된다.

## 클래스

JavaScript는 프로토타입 기반 객체지향을 채택하고 있는 언어였지만, ES6에서 `class` 예약어와 함께 클래스 기반 객체지향을 사용할 수 있게 되었다. JavaScript에서의 클래스는 프로토타입을 이용하여 구현되었기 때문에 클래스는 프로토타입의 문법 설탕이라는 의견이 있으며, 클래스를 사용할 경우 프로토타입을 사용하는 것보다 좀 더 많은 일이 내부적으로 일어나기 때문에 그렇지 않다는 의견 또한 존재한다.

### 클래스를 정의하는 방법

`class` 키워드를 사용하여 클래스를 정의할 수 있으며, 함수를 함수 선언문과 함수 표현식으로 정의할 수 있듯 class 선언문과 class 표현식 두 가지 방법이 제공된다.

```jsx
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

const Square = class {
  constructor(side) {
    this.side = side;
  }

  area() {
    return this.side * this.side;
  }
}

// result: 15
console.log(new Rectangle(3, 5).area());
// result: 49
console.log(new Square(7).area());
```

### `new`

클래스는 `constructor`라는 이름을 가진 특별한 메소드를 딱 하나씩 가질 수 있는데, `new` 키워드와 함께 해당 클래스명에 소괄호 쌍을 붙여 호출하는 경우 `constructor`를 호출하게 된다. 소괄호 쌍 안에 제공한 인자는 `constructor`의 매개변수를 통해 접근할 수 있다.

## 불변성

JavaScript에는 `string`, `number`, `bigint`, `boolean`, `undefined`, `null`, 그리고 `symbol`까지 총 7개의 원시 자료형이 있으며, 모든 원시 자료형은 변경이 불가능하다. 원시 자료형 이외의 모든 값은 객체 타입이며, 객체 타입은 변경 가능하다. 

### `Object.seal()`

객체에 프로퍼티를 추가하거나 삭제할 수 없게 만드는 메소드이다.

### `Object.freeze()`

`Object.seal()`의 동작에 더하여, 존재하는 프로퍼티의 변경을 막는 메소드이다. 해당 메소드를 사용하여도 객체 내부의 객체는 변경 가능하며, 내부 객체까지 변경 불가능하게 만들기 위해서는 해당 객체가 가지고 있는 모든 객체에 대해 깊이 우선 탐색을 수행하여 `Object.freeze()`를 적용해주어야 한다.

## 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

1. 객체는 원시 자료형과 달리 변경 가능하다는 특징이 있다.
2. 원시 자료형은 값으로 비교되기 때문에, 서로 같은 값을 가지고 있다면 동등하다고 말할 수 있다. 그러나 객체는 값으로 비교되지 않으며, 이는 곧 서로 같은 이름의 프로퍼티를 같은 순서와 같은 값으로 가지고 있다고 해도 서로 동등하다고 말할 수 없다. 서로 같은 메모리 공간에 위치하는 객체들끼리만 서로 동등하다고 말할 수 있다.
3. `typeof (function(){}) !== 'object'`이기 때문에 헷갈리기 쉽지만, `(function(){}) instanceof Object === true`이기 때문에, 함수 또한 일종의 객체라는 사실을 알 수 있다.

## 영은

## 1. `this`

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

✔ this는 자바스크립트 엔진에 의해 암묵적으로 생성

✔ 코드 어디서든 참조할 수 있다

✔ this가 가리키는 값, 즉 this 바인딩(식별자와 값을 연결하는 과정)은 **함수 호출 방식에 의해 동적으로 결정**된다.

🎈아래 표만 외워도 this가 뭘 가리키는지 정도는 쉽게 알아챌 수 있을것이다.

| 호출 방식 | this 바인딩 | 예시 |
| --- | --- | --- |
| 일반 함수 호출 | 전역 객체 | javascript regularFunction(); |
| 메서드 호출 | 메서드를 호출한 객체 | javascript obj.methodFunction(); |
| 생성자 함수 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 | javascript new ConstructorFunction(); |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | 첫 번째 인수로 전달한 객체 | javascript someFunction.apply(someObject); |
| Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 | 전달한 객체에 바인딩 | javascript someFunction.call(someObject); |

## 2. 클래스

자바스크립트는 프로토타입 기반 언어라서 클래스 기반 언어에 익숙한 프로그래머에겐 익숙하지 않아 다소 혼란스럽거나 어렵게 느낄 수 있었다. 때문에 ES6에서 도입된 클래스는 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 **새로운 객체 생성 메커니즘**을 제시한다.

✔ 클래스 몸체에서 정의할 수 있는 메서드는 **constructor(생성자), 프로토타입 메서드, 정적 메서드** 세가지가 있다.

**constructor**

- constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
- constructor 내부의 this는 클래스가 생성한 인스턴스를 가르킨다.
- 클래스 내에 최대 한 개
- 생략 가능 -> 빈 constructor 암묵적 생성
- 내부에서 return 문 반드시 생략

**프로토타입 메서드**

- 클래스 몸체에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.
- 클래스는 프로토타입 기반의 객체 생성 메커니즘

**정적 메서드**

- static이라는 키워드를 붙이면 정적 메서드
- 정적 메서드는 클래스에 바인딩된 메서드
- 정적 메서드는 인스턴스로 호출 불가

```jsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

✔ 클래스는 함수다. 자바스크립트에서 함수는 일급 객체다. 그러므로 클래스도 일급 객체다!

✔ 클래스는 재정의될 수 없다. 재정의를 시도하면 `SyntaxError` 가 발생한다.

✔  클래스는 호이스팅이 발생하지만, 정의 이전에 참조 할 수 없다. ⇒ 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지게 되기 때문에 호이스팅이 발생하지 않는 것처럼 동작

💬 클래스 선언문은 소스코드 평가 단계에서 이미 함수 객체를 생성하는데 일반 함수 선언문과 같이 소스코드 순서 상 이전에 호출할 수 없는 이유는?

✅ 클래스 함수 객체는 런타임 이전에 생성이 되는건 맞지만 내부 메서드들은 new 연산자로 생성한 인스턴스가 생성될 때 유효한 것이므로 클래스 선언 이후에 사용가능하다.

✔ 생성자 함수와의 차이점

| 특징 및 차이점 | 생성자 함수 | 클래스 |
| --- | --- | --- |
| 구문 | function Car(make, model) { ... } | class Car { constructor(make, model) { ... } } |
| 호출 방식 | new Car()로 호출 | new Car()로 호출 |
| 프로토타입 기반 | 지원 | 내부적으로 지원 (명시적 설정 불가능) |
| 프로토타입 메서드 추가 | Car.prototype.drive = function() { ... } | 메서드 정의 구문 사용 (자동으로 프로토타입에 추가됨) |
| this 바인딩 | 호출한 객체에 바인딩 | 항상 인스턴스에 바인딩 |
| 상속 | 프로토타입 체인 사용 | extends 키워드 사용 |

**클래스 필드**

클래스 내에서 선언되는 변수를 의미, 클래스의 인스턴스가 아닌 클래스 자체에 속하는 속성이며, 각 인스턴스에서 독립적인 값을 갖지 않고 모든 인스턴스가 공유한다.

- **정적클래스 필드**
    
    정적 클래스 필드는 클래스의 모든 인스턴스에서 공유되며, 클래스 자체에 속한다. 정적 필드는 **`static`** 키워드를 사용하여 정의된다.
    
- **프라이빗 클래스 필드**
프라이빗 클래스 필드는 클래스 내에서만 접근 가능한 필드로, 클래스 외부에서는 직접 접근할 수 없다. 프라이빗 필드는 **`#`** 접두어를 사용하여 정의된다.

```jsx
class Example {
  // 클래스 필드
  static staticField = 'I am a static field'; // 특징: 정적 필드
  instanceField = 'I am an instance field'; // 특징: 인스턴스 필드

  // 프라이빗 필드
  #privateField = 'I am a private field'; // 특징: 프라이빗 필드

  constructor() {
    // 생성자 내부에서 인스턴스 변수 정의
    this.anotherInstanceField = 'I am another instance field';
  }

  // 프라이빗 메서드
  #privateMethod() {
    console.log('I am a private method');
  }

  // 공개 메서드
  publicMethod() {
    console.log('I am a public method');
    
    // 특징: 프라이빗 필드 및 메서드 사용
    console.log(this.#privateField);
    this.#privateMethod();
  }
}

const instance = new Example();

// 특징: 정적 필드는 인스턴스에서 직접 접근 가능
console.log(instance.staticField);

// 특징: 인스턴스 필드는 인스턴스에서 직접 접근 가능
console.log(instance.instanceField);

// 에러 - 특징: 프라이빗 필드에 직접 접근 불가
console.log(instance.#privateField);
// 에러 - 특징: 프라이빗 메서드에 직접 접근 불가
instance.#privateMethod();

// 특징: 프라이빗 필드와 메서드를 간접적으로 접근
instance.publicMethod();
```

**클래스 상속**

- **`extends`** 키워드를 사용하여 부모 클래스 지정해 자식 클래스가 부모 클래스의 특성을 상속받아 사용할 수 있는 특징이 있다.
- 자식 클래스의 생성자에서 **`super()`** 를 사용해 부모 클래스의 생성자를 호출할 수 있다.

→ 코드의 재사용성을 높이고 유지보수를 쉽게해준다.

## 3. 불변성

**원시 데이터 타입의 불변성:**

- 원시 데이터 타입(숫자, 문자열, 불리언, null, undefined, Symbol)은 불변합니다. 이 값들은 변경 불가능하며, 변수에 새로운 값을 할당하면 이전 값이 변경되는 것이 아니라 새로운 메모리에 새로운 값이 할당됩니다.

**불변성을 유지하는 객체나 배열 생성:**

- 객체나 배열을 생성할 때, 불변성을 유지하는 방법으로 **`Object.freeze()`**, **`Object.seal()`**, **`Object.assign()`**, 혹은 불변성 라이브러리들을 사용할 수 있습니다.

| 구분 | 메서드 | 프로퍼티
추가 | 프로퍼티
삭제 | 프로퍼티
값 읽기 | 프로퍼티
값 쓰기 | 프로퍼티 어트
리뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Object.preventExtensions | ✕ | ◯ | ◯ | ◯ | ◯ |
| 객체 밀봉 | Object.seal | ✕ | ✕ | ◯ | ◯ | ✕ |
| 객체 동결 | Object.freeze | ✕ | ✕ | ◯ | ✕ | ✕ |

**불변성의 이점:**

- 예측 가능한 코드: 값이 변경되지 않으므로 코드 실행 결과를 예측하기 쉽다.
- 효율성: 변경이 없는 데이터는 캐싱이나 메모이제이션과 같은 최적화 기법에 활용될 수 있다.
- 병렬 처리: 불변 데이터는 여러 스레드나 워커 간에 안전하게 공유될 수 있다.

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

**자바스크립트의 타입**

| 데이터 타입 | 구분 | 설명 |
| --- | --- | --- |
| 숫자(number) | 원시 타입 | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 문자열(string) | 원시 타입 | 문자열 |
| 불리언(boolean) | 원시 타입 | 논리적 참(true)과 거짓(false) |
| undefined | 원시 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| null | 원시 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
| 심벌(symbol) | 원시 타입 | ES6에서 추가된 7번째 타입 |
| 객체(object) | 객체 타입 | 객체, 함수, 배열 등 |

데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유?

✔ 원시 타입의 값, 즉 **원시 값은 변경 불가능한 값immutable value**이다. 이에 비해 **객체(참조) 타입의 값, 즉 객체는 변경 가능한 값mutable value**이다.
✔ 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
✔ 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

| 특성 | 원시 타입 | 객체 타입 |
| --- | --- | --- |
| 변경 가능성 | 변경 불가능(immutable) | 변경 가능(mutable) |
| 저장 방식 | 값 자체가 변수에 직접 저장 | 참조 값이 변수에 저장 |
| 할당과 전달 | 값 복사 (값에 의한 전달) | 참조 값 복사 (참조에 의한 전달) |
