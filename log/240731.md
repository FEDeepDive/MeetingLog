## 보경

# DB의 종류

- RDBMS : 행과 열을 가지는 관계형 데이터베이스
- NoSQL : SQL을 사용하지 않는 데이터베이스

## 미림

## 정욱

## 데이터베이스의 종류

### 계층형 데이터베이스, 네트워크형 데이터베이스

개체 간 일대다 관계를 가지는 계층형 데이터베이스와 다대다 관계를 가지는 네트워크 데이터베이스는 과거에 주로 사용되던 모델들로, 계층형 데이터베이스는 하나의 부모가 다수의 자식을 가질 수 있지만 자식은 단 하나의 부모만을 가질 수 있는 **트리 구조**를 가지는데 반해 네트워크형 데이터베이스는 여러 부모와 자식을 가질 수 있는 **그래프 구조**를 가진다.

### 관계형 데이터베이스

집합론의 [관계](https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EC%88%98%ED%95%99))라는 개념에서 아이디어를 가져온 관계형 모델에 기초하는 데이터베이스.

주요 RDBMS: Oracle, MySQL, 마이크로소프트 SQL 서버, 마이크로소프트 Access, SQLite, MariaDB

<aside>
💡 최근 자주 사용되는 PostgreSQL은 엄밀히 말하자면 객체-관계형 DBMS로, 데이터를 객체로 저장할 수 있다는 특징을 가지고 있다!

</aside>

### NoSQL

[non | not-only | non-relational] 등 여러 용어의 약자로 해석되는 NoSQL은 기존 관계형 DBMS에서 트랜잭션이 안전하게 수행된다는 것을 보장하는 성질인 ACID를 완화하여, 높은 확장성이나 성능 등의 이점을 가지는 다른 유형의 DBMS를 말한다.

| 종류 | 예시 |
| --- | --- |
| 문서 | MongoDB, Google Firebase Firestore, Amazon DocumentDB 등 |
| 그래프 | Neo4j, Amazon Neptune 등 |
| 키-값 | Google Firebase Realtime Database, Amazon DynamoDB, Vercel KV 등 |
| 와이드 컬럼 | Apache Cassandra, ScyllaDB 등 |

## 인덱스

데이터베이스 테이블의 검색 성능을 높여주는 자료구조로, 속성 값과 튜플이 저장된 주소가 저장된다.  튜플 간 순서가 없는 테이블과 달리 미리 정렬되어 있어 인덱스를 통해 원하는 데이터 및 해당 데이터가 속한 특정 범위나 최대/최소 값 등을 찾는데 유리하다. 그러나 인덱스 저장에는 추가 공간이 필요하며, 정렬된 데이터이기 때문에 값을 추가/삭제할 때 리소스가 추가로 필요하다.

## 조인의 종류

### 조인(Join)?

하나의 데이터베이스 내 여러 테이블의 레코드를 조합하여 하나로 표현하는 방법이며, 사용하는 테이블 간에 공통으로 존재하는 값을 이용하여 조합한다. 데이터 무결성을 위해 정규화한 테이블을 조합하는 과정에는 자원이 들기 때문에 자주 조합되는 테이블은 반정규화(Denormalization)을 수행하기도 한다.

### 잘 알려진 조인 유형

| 유형 | 설명 |
| --- | --- |
| 교차(Cross) | 두 테이블의 각 행에 대한 곱집합을 반환한다. |
| 내부(Inner) | 두 테이블의 각 행에 대한 교집합을 반환한다.
- 하위 개념: 동등(Equi), 자연(Natural) 조인 |
| 외부(Outer) | 두 테이블에서 공통된 값을 가지지 않는 행도 함께 반환한다.
- Left: 왼쪽 테이블의 모든 행 및 오른쪽 테이블 중 왼쪽 테이블과 공통된 값을 가지는 행
- Right: 오른쪽 테이블의 모든 행 및 왼쪽 테이블 중 오른쪽 테이블과 공통된 값을 가지는 행
- Full: 두 테이블의 모든 행 |
| 자가(Self) | 한 테이블에서 자기 자신에 조인을 시킨다. |

## 조인의 ~~원리~~(알고리즘)

두 테이블 간의 조인을 수행하기 위해 주로 사용되는 알고리즘은 세 가지로 나뉜다.

| 종류 | 설명 |
| --- | --- |
| 중첩 루프(Nested Loop) | 두 개의 테이블에 대해 일반적인 이중 반복문을 생각할 수 있다. 테이블의 크기가 작을수록 성능이 좋아지며, 간단하기 때문에 모든 RDBMS에서 지원한다. |
| 정렬 병합(Sort-merge) | 두 개의 테이블을 각각 정렬한 후, 정렬된 데이터를 비교하여 조인을 수행한다. 이미 정렬되어 있거나 정렬 비용이 적은 경우 성능이 좋다. |
| 해시(Hash) | 두 개의 테이블 중 하나를 해시 테이블로 정하여, 조인될 테이블의 키 값을 해시 알고리즘으로 비교한 후 매치되는 결과값을 얻는다. 중첩 루프 방식이나 정렬 병합 방식을 쓰기엔 너무 크거나 정렬 비용이 높은 경우 주로 사용한다. |

## 영은

### 데이터베이스 종류

관계형 - MySQL이 대표적이고 ~~가장 많이씀~~

NoSQL - 대표적으로 MongoDB 

**MongoDB - 프론트엔드가 많이 사용하는이유**

- BSON으로 저장하기 때문에 JSON과 유사
    - 직렬화/역직렬화 JSON형식 그대로 저장하고 불러올 수 있어서 직관적이고 백과의 변환작업이 준다고 함.
- 스키마 없이 데이터를 삽입 가능
    - 다양한 도메인의 데이터베이스 기반으로 분석 로깅에 강점
    - 프론트엔드 개발자가 데이터를 저장할 때 스키마를 엄격하게 정의할 필요가 없음

### 인덱스

데이터를 빠르게 찾을 수 있는 장치

- 특정 조건에 맞는 데이터를 빠르게 찾을 수 있는 장점이 있음
- 트리구조로 되어있고, 대수확장성 때문에 효율적이라고 함
- 비용이 들기 때문에 적절한 인덱스를 선택하고 관리하는 것이 중요. 잘못된 인덱스는 오히려 성능을 저하시킬 수 있음
    - 중복, 불필요한 인덱스는 제거해야함
    - 요구사항에 적합하게 인덱스를 생성해야함
    - 복합 인덱스는 같음, 정렬, 다중값, 카디널리티 순

### 조인

두 개 이상의 테이블을 기준으로 **데이터**를 결합하는것

**종류**

- 내부 조인(inner join): 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인(left outer join): 왼쪽 테이블의 모든 행이 결과 테이블에 표기됨
- 오른쪽 조인(right outer join): 오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
- 합집합 조인(full outer join) 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

**원리 ⇒ 를 알아야 할까,,?**

<aside>
💡 프론트엔드 개발자로서 알아야 할것이 뭐가 있을까
프론트엔드 개발자가 직접 SQL 조인을 사용할 일은 거의 없음. 조인은 주로 데이터베이스에서 여러 테이블을 결합하여 필요한 데이터를 제공하는 역할을 하며, 이 작업은 일반적으로 백엔드에서 수행됨. 프론트엔드는 백엔드에서 조인을 통해 준비된 데이터를 API로 받아와 화면에 표시하는 역할을 함.

</aside>

⇒ 효과적인 데이터 요청을 위해 특정 화면에 필요한 데이터를 조인해서 한 번에 제공받도록 백엔드와 협업시 요청할 수 있음.
