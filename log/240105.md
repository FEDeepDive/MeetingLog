# 보경

## 7. sass, css module, css in js 차이점

### **1. CSS Pre-processor (전처리기)**

- 종류 : **`SCSS`**, **`SASS`**, **`Less`**, **`Stylus`**
- 특징 : 변수, 중첩 규칙, 함수, mixin 등의 기능을 제공, 브라우저에서 구동 가능한 CSS로 컴파일 됨

### 2. CSS-in-CSS

- 종류 : **`PostCSS`**, **`Stylelint`**
- 특징 : CSS를 모듈화하여 사용하는 방식으로, CSS 클래스 이름을 고유하게 만들어 스코프를 지정하여 스타일 충돌방지

### 3. CSS-in-JS

- 종류 : **`styled-components`**, **`Emotion`**
- 특징 : JavaScript 파일 안에서 스타일 정보를 포함한 객체 또는 함수를 작성. 컴포넌트에 이를 적용하여 런타임에서 스타일이 적용

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점

- `**<img src=’경로’>**`
    - 이미지를 HTML 태그로 표시하는 방식
    - 이미지 로딩 실패시 alt 속성으로 대체 텍스트 설정 가능
    - html 태그이기 때문에 검색엔진이 이미지를 읽어올 수 있다.
- **`{ background-image :  url(’경로’) }`**
    - 요소의 배경으로 이미지를 설정하는 방식
    - 이미지 위에 텍스트나 다른 요소를 겹쳐 표시할 수 있음
    - 디자인적인 요소로만 이미지를 활용하고 싶을 때
    - 콘텐츠와 관련이 없어 이미지를 불러오지 못해도 상관 없을 때

## 9. `visibility: hidden`과 `display: none`의 차이점

- **`visibility : hidden`**
    
    사용자 눈에 해당 요소를 보이지 않게 함.
    
    width와 height 공간을 차지함
    
- **`display : none`**
    
    렌더 트리에서 해당 요소를 사라지게 함.
    
    width와 height 공간을 차지하지 않음
    

## 10. 반응형 웹의 3요소

- **Fluid Grids**
    
    부모요소에 **`display : grid`** 를 적용해 화면의 크기에 따라 그리드의 크기와 열의 수를 조정하는 배치 방식
    
- **Flexible Images**
    
    **`max-width`**, **`width`**, **`min-width`** 등을 이용해 이미지의 크기와 비율을 유지하면서 화면의 크기에 맞게 조정 
    
- **Media Queries**
    
    디바이스의 특성에 따라 스타일을 다르게 적용할 수 있는 CSS 기능
    
    미디어 쿼리를 사용하여 화면의 크기, 해상도, 방향 등을 감지하고 적절한 스타일 적용 가능
    

# 미림

## 7. sass, css module, css in js 차이점

```
💡 세 가지 모두 CSS를 보완하여 스타일을 구성하기 위한 도구입니다.
1️⃣Sass는 CSS 안에서 특정 syntax를 지원합니다. 특히 변수, 함수같은 프로그래밍 개념을 CSS에 적용할 수 있습니다.
2️⃣CSS Module은 CSS를 모듈화하여 클래스명이 고유하지 않아도 된다는 특징을 가지고 있습니다.
3️⃣CSS-in-JS는 Javascript 코드에 CSS를 함께 작성하는 방식입니다. Javascript 변수를 스타일에 사용할 수 있고, 스타일을 코드와 함께 local scope로 관리할 수 있습니다.
```

### 개요

- 스타일 구성 방식: 1️⃣CSS, 2️⃣CSS-in-CSS, 3️⃣CSS-in-JS
- 2️⃣CSS-in-CSS: ☝️CSS preprocessor, ✌️CSS module

### CSS Preprocessor

- **개념**
    - 자신만의 구문(Syntax)를 가짐
- **장점**
    - CSS에서 프로그래밍 개념(변수, 함수, 상속 등)을 사용
    - ⇒ 공통 또는 반복되는 항목을 변수/함수로 대체 ⇒ 재사용성 ↑
    - ⇒ 개발 시간, 비용 절약
    - ⇒ 중첩, 상속과 같은 구조 ⇒ 유지보수 용이
- **단점**
    - 전처리기를 위한 도구 필요
    - 다시 컴파일하는 데 시간이 소요
- **종류**
    - Sass
    - Less
    - Stylus
- **참고**
    - [웹 컴포넌트 스타일링 관리 : CSS-in-JS vs CSS-in-CSS](https://www.samsungsds.com/kr/insights/web_component.html)

### CSS Module

- **개념**
    - CSS 모듈화
    - CSS 적용 범위를 local scope로 제한 & CSS 클래스명을 고유한 이름으로 자동 변환함
- **장점**
    - 클래스명 중복으로 인한 스타일의 전역 오염을 방지
        - 기존 CSS에서는 동일한 클래스명을 가지는 CSS 파일이 여러 개인 경우, 어떤 스타일이 적용될 지 예측할 수 없는데, 이를 해결함
    - ⇒ 클래스명을 모두 고유하게 만들 필요가 없음
    - 컴포넌트 단위 스타일 관리 ⇒ 스타일 관리, 유지보수 용이
    - 라이브러리 설치 필요 X
- **단점**
    - 많은 CSS 파일을 관리해야 함
    - 클래스를 동적으로 추가 시, 클래스명 자동 변환됨 ⇒ 코드 가독성 ↓
- **언제 쓰면 좋을까?**
    - CSS 클래스 네이밍하기 힘들 때
    - 레거시 프로젝트를 손봐야 할 때 (기존 CSS 클래스 이름과 중복돼도 OK)
- **참고**
    - [TCP React Styling CSS Module](https://www.tcpschool.com/react/react_styling_cssmodule)
    - [벨로퍼트와 함께하는 모던 리액트 CSS Module](https://react.vlpt.us/styling/02-css-module.html)

### CSS-in-JS

- **개념**
    - JS 코드에서 CSS를 작성하는 방식
- **장점**
    - JS 변수를 스타일에 사용 가능
    - 스타일 적용 범위가 local scope
    - 컴포넌트 코드와 스타일 코드를 한 곳에서 모아 볼 수 있음(Colocation)
    - ⇒ 스타일 관리, 구분, 유지보수 용이
    - ⇒ 데드 코드 검출이 쉬움
- **단점**
    - 런타임 오버헤드: CSS-in-JS 라이브러리를 일반 CSS로 직렬화해야 함
    - 번들 크기가 커짐: 클라이언트는 CSS-in-JS 라이브러리용 JS를 다운로드해야 함
- **종류**
    - Styled Components
    - JSS
    - Emotion
- **참고**
    - [(번역) 우리가 CSS-in-JS와 헤어지는 이유](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EC%9A%B0%EB%A6%AC%EA%B0%80-css-in-js%EC%99%80-%ED%97%A4%EC%96%B4%EC%A7%80%EB%8A%94-%EC%9D%B4%EC%9C%A0-a2e726d6ace6)

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점

```
💡 HTML img 태그로 만든 이미지 요소는 대체 텍스트를 가지며 검색엔진에 노출됩니다. 반면, CSS background-image로 만든 이미지는 의미론적이지 않으며 검색 엔진에 노출되지 않습니다. 따라서 이미지가 의미를 갖는 경우 HTML img 태그를 사용하고, 이미지가 꾸밈 요소로만 사용되는 경우 CSS background-image를 사용하는 것이 적절합니다.
```

|  | HTML img 태그 | CSS background-image |
| --- | --- | --- |
| 시맨틱 | 이미지가 의미를 가지는 경우(대체 텍스트가 필요한 경우) | 이미지가 의미 없이 꾸밈 요소로만 사용되는 경우 (ex. 글머리 기호) |
| SEO | 이미지가 검색엔진에 노출되어야 하는 경우 | 이미지가 검색엔진에 노출되지 않아도 되는 경우 |
| 인쇄 | 인쇄 시 이미지가 기본적으로 출력되어야 하는 경우 | 인쇄 시 이미지가 출력되지 않아도 되는 경우 (”배경 그래픽” 옵션 체크 시 이미지가 출력되긴 함) |
- 참고
    - [이미지 마크업, <img> vs background-image 딱 정해드립니다.](https://inseq.co.kr/ko/bbs/i-24/show.do?seq=19)

## 9. `visibility: hidden`과 `display: none`의 차이점

```
💡 두 방식 모두 요소를 숨기는 데 사용되지만, `display: none`을 사용하면 요소가 렌더링 되지 않아, 영역을 차지하지도 않습니다. 반면 `visibility: hidden`을 사용하면 요소가 렌더링되며 영역을 차지합니다.
```

|  | visibility: hidden | display: none |
| --- | --- | --- |
| 가시성 | 요소가 보이지 않게 함 | 요소가 보이지 않게 함 |
| 요소 렌더링 | 렌더링 O | 렌더링 X (요소가 \*Render Tree에 반영되지 않음) |
| 영역 | 차지 O | 차지 X |
- \*Render Tree: 시각적 레이아웃에 기여하는 요소만 포함하는 구조
- 🚨 `display: none`을 사용해도 요소는 여전히 DOM에 존재함 ⇒ Javascript로 상호작용 가능
- ❓ 함께 보면 좋은 글: [조건부 렌더링 vs display none](https://ssangq.netlify.app/posts/conditional-rendering-vs-diplay-none)

## 10. 반응형 웹의 3요소

```
💡 반응형 웹의 3요소는 "유연한 그리드 시스템", "유동적인 미디어", "미디어 쿼리"입니다. 세 가지 요소 모두, 화면 크기에 따라 화면의 레이아웃이나 콘텐츠 크기가 변경되게 하여, 반응형 웹 디자인의 필수 요소라고 할 수 있습니다.
```

- **유연한 그리드 시스템(Flexible Grid System)**
    - 🚨 CSS grid를 말하는 게 X
    - 화면 크기에 따라 레이아웃이 알아서 동적으로 조정되어야 함
    - 구현 방법
        - 고정 단위(ex. px) 대신 상대 단위(ex. %) 사용
        - `display: grid`, `display: flex`사용
- **유동적인 미디어(Fluid Images and Media)**
    - 화면 크기에 따라 미디어(이미지, 동영상 등) 크기가 조절되어야 함
    - 구현 방법
        - `max-width`, `min-width`, `width` 사용
        - 크기 조정 시 상대 단위 사용
        - `<img>`의 `srcset` 속성 사용
        - 미디어 쿼리 사용
- **미디어 쿼리(Media Queries)**
    - 화면 크기, 장치 유형, 해상도 등에 따라 적절한 스타일을 제공해야 함

# 정욱

## 7. sass, css module, css in js 차이점

Vanilla CSS는 다음과 같은 문제점이 있다:

1. 모든 스타일이 단일 이름공간에 선언되기 때문에, 모든 스타일의 이름이 중복되지 않아야 한다.
2. CSS 파일의 로드 순서에 따라 적용되는 스타일의 우선 순위가 달라지기 때문에 스타일 간의 의존성을 관리하기 어렵다.

이러한 문제점을 해결하기 위해 아래의 접근법들이 생겨났다.

### CSS 전처리기

CSS 스타일을 구조적으로 작성할 수 있게, 기본 CSS에 존재하지 않는 여러 문법을 통하여 CSS를 생성하는 프로그램이다. SASS는 CSS 전처리기들 중 가장 오래된 역사를 가지고 있으며, 변수/중첩문/믹스인/함수 등을 사용하여 스타일을 작성할 수 있게 해준다.

**그 외 전처리기**

- `Less`
- `Stylus`

### CSS 모듈

파일 내에 작성된 클래스명과 애니메이션 이름들이 기본적으로 지역 공간에 선언된다. 서로 다른 모듈에 존재하는 클래스들의 이름이 중복될 수 있어 의존성 관리가 쉬워지며, 따라서 재사용성과 모듈성이 높아진다.

### CSS in JS

스타일을 CSS 파일에 작성하지 않고 JS 코드 내에서 작성한다. 스타일이 문서 레벨이 아닌 컴포넌트 레벨로 추상화되며, JS와 CSS 코드가 변수와 함수를 공유할 수 있어 유연성이 높아진다.

**주요 라이브러리**

- `styled-component`
- `Emotion`
- `Vanilla Extract`
- `Panda CSS`
- `StyleX`

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점

### `<img src="example.png">`

**로고나 프로필 사진 등 의미를 가지고 있거나, 삽화같이 내용과 관련 있는 이미지에 사용한다.**

1. 이미지를 불러오지 못했을 때, alt 속성으로 지정해준 대체 텍스트를 제공할 수 있다.
2. 페이지를 인쇄할 때 기본적으로 포함된다.
3. 검색 엔진이 이미지임을 인식하여 검색 결과에 노출할 수 있다.

### `{ background-image: url("example.png") }`

**순수하게 디자인을 위해서 활용하고 싶은 이미지에 사용한다.**

1. 여러 개의 작은 이미지를 사용해야 하는 경우, CSS Sprite 기법을 활용할 때 사용하기 좋다.
2. 페이지를 인쇄할 때 포함되지 않는다.
3. 검색 엔진이 이미지로 인식하지 않아 검색 결과에 노출되지 않는다.

## 9. `visibility: hidden`과 `display: none`의 차이점

### 외형적 차이

`visibility: hidden`을 적용할 경우, 화면의 레이아웃 변화 없이 단순히 해당 요소가 보이지 않게 된다. 다른 요소들이 빈 공간을 채우기 위해 움직이지 않고 제자리에 위치한다.

`display: none`을 적용할 경우, 해당 요소가 아예 존재하지 않는 것처럼 취급되며, 레이아웃의 변화가 생긴다. 다른 요소들이 빈 공간을 채우며 위치를 바꾼다.

### 기능적 차이

`visibility: hidden`을 적용할 경우, 레이아웃의 변화가 없기 때문에 Reflow 없이 Repaint만이 발생한다.

`display: none`을 적용하는 경우, 레이아웃의 변화가 생기기 때문에 브라우저가 렌더 트리를 다시 생성하게 된다. 또한 기존에 화면에 보이던 요소에 `display: none`을 적용하게 될 경우, 레이아웃 변화가 생겨 Reflow가 발생할 가능성이 있다.

## 10. 반응형 웹의 3요소

2010년 Ethan Marcotte의 글 [‘Responsive Web Design’](https://alistapart.com/article/responsive-web-design/)이 인기를 얻게 되며, ‘반응형 웹’이라는 용어가 인기를 얻게 되었다. 해당 글에서 이야기하는 반응형 웹의 3요소는 다음과 같다:

### Fluid grid

서로 다른 기기의 화면 크기에 비례하여 조정되는 레이아웃 구조를 뜻한다. 고정된 픽셀 값보다 `%` 등의 상대 단위를 사용하여, 화면 크기가 달라지더라도 각 요소의 크기 비율이 유지되도록 한다.

### Flexible images

서로 다른 기기의 화면 크기와 해상도에 따라 이미지의 크기를 조정하는 것을 뜻한다. 이미지 크기를 컨테이너의 100%로 지정하여, 이미지의 화면 비율을 유지하고 왜곡을 방지함과 동시에 사용 가능한 공간 크기에 비례하여 이미지 크기를 조정할 수 있다.

### Media queries

웹사이트를 보기 위해 사용되는 기기 화면의 특성에 따라 다른 스타일과 레이아웃 규칙을 적용하는 것을 뜻한다. Media query를 사용하여 화면 사이즈, 해상도, 화면 방향(orientation)과 그 외 장치 환경을 특정하여 CSS 스타일을 적용할 수 있다.

# 영은

## 7. sass, css module, css in js 차이점

**Sass**
CSS 의 단점을 보완하기 위해 만든 CSS 전처리기

- CSS내에 반복되는 내용을 줄이고 효과적으로 스타일시트를 유지 보수 할 수 있다.
- CSS 파일 그 자체를 SCSS로 확장자만 바꾸어주어도 정상적으로 작동
- 변수의 사용, 조건문과 반복문, Import, Nesting, Mixin, Extend/Inheritance 등의 기능을 제공 한다.
- 다만 SASS 자체는 개발자용 언어이기 때문에 웹브라우저가 읽을 수 없음
    
    ⇒ 컴파일러를 거쳐서 CSS로 변환한 후 HTML에 연결해야 한다.
    
- SASS에는 Sass와 SCSS가 있다. (작성방식(문법)이 약간 다름)
    
    →Sass -들여쓰기 , SCSS- 대괄호와 세미콜론 사용
    
    |  | SCSS | SASS | CSS |
    | --- | --- | --- | --- |
    | 중괄호 {} | 필요 | 불필요(들여쓰기) | 필요 |
    | 세미콜론 ; | 필요 | 불필요 | 필요 |
    | : 뒤의 공백 | 불필요 | 필요 | 불필요 |
    | Mixin | @mixin | = | 없음 |
    | Include | @include | + | 없음 |
    | 확장자 | .scss | .sass | .css |

**CSS module**
CSS를 사용할 때 클래스 이름을 고유한 값으로 자동으로 만들어서 컴포넌트 스타일 클래스이름이 중첩되는 현상을 방지해 주는 기술이다.

- CSS Module을 이용하면 클래스명이 충돌하는 단점을 극복할 수 있다.
- CSS Module은 컴포넌트 단위로 스타일을 적용할 때 유용하다.
- import를 할 때 앞에 이름을 지정하고, 클래스에 적용시킬 때는 메서드를 호출하는 것 처럼 CSS module 클래스명을 호출하면 된다.
- 클래스 이름들은 주로 React 컴포넌트에서 JavaScript 코드에서 참조된다.

**CSS in JS**
단어 그대로 JavaScript코드에서 CSS를 작성하는 방식

- 스타일을 컴포넌트에 캡슐화하여 전역 스타일 충돌을 방지
- 동적 스타일링을 쉽게 구현
- React와 같은 컴포넌트 기반 라이브러리에서 유용

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점

이미지를 마크업 하는 두가지 방법이다. 용도에 맞게 잘 사용하는게 좋을 것 같다.

<**img>태그를 사용해서 마크업 ⇒ 전경 처리**

- 특징 :
    - **`<img>`** 태그를 사용하여 **이미지를 문서에 콘텐츠로 포함**시킨다.
    - 스크린 리더 및 검색 엔진에 대체 텍스트를 제공한다.( `alt` 속성 사용)
    - `**src`** 속성을 통해 브라우저는 이미지를 다운로드하고 페이지에 표시할 수 있다.
    - 이미지 외에도 텍스트나 다른 HTML 요소를 포함할 수 있다.
- 전경처리가 더 효과적인 상황
    - 이미지의 크기가 레이아웃에 영향을 미칠 때⇒반응형으로 이미지를 써야 할 때
    - 이미지에 구체적인 정보가 담겨있을 때
    - 사용자가 등록하는 데이터 이미지일 때
    - 인쇄 시 이미지까지 출력되어야 할 때
    - 검색엔진에 이미지까지 노출이 필요할 때, 이미지검색 SEO효과

**요소의 background로 이미지를 넣는법 ⇒배경처리**

- 특징 :
    - 주로 시각적 디자인과 스타일링에 중점
    - 스크린 리더에게 이미지 정보를 전달하는 데는 한계가 있다.
    - CSS속성으로 크기와 위치를 제어해야 한다.
    - [CSS sprite 기법](https://www.w3schools.com/css/css_image_sprites.asp)을 통해 이미지를 하나로 병합함으로써 파일 호출 횟수를 줄일 수 있습니다.
    ⇒ [메모리와 네트워크 사용량을 절약하는 효과](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS)를 가져와 사이트 성능 개선에 도움을 줌
- 배경처리가 더 효과적인 상황
    - **꾸밈(디자인) 요소로만 사용할 때**
    - **성능 향상을 위해, IR 기법 & Sprite 기법**
    - **개발 생산성과 유지보수 효율 향상을 위해, 아이콘 시스템**
    - **인쇄 시 이미지는 출력되지 않기를 원할 때**

## 9. `visibility: hidden`과 `display: none`의 차이점

`visibility: hidden`과 `display: none`은 둘 다 요소를 화면에서 숨기는 CSS 속성

- `visibility: hidden`
    - 요소를 화면에서 숨기지만, 레이아웃에서 차지하는 공간은 유지됨
        
        ⇒ 시각적으로는 보이지 않지만, 투명하게 공간을 차지
        
- `display: none`
    - 요소를 화면에서 숨기면서, 레이아웃에서도 해당 요소의 공간을 차지안함.
        
        ⇒  화면에서 완전히 사라지며, 다른 요소들에 대한 레이아웃 계산에서 제외됨
        

```markup
따라서 두 속성을 사용할 때, 숨긴 요소가 레이아웃에 영향을 주지 않아야 할 경우
**display: none**을 사용하는 것이 더 적합하고, 공간은 유지하면서 시각적으로만 숨기고 싶을 때는
**visibility: hidden**을 사용하는것이 좋다.
```

| 특성 | visibility: hidden | display: none |
| --- | --- | --- |
| 화면에서의 시각성 | 화면에서 보이지 않음 | 화면에서 완전히 사라짐 |
| 레이아웃 공간 유지 여부 | 공간을 계속 차지함 | 공간을 차지하지 않음 |
| 인터랙션 가능 여부 | 인터랙션 가능 | 인터랙션 불가능 |
| 주로 사용되는 상황 | 요소를 시각적으로 숨기되, 레이아웃에 공간을 유지해야 할 때 | 요소를 완전히 숨기고, 레이아웃에서 공간이 요 없을 때 |

## 10. 반응형 웹의 3요소

반응형 : 다양한 디바이스와 화면 크기에 대응하여 웹 페이지를 최적화하는 디자인 접근 방식

**그리드 레이아웃 (Flexible Grid Layout)**

- CSS 그리드 레이아웃이나 Flexbox를 활용하여 유연하게 배치한다.
- 상대적인 단위(%, em, rem)를 사용하여 레이아웃을 정의한다.

**유동적인 이미지와 미디어 (Flexible Images and Media)**

- 이미지와 미디어 요소도 다양한 화면 크기에 적응하여 화면에 최적화된 크기로 표시
- CSS의 **`max-width: 100%`**나 **`img`** 태그의 **`width: 100%`** 등을 사용하여 이미지가 부모 요소에 맞춰 유연하게 크기 조절될 수 있도록 함.

**미디어 쿼리 (Media Queries) - @media**

- 디바이스의 특성에 따라 스타일이나 레이아웃을 다르게 적용하기 위함
- 특정 스타일을 적용함으로써 반응형 디자인을 구현
- CSS의 미디어 쿼리를 사용하여 특정 조건(화면 크기, 해상도 등)에 맞춰 스타일 시트를 로드

```css
@media (조건) {
  /* 조건을 만족할 때 적용될 스타일 */
}
```
