## 보경

## 6. `Symbol`에 대해 설명해주세요.

ES6에서 추가된 7번째 타입으로 다른값과 중복되지 않는 **변경 불가능한 유일무이한 원시타입의 값**이다.
심벌 값은 충돌 위험이 없는 오브젝트의 **유일한 프로퍼티 키**를 만들수 있다는 장점이 있다.

심벌 값은 문자열이나 숫자 값으로 암묵적으로 변환되지 않으며, 내부 확인할 수 없으며, for … in 문이나 Object.keys 등으로 내부 값을 찾을 수 없다. 

따라서 이름에 의미를 두는 상수 값에 사용하거나 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 은닉하는데에 사용한다.

## 7. `==` 과 `===` 의 차이가 무엇인가요?

- **`== (동등 비교)`** : 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
- **`=== (일치 비교)`** : 좌항과 우항의 피연산자의 타입과 값을 **엄격하게 비교**한다. 두 피연산자의 타입도 같고 값도 같은 경우에만 true를 반환한다.
- **`NaN`**은 자신과 일치하지 않는 유일한 값(ex. **NaN** === **NaN** // false). 따라서 숫자가 **NaN**인지 조사하려면 빌트인 함수 Number.isNaN를 사용한다.

## 8. `for … of` / `for … in` 문

- **`for … of`**  : 이터러블 순환
    
    ```jsx
    for (변수 선언문 of 이터러블) { ... } 
    ```
    
- **`for … in`** : 객체 순환
    
    ```jsx
    **for (변수 선언문 of 객체) { ... }** 
    ```
    

## 9. `reduce` 사용법

```jsx
// Array.prototype.reduce(callback, initialVal)
// callback = (acc, cur, idx, arr) => {}
```

**`reduc**e()` 메서드는 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출한다. 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 **하나의 결과값을 만들어 반환**한다. 이때 원본 배열은 변경되지 않는다.

이 때 매개변수로 전달받은 콜백함수를 **리듀서 함수(**`reducer()`**)**라고 한다. 리듀서는 4개의 인수를 받는다.

- **`acc (누산기)`** : 콜백 함수의 반환 값
- **`cur (현재 값)`** : 처리할 현재 요소
- **`idx (현재 인덱스)`** : 현재 요소(**`cur`**)의 인덱스 ****
- **`src (원본 배열**)` ****: **`reduce()`** 를 호출 한 배열 ****

## 10. `splice`, `slice` , `split` 차이점

- **`Array.prototype.splice(start, deleteCount, )`
배열 기존요소를 삭제하거나 새 요소를 추가하여** 원본 배열의 내용을 변경한다.
    - **`start`** : 배열의 변경을 시작할 인덱스. 음수로 지정한 경우 배열의 끝에서부터 요소를 센다.
    - **`deleteCount(option)`** : 배열에서 제거할 요소의 수
    - **`item1, item2(option)`** : 배열에 추가할 요소
- **`Array.prototype.slice(start, end)`**
어떤 배열의 start부터 end까지에 대한 얕은 복사본을 **새로운 배열 객체**로 반환한다.
    - **`start(option)`** : 추출 시작점으로 빈 값일경우 0
    - **`end(option)`** : 추출 끝점으로 빈 값일 경우 배열의 끝까지 slice
- `**String.prototype.split(separator)**`
    
    구분자를 이용하여 여러개의 문자열로 나눈다.
    
    - **`separator(option)`** : 끊어야 할 부분을 나타내는 문자열

## 미림

## 6. `Symbol`에 대해 설명해주세요.

- **개념**
    - ES6에서 추가된 7번째 원시형 타입
    - 유일성이 보장됨
    - “심볼 이름”(또는 “심볼 설명”)을 가짐
        - 두 심볼이 서로 동일한 심볼 설명을 가져도 심볼값은 서로 다름
        - ⇒ 심볼 이름은 진짜 이름표 역할만 함
- **목적**
    - 숨겨진 프로퍼티, 유니크한 식별자를 만들기 위해 사용됨
- **특징**
    - `for..in` 반복문에서 배제됨 (non-Symbol이어야 순회함)
- **참고**
    - [심볼형](https://ko.javascript.info/symbol)

## 7. `==` 과 `===` 의 차이가 무엇인가요?

```
💡 엄격한 동등 연산자(`===`)는 피연산자의 타입이 서로 다른 경우 `false`를 반환합니다.
하지만 느슨한 동등 연산자(`==`)는 피연산자의 타입이 서로 다른 경우 타입 변환을 시도한 후 값을 비교합니다.
따라서 정확한 값 비교를 원한다면 엄격한 동등 연산자(`===`)를 사용하는 것이 좋습니다.

```

|  | 느슨한 동등 연산자(==) | 엄격한 동등 연산자(===, 일치 연산자) |
| --- | --- | --- |
| 비교 값 | 값 | 값 & 타입 |
| 연산 과정 | 타입이 다른 경우 타입 변환 후 비교 | 동등 연산자와 동일 but 타입이 다른 경우 바로 false 반환 |

**💡자세한 내용은 [MDN 동등 비교 및 동일성](https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using) 참고**

## 8. `for … of` / `for … in` 문

### `for...in`

- **순회 대상**
    - 모든 객체
    - 객체의 모든 \*열거가능(enumerable)하고 non-Symbol인 속성에 대해 반복
        - \*열거 속성: 내부의 열거 가능 플래그 `[[Enumerable]]`가 `true`인 속성
- **특징**
    - 객체의 key에만 접근 가능
    - 임의의 순서로 반복(=순서 보장 X)
    - 객체의 프로토타입까지 순회 가능
- **등장 시기**: ES1

### `for...of`

- **순회 대상**
    - 이터러블 객체(`[Symbol.iterator]` 속성을 갖고 있는 객체)
- **특징**
    - 객체의 key, value에 접근 가능
    - `await` 사용 가능 (`for-await-of`)
- **등장 시기**: ES6

### `Array.prototype.forEach`

- **순회 대상**: Array, Map
- **장점**
    - 배열의 요소와 인덱스에 접근 가능
    - 콜백 함수를 따로 짤 수 있음 & 화살표 함수 사용 가능
- **단점**
    - 루프 내부에서 `await` 사용이 불가
    - 반복 흐름을 제어하지 못함 (`break`, `continue` 불가능)
- **등장 시기**: ES5

### 참고

- [for...of와 for..in의 차이](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#difference_between_for...of_and_for...in)
- [for vs for-in vs forEach vs for-of 무엇으로 자바스크립트 리스트를 돌아야 하나](https://yceffort.kr/2021/06/best-solution-for-looping-over-array)

## 9. `reduce` 사용법

```
💡 `reduce`는 배열의 각 요소에 대해 함수를 실행하고, 그 결과를 누산기에 누적하여 최종 누적 결과를 얻을 때 사용됩니다.

```

- **개념**
    - 배열을 순회하며 각 요소에 대한 함수를 실행 ⇒ 함수 반환값을 누적하여 하나의 결과값을 반환함
- **구문**
    
    ```jsx
    // 물음표(?)로 끝나는 변수는 Optional
    
    const 누적된결과값 = array.reduce(
      (누산기, 현재요소, 현재인덱스?, _호출한배열?) => {
        return 누산기에_누적할_값;
      },
      누산기초기값?,
    );
    
    ```
    
    - `array.reduce(콜백, 누산기초기값?)`
        - 콜백 매개변수
            - `누산기`: 콜백의 반환 값을 누적함
            - `현재요소`
            - `현재인덱스?`
            - `호출한배열?`: `reduce()`를 호출한 배열
        - `누산기초기값?`: 콜백 최초 호출 시 누산기 초기값으로 할당할 값. 없으면 배열의 첫 번째 요소 사용. (빈 배열 + 초기값도 없으면 오류 발생)
    - 반환값: 누산기의 최종 값
- **예시**
    
    ```jsx
    // 배열의 모든 원소 더하기
    const numbers = [1, 2, 3, 4];
    const sum = numbers.reduce((sum, num) => sum + num, 0);
    console.log(sum); // 10
    
    ```
    

## 10. `splice`, `slice`, `split` 차이

```
💡 `splice`와 `slice`는 배열의 특정 구간을 추출한다는 점에서 비슷합니다.
하지만 `splice`는 원본 배열을 변형하고, 배열 삭제와 추가 모두 가능한 반면,
`slice`는 원본을 변형하지 않고, 특정 부분을 획득하는 데 목적이 있다는 점에서 다릅니다.
`split`은 문자열을 구분자로 끊어 배열로 만들 때 사용됩니다.

```

|  | splice | slice | split |
| --- | --- | --- | --- |
| 목적 | 배열에 요소 삽입/삭제/교체를 통한 배열 내용 변경 | 배열/문자열의 특정 구간 획득 | 문자열을 특정 구분자로 나눔 |
| 원본변형 | O | X | X |
| 반환값 | 제거한 구간 배열 | 추출한 구간 배열 | 구분자로 나눈 결과 배열 |
| 매개변수(\*:옵셔널) | 시작 인덱스, *삭제할 요소 개수, *배열에 추가할 요소들 | *시작 인덱스, *종료 인덱스(구간에 미포함) | *구분자, *끊어진 문자열의 최대 개수 |
| 매개변수 특징 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 |  |

## 정욱

## 6. `Symbol`에 대해 설명해주세요.

ES6에서 새롭게 추가된 원시 타입으로, 그 값이 고유함이 보장된다. ES5 이전까지의 객체 프로퍼티 키는 문자열만을 사용했으며, 따라서 이미 존재하는 프로퍼티를 덮어쓰게 될 가능성이 있었다. ES6에서 `Symbol`이 추가되며, 객체의 프로퍼티 키를 고유하게 설정하여 충돌을 방지할 수 있게 되었다. 이렇게 생성된 프로퍼티 키는 일반적인 문자열 키와 달리 열거 불가능하다. 즉, `for ... in` 문법으로 접근할 수 없고, `Object.getOwnPropertyName()`으로 반환할 수 없으며, `JSON.stringify()`를 통해 객체를 JSON 문자열로 만들 때 무시된다.

JavaScript 엔진 내에 미리 생성되어 상수로 존재하는 내장 심볼들도 존재한다. 대표적으로 `Symbol.iterator`가 있는데, JavaScript 엔진은 `Symbol.iterator`를 키로 가지는 메소드가 정의된 객체를 iterable한 객체로 인식한다. 이러한 객체는 `for … of` 문법을 이용해 반복할 수 있다.

## 7. `==` 과 `===` 의 차이가 무엇인가요?

|  | == | === |
| --- | --- | --- |
| 명칭 | loose equality(느슨한 동등) | strict equality(엄격한 동등) |
| null vs. undefined | true | false |
| number vs. string | number == Number(string) | false |
| BigInt vs. string | StringToBigInt(x) == BigInt | false |
| boolean vs. number | Number(boolean) == number | false |
| … | … | … |

### 기억할 점

`===`를 사용할 경우, 두 값의 타입이 같지 않다면 항상 false이다. `==`를 사용할 경우, 두 값의 타입을 일치시키는 방향으로 어느 한 값을 변환한 다음 느슨한 동등 비교를 진행한다.

## 8. `for … of` / `for … in` 문

### `for ... in`

객체의 프로퍼티 키 중 문자열로 지정된 모든 열거 가능한 속성에 대해 반복문을 사용하는 문법이다. 해당 객체의 속성을 확인하기 위해 사용할 수 있다.

### `for ... of`

ES6에서 새롭게 등장한 문법으로, `Symbol.iterator`를 키로 가지는 모든 ‘컬렉션(Array, String, Map 등)’에 대해, 모든 원소를 한 번씩 추출하여 변수에 담아 반복문을 수행하는 식으로 동작한다.

## 9. `reduce` 사용법

`reduce(callbackFn, initialValue)`는 배열의 요소를 하나의 값으로 ‘줄이는’ 작업을 수행한다.

### `callbackFn(accumulator, currentValue, currentIndex, array)`

배열의 각 요소에 대해 실행할 함수이며, 콜백 함수의 이전 반환값을 `accumulator` 변수를 통해 접근 가능하다. `initialValue` 값이 존재할 경우 `accumulator`의 첫 값은 `initialValue` 값이고, 존재하지 않을 경우 배열의 첫 요소가 `accumulator` 값이 된다. 배열의 모든 요소에 대해 `callbackFn`이 실행된 후, 그 결과가 하나의 값으로 ‘줄어들어’ 반환된다.

## 10. `splice`, `slice`, `split` 차이점

### `slice(begin, end)`

`slice()`는 문자열/배열에서 특정 범위만큼 복사한 값들을 담는 **새로운** 문자열/배열을 만들기 위해 사용한다. 새로운 변수를 만들기 때문에, 해당 문자열/배열을 조작한다고 하더라도 원본 문자열/배열에 영향을 미치지 않는다.

### `splice(start, deleteCount, ...items)`

`splice()`는 배열의 기존 요소를 삭제/교체하거나 새 요소를 추가하는 등 **배열의 내용을 변경**한다.

### `split(seperator)`

`split()`은 지정한 구분자를 이용하여 대상 문자열을 여러 개의 문자열로 나눈다.

## 영은

## 6. `Symbol`에 대해 설명해주세요.

- ES6에서 도입된 7번째 데이터 타입으로 **변경 불가능한 원시 타입의 값**이다.
- 프로퍼티 키로 사용될 수 있다.
- for in문에서 무시된다.

> 👉 심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.
> 

> 👉 심벌을 사용하면 표준 빌트인 객체도 확장 하기에 안전하다. 미래에 생길 빌트인 객체와 이름 충돌할 일이 없어짐.
> 

## 7. `==` 과 `===` 의 차이가 무엇인가요?

- `==` (동등비교 연산자, Equality Operator):
    - **`==` 연산자는 값을 비교할 때 타입 변환을 수행**합니다. 따라서 **타입이 다른 두 값의 비교를 할 때 타입 변환이 일어납니다.**
    - 타입 변환 규칙에 따라 값이 같은지 비교합니다.
        - **숫자와 문자열 비교:**
            
            `console.log(5 == "5"); // true` **문 자열 "5"를 숫자 5로 변환**하여 비교
            
        - **불리언과 숫자 비교:** `console.log(true == 1); // true` **불리언 true를 숫자 1로 변환**하여 비교
        - **null과 undefined 비교:** `console.log(null == undefined);// true` null과 undefined는 서로 동등하다고 간주
        - **객체와 문자열 비교:** `console.log({} == "[object Object]"); // true` 객체를 문자열로 변환하여 비교
        - **문자열과 불리언 비교:** `console.log("true" == true); // false`, 문자열 "true"를 불리언 true로 변환하여 비교 ⇒ ??? 어렵⇒ 해결
- `===` (일치비교 연산자, Strict Equality Operator):
    - `===` 연산자는 **값과 타입을 모두 비교**합니다. 타입 변환을 수행하지 않고 엄격하게 비교합니다.
    - 비교하는 값의 타입과 값이 정확히 일치하는지 확인합니다.
    
    ⇒ 특별한 경우가 아니라면 의도치 않은 실수를 막기 위해 `===` 를 사용하는것이 좋음
    

## 8. `for … of` / `for … in` 문

### `for … in` 문

객체의 모든 프로퍼티를 순회하며 열거하려면 for...in 문을 사용한다.

```
for (변수선언문 in 객체) {...}
```

- for...in 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의 ⇒ but,대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시
- 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거 ⇒ 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.
- `for...in`은 인덱스의 순서가 중요한 `Array`에서 반복을 위해 사용할 수 없다. ⇒ 순서가 중요한 배열의 반복시에는 숫자 인덱스를 사용할 수 있는 for, forEach, for of를 사용하는 것을 권장한다.

**장점**

- 쉽게 객체의 속성을 확인(콘솔이나 다른 방법으로 출력)할 수 있기 때문에 실질적으로 디버깅을 위해 사용될 수 있다.
- 키-값 쌍이 선호되는 데이터의 경우(속성이 "key"의 역할을 함) 특정 값을 가진 키가 있는지 확인하려는 경우에 for...in이 효과적이다.

### `for … of` 문

`for...of` 구문은 **컬렉션** 전용이다. 모든 객체보다는, `[Symbol.iterator]` 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복한다.

```
for (변수선언문 of 이터러블) { ... }
```

- for...of문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for...of 문의 변수에 할당한다.
- 이터레이터 리절트객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단한다.

| 특성 | for...of | for...in |
| --- | --- | --- |
| 사용 목적 | 이터러블 객체 순회 (배열, 문자열 등) | 객체의 프로퍼티 순회 |
| 구문 | for (const value of iterable) { /* code */ } | for (const key in object) { /* code */ } |
| 반복 대상 | 이터러블 객체 (Array, Set, Map, 문자열 등) | 객체 (프로토타입 체인의 상속된 프로퍼티도 포함) |
| 순회 대상 | 값 (요소, 문자 등) | 키 (프로퍼티 이름) |
| 상속된 프로퍼티 | 미포함 | 포함 |
| 순서 보장 여부 | 보장됨 | 보장되지 않음 |
| 반복 변수 값 | 값 복사 (immutable) | 키 값 |

## 9. `reduce` 사용법

배열을 하나의 값으로 축소하는 고차 함수. 주로 배열의 모든 요소를 하나의 값으로 합치거나 변환할 때 사용.

```
	array.reduce((누적값, 현재값, 현재인덱스, 호출한배열) => {
    // 처리 로직
  }, 초기값);

```

빈 요소를 제외하고 배열 내에 존재하는 각 요소에 대해 `callback` 함수를 한 번씩 실행 요소를 돌면서 현재값과 누적값을 계산해 누적값을 반환한다.

초기 값이 없다면 첫번째 요소를 누적값에 넣고, 두번째 값을 현재 값에 넣어서 진행한다. → 이는 **예상치 못한 실수를 발생하게 할 수 있으니 초기값은 항상 넣어 두는 것이 안전**하다.

reduce는 가독성이 상대적으로 안좋기 때문에 map,filter로 충분히 해결 할 수 있는 문제들은 reduce사용을 하지 않는것이 좋다고 생각한다.

## 10. `splice`, `slice`,`split`차이

### **`splice()`:**

- 배열 메서드로 배열의 요소를 추가 또는 제거,교체 할 수 있다.
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 제거할 요소의 개수다.
- 나머지 매개변수는 배열에 추가될 요소다.
- 원본배열을 수정한다.
- 제거한 배열을 반환한다.

### **`slice()`:**

- 배열 메서드로 배열의 일부분을 추출하여 새로운 배열을 반환
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 끝 인덱스(끝 인덱스는 제외)이다.
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.

### **`split()`:**

- 문자열 메서드로 문자열을 지정된 구분자를 기준으로 나누어 배열로 반환합니다.
- 첫 번째 매개변수로는 구분할 문자열을 넣고 두번째 매개변수 반환할 배열의 최대 길이이다.(선택사항)
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.
- 문자열을 배열로 만들 때 많이 사용. ex. `str.split(””)`

| 메서드 | 사용 대상 | 동작 | 반환값 | 원본 변경 여부 |
| --- | --- | --- | --- | --- |
| splice | 배열 | 요소를 추가 또는 제거하고, 제거된 요소를 반환 | 제거된 요소들의 배열 | 원본 배열 변경 |
| slice | 배열 | 일부분을 추출하여 새로운 배열을 반환 | 추출된 배열 | 원본 배열 변경 안됨 |
| split | 문자열 | 구분자를 기준으로 나누어 배열로 반환 | 구분된 문자열로 이루어진 배열 | 원본 문자열 변경 안됨 |
