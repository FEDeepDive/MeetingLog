## 보경

### 프로세스

**프로그램**

- 저장장치에 저장되어 있는 정적인 상태로 파일시스템의 실행파일

**프로세스**

- 메모리 상에서 실행중인 프로그램.
- 프로그램이 운영체제로부터 PCB를 얻어 자신만의 고유공간과 자원을 할당받아 프로세스가 됨
- CPU 스케줄링의 대상이다.

### 프로세스의 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7437b847-1662-4bb9-8689-547b8e7e7d15/Untitled.png)

- **생성 상태** : 프로그램을 메모리에 가져와 실행 준비가 완료된 상태. 즉 프로세스가 생성된 상태
- **대기 상태(준비)** : 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태.
- **실행 상태** : CPU 소유권과 메모리를 할당받아 사용하는 상태
- **중단 상태(대기)** : 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
- **완료 상태** : 메모리와 CPU 소유권을 모두 놓고 가는 상태. 정상 종료인 exit와 비정상 종료인 abort를 포함

### 프로세스 메모리구조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10f8b8a0-47b2-4370-b122-478fada0515e/Untitled.png)

- 프로세스의 메모리 구조는 런타임 단계에서 메모리를 할당받는 정적영역과 컴파일단계에서 메모리를 할당받는 동적영역으로 이루어진다.
- **코드영역 :** 프로그램의 본문이 기술된 영역
- **데이터영역 :** 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳
- **힙영역** : 동적으로 할당되는 변수를 담는 영역
- **스택영역  :** 함수가 호출될 때마다 함수 호출과 관련된 정보들이 저장되는 영역으로 변수의 스코프나 함수가 호출된 메모리 주소 등을 저장함.

### 프로세스 제어 블록 PCB(**Process Control Block)**

- 프로세스에 대한 메타데이터를 저장한 데이터
- 모든 프로세스는 고유의 프로세스 제어 블록을 가지며, 프로세스 제어 블록은 프로세스 생성 시 OS 커널에 의해 만들어지고, 프로세스가 실행을 완료하면 폐기됨.
- 프로세스의 중요한 정보를 담고 있기 때문에 커널모드에서만 접근 가능하며 일반 사용자가 접근하지 못하도록 커널스택의 가장 앞부분에서 관리된다.
- 아래의 정보들로 이루어져 있다
    - **프로세스 ID(Process ID)** : 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
    - **프로세스 스케줄링 상태(Process state)** : '준비', '일시중단' 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
    - **프로세스 우선순위(Process Priority)** : 프로세스의 실행 순서를 결정하는 우선순위
    - **프로세스 권한** : 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
    - **프로그램 카운터(Program Counter)** : 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
    - **CPU 레지스터(CPU Register)** : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - **CPU 스케줄링 정보** : CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - **계정 정보(Accounting Information)** : 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    - **I/O 상태 정보** : 프로세스에 할당된 I/O 디바이스 목록

### 컨텍스트 스위칭(Context Switching)

- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업으로 **두 프로세스의 PCB를 교환**하는 작업
- 하나의 프로세스에 할당된 시간이 끝나거나, 인터럽트에 의해 발생
- 컨텍스트 스위칭은 스레드에서도 발생한다.

### 멀티프로세싱

- **멀티 프로세스**
    - 여러개의 프로세스가 각자 하나의 작업을 맡아 처리해 하나 이상의 일을 병렬로 처리할 수 있는 것
    - ex) 웹브라우저의 멀티프로세스 : 브라우저프로세스, 렌더러프로세스, 플러그인프로세스, GPU프로세스

### **프로세스 간 통신(Inter-Process Communication, IPC)**

- 프로세스들 사이에 서로 동시에 데이터를 주고받는 방식, 즉 프로세스간의 통신
- **메세지를 전달하는 방법**
    
    `message passing` : 커널을 통해 메세지 전달 ****(EX. 파이프, 메세지큐, 소켓)
    
- **주소공간을 공유하는 방법**
    
    `shared memory` : 서로 다른 프로세스간에도 일부 주소공간을 공유하게 하는 shared memory 매커니즘이 있음 
    

### **스레드**

- 프로세스 내부의 실행 단위.  하나의 프로세스는 여러 스레드를 가질 수 있다.
- 스레드는 프로세스와 달리 다른 스레드와 **공간과 자원(코드, 데이터, 힙)을 공유**하며 사용한다.
    - 모든 스레드가 자원을 공유하기 때문에 하나의 스레드에 문제가 생기면 프로세스에 영향을 미침
    - 임계영역에 동시에 접근하는 경우 다른스레드가 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오기도 함
- 멀티스레딩 : 단일 프로세스의 컨텍스트 내에서 여러 스레드를 동시에 실행하는 기법

### 공유자원

- 여러 프로세스/스레드가 함께 접근할 수 있는 변수, 메모리, 파일, 데이터 등의 자원
- 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 경쟁 조건이라고 한다.

### 임계영역

- 2개 이상의 프로세스/스레드가 공유 자원에 접근해서 실행 결과가 달라지게 될 수 있는 코드영역
- 임계영역 해결 충족조건
    - **상호 배제 :** 한 프로세스가 임계영역에 들어가면 다른 프로세스는 임계영역에 들어갈 수 없음
    - **한정 대기 :** 특정 프로세스가 영원히 임계영역에 들어가지 못하면 안된다.
    - **융통성 :** 한 프로세스가 다른 프로세스의 일을 방해해서는 안됨
- 임계영역 해결 방법
    - 임계영역 해결 방법에는 크게 뮤택스, 세마포어, 모니터 세가지가 있으며 이 방법들에 토대가 되는 매커니즘은 lock이다.
    - **뮤택스(Mutex)**
        - 프로세스나 스레드가 공유자원을 lock을 통해 잠금 설정하고 사용한 후에는 unlock을 통해 잠금 해제하는 객체
        - 이 객체를 소유해야만 공유자원에 접근가능하다.
    - **세마포어(Semaphores)**
        - 일반화된 뮤텍스로 간단한 정수값과 P, V 두가지 함수로 공유자원에 대한 접근을 처리하는 방법
        - 0과 1의 값만 가질 수 있는 바이너리 세마포어와 여러개의 값을 가질 수 있는 카운팅 세마포어로 나뉘어진다.
    - **모니터(Monitor)**
        - 둘 이상의 스레드나 프로세스가 공유자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 것
        - 세마포어 알고리즘을 자동으로 관리하는 기법

### 교착상태(Deadlock)

- 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태
- **교착 상태의 원인(필요조건)**
    - **상호 배제 :** 한 프로세스가 자원을 독점하고 있으며 다른 프로세스는 접근이 불가능함
    - **점유와 대기** : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
    - **원형 대기** : 점유와 대기를 하는 프로세스 간에 사이클이 형성되어야함
    - **비선점 :** 한 프로세스가 사용 중인 자원은 다른 프로세스가 강제로 뺏어올 수 없는 비선점 자원이어야 함
- **교착상태의 해결방법**
    - **교착 상태 예방 :** 자원을 할당할 때 교착상태를 유발하는 4가지 필요조건이 성립되지 않도록 함
    - **교착 상태 회피 :** 교착상태 가능성이 없을 때만 자원을 할당하여 교착 상태를 회피함
        - **은행원 알고리즘 :** 프로세스 시작 시 해당 프로세스가 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정/불안정 상태를 나누어 시스템이 안정 상태를 유지하도록 자원을 할당하는 알고리즘
    - **교착 상태 검출 :** 타임아웃이나 자원할당 그래프를 사용하여 교착상태를 검출함
    - **교착 상태 회복 :** 교착 상태가 검출되면 교착 상태를 유발한 프로세스를 강제로 종료

## 미림

## 정욱

## 프로세스와 스레드

### 프로세스(Process)

프로그램이 특정 작업을 수행하기 위한 명령어의 집합이라면, 프로세스는 컴퓨터에서 실행 중인 프로그램을 의미한다. 현대 운영체제는 컴퓨터 시스템의 물리적 CPU 수보다 많은 프로세스를 **‘동시’**에 처리할 수 있도록,  프로세스 각각이 온전히 사용할 수 있는 CPU를 하나씩 가지는 것처럼 **가상화**한다. 이는 각 작업 또는 사용자들에게 CPU를 한 번에 일정 시간만큼만 제공하여 공유하는 **시분할(Time-sharing)** 기법을 통해 달성 가능하다.

<aside>
💡 동시(concurrent): 하나의 프로그램을 이루는 서로 다른 부분이 순서를 지키지 않고 실행되어도 결과에 영향을 미치지 않는 것을 의미한다.

</aside>

각 프로세스는 운영체제로부터 격리된 메모리 영역을 할당받으며 프로세스 간 자원을 공유해야 할 때는 여러 가지 **프로세스 간 통신(Inter-Process Communication)** 기법을 사용해야 한다. 프로세스의 메모리 영역은 다음과 같은 세부 영역으로 나뉜다.

| 프로세스 메모리 영역 구조 | 설명 |
| --- | --- |
| Text | 실행할 기계어 코드가 저장되는 영역 |
| Data | 정적 변수가 저장되는 영역이며, 읽기 전용으로 초기화된 정적 변수가 저장되는 .rodata, 읽고 쓸 수 있는 초기화된 정적 변수가 저장되는 .data, 읽고 쓸 수 있는 초기화되지 않은 정적 변수가 저장되는 .bss의 세 가지로 구분된다. |
| Stack | 지역 변수, 함수 매개변수, 반환 주소값 등이 저장되는 영역이며, Heap과 반대 방향으로 증가한다. |
| Heap | 사용자에 의해 동적 메모리 할당이 일어나는 영역이며, Stack과 반대 방향으로 증가한다. |

운영체제는 각 프로세스를 제어하기 위한 정보를 저장하기 위해 **프로세스 제어 블록(Process Control Block, PCB)**이라는 자료구조를 저장하며, PCB의 모음을 **프로세스 테이블**이라고 부른다. 운영체제의 종류에 따라 PCB에 포함되는 항목이 다를 수 있지만, 일반적으로 다음과 같은 정보가 포함되어 있다.

---

- 프로세스 식별자 및 현재 상태
- CPU의 동작을 제어하거나 사용자 접근이 가능한 레지스터
- 프로세스 주소 공간 등에 대한 메모리 관리 정보
- 프로세스에 할당된 입출력 장치나 열린 파일 목록 등에 대한 입출력 상태 정보

<aside>
❓ 운영체제와 PCB의 관계는 React와 [Fiber](https://github.com/facebook/react/blob/83d538e0d04aac2a32d335e6b3963273729a9fe6/packages/react-reconciler/src/ReactInternalTypes.js#L83)의 관계와 같다고 생각할 수 있지 않을까?

</aside>

---

컴퓨터 시스템에서 프로세스는 (**생성) → [준비 → 대기 → 실행] → (종료)**의 5단계 생명주기를 가진다. 프로세스가 생성되어 준비 상태로 전이한 후, 종료 상태로 전이하기 전까지 준비/대기/실행 세 가지 상태 사이에서 전이되며 작업을 수행한다.

| 상태명 | 설명 |
| --- | --- |
| 생성(New) | PCB가 생성된 후, CPU를 제외한 다른 자원이 준비되어 OS가 ‘준비’ 상태로 전이할 수 있도록 승인(admit)하기 전 상태 |
| 준비(Ready) | OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다리는 상태 |
| 대기(Block) | 입출력 동작 완료 등의 이벤트 발생을 기다리는 상태 |
| 실행(Running) | CPU를 할당받아 명령어가 실행되는 상태 |
| 종료(Terminated) | 작업 수행이 완료되어 자원을 반납한 상태 |

### 인터럽트(Interrupt)

CPU에서 작업을 처리하다가 입출력 발생이나 CPU 사용 시간 만료 등의 예외 상황이 발생할 때 하드웨어 또는 소프트웨어에서 보내는 신호를 뜻한다. 인터럽트가 발생하면 CPU는 프로그램의 실행을 중단하고 인터럽트를 알맞게 처리할 수 있는 **인터럽트 서비스 루틴(Interrupt Service Routine, ISR 또는 간단히 인터럽트 핸들러)**로 제어 흐름을 넘겨준다.

### 문맥 교환(Context Switch)

CPU는 한 번에 하나의 작업 실행 단위만 처리할 수 있으며, 다른 작업을 실행하기 위해서는 CPU가 현재 처리 중인 작업 실행 단위의 정보, 즉 문맥(또는 컨텍스트)를 바꿔야 한다. 이러한 과정을 문맥 교환이라고 하며, 작업 실행 단위의 CPU 사용 시간이 만료되었을 때 인터럽트가 발생하며 이루어진다.

### 스레드(Thread)

프로세스 내에서 실제로 작업이 실행될 때 그 흐름의 단위를 뜻한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며, 코드/데이터/힙 영역을 공유하지만 각각 별도의 스택 영역을 할당받는다. 같은 프로세스 내에 존재하는 스레드는 메모리 영역을 공유하기 때문에 문맥 교환에 필요한 작업이 적어 프로세스 문맥 교환보다 비용이 적고 효율적이다. 

<aside>
💡 가상 메모리 기법으로 인해 각 프로세스가 서로 다른 주소 공간을 가지기 때문에, 프로세스 문맥 교환이 발생하면 다음에 실행될 프로세스의 주소 공간을 사용하도록 MMU를 조정하고, MMU 연산 결과를 임시 저장하는 **변환 색인 버퍼(Translation Lookaside Buffer, TLB)**를 비워야 하기 때문에 스레드 문맥 교환에 비해 비용이 크다.

</aside>

스레드는 하드웨어 스레드와 소프트웨어 스레드로 나누어지며, 또한 소프트웨어 스레드는 커널 레벨 스레드와 유저 레벨 스레드로 나뉜다.

| 스레드 대분류 | 설명 |
| --- | --- |
| 하드웨어 스레드 | CPU의 물리적인 작업 단위. 동시 멀티스레딩(SMT) 기술이 등장한 후, 하나의 코어 당 하나 이상의 스레드를 할당하여, OS 입장에서 여러 개의 코어처럼 보이도록 가상화할 수 있게 되었다. |
| 소프트웨어 스레드 | 운영체제나 프로그래밍 언어, 런타임 환경 수준에서 제공되는 논리적인 작업 단위. |

| 소프트웨어 스레드 분류 | 설명 |
| --- | --- |
| 커널 레벨 스레드 | 커널이 스레드 생성 및 관리의 주체인 스레드. 새롭게 만들거나 없앨 때 시스템 콜이 필요해서 오버헤드가 크지만 커널의 관리 지원을 많이 받을 수 있다. |
| 유저 레벨 스레드(또는 그린 스레드) | 유저 레벨 소프트웨어에 의해 관리되며 커널은 그 존재를 모르는 스레드. 스케줄링이나 동기화에 시스템 콜이 필요하지 않기 때문에 오버헤드가 적다. |

| 커널 레벨 스레드와 유저 레벨 스레드의 관계 | 설명 |
| --- | --- |
| 일대일 모델 | 하나의 유저 레벨 스레드에서 시스템 콜을 해도 다른 유저 레벨 스레드가 블록되지 않는 장점이 있지만, 유저 레벨 스레드의 수만큼 커널 레벨 스레드가 생성되므로 성능 저하가 일어날 수 있다. |
| 다대일 모델 | N개의 유저 레벨 스레드에 1개의 커널 레벨 스레드가 매핑되며, 한 번에 하나의 유저 레벨 스레드만 커널에 접근할 수 있다. |
| 다대다 모델 | N개의 유저 레벨 스레드에 M개의 커널 레벨 스레드가 매핑되며, 일대일과 다대일 모델의 장점을 포함하지만 구현이 어렵다. |

### 경쟁 상태**(Race Condition)**와 임계 영역**(Critical Section)**

여러 개의 작업 단위가 공유 자원에 동시 접근할 때, 접근 순서에 따라 결과 값이 달라질 수 있다. 이러한 현상을 **경쟁 상태**라고 부르며, 둘 이상의 작업 단위가 동시에 접근하면 안되는 공유 자원에 접근하는 프로그램 코드의 일부분을 **임계 영역**이라고 한다.

임계 영역에서 경쟁 상태가 되는 것을 방지하는 **상호 배제(Mutual Exclusion)**를 보장받기 위해서는 다음 조건을 충족해야 한다.

- 둘 이상의 작업 단위가 동시에 임계 영역에 접근하면 안 된다.
- 임계 영역에 접근하려는 작업 단위의 수행이 무한히 이루어지면 안 된다.
- 임계 영역에 접근한 작업 단위가 없는 경우, 다른 작업 단위가 즉시 접근할 수 있다.
- 작업 단위의 수행 속도에 대한 가정이 이루어지면 안 된다.

### 교착 상태(Deadlock)

상호 배제 기법 때문에 둘 이상의 작업 단위가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 **교착 상태**라고 부른다. 교착 상태는 다음의 4가지 필요충분조건에 의해 발생하며, 4가지 중 하나라도 제거할 경우 교착 상태를 막을 수 있다.

- 상호 배제: 하나의 공유 자원에 하나의 작업 단위만 접근할 수 있다.
    - 여러 작업 단위가 동시에 하나의 공유 자원을 사용할 수 있게 하면 교착 상태는 해소된다.
- 점유와 대기: 작업 단위가 최소 하나의 자원을 점유하고 있는 상태에서, 다른 작업 단위가 사용 중인 자원을 추가로 점유하기 위해 대기한다.
    - 작업 단위가 실행되기 전에 필요한 모든 자원을 미리 할당하거나, 자원을 점유하지 않았을 때만 자원을 요구할 수 있게 하면 교착 상태는 해소된다.
- 비선점: 다른 작업 단위에 할당된 자원을 빼앗아올 수 없다.
    - 이미 할당된 자원을 선점하지 않도록 하여, 점유하고 있는 자원이 현재 사용 중이지 않다면 반납한 후 대기하게 하면 교착 상태는 해소된다.
- 환형 대기: 작업 단위가 자신의 자원을 점유하면서 앞/뒤에 있는 작업 단위의 자원을 요구한다.
    - 모든 자원에 대해 순서를 부여하고, 특정 방향으로만 자원을 요구하게 하면 교착 상태는 해소된다.

## 영은

### 프로세스 (Process)

컴퓨터에서 실행되고 있는 프로그램의 인스턴스로, 운영 체제에서 자원 할당의 기본 단위

각각 독립된 메모리 공간(코드, 데이터, 힙, 스택)을 갖고 있음

### 스레드 (Thread)

프로세스 내 작업의 흐름

스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위

같은 프로세스 내의 다른 스레드와 메모리 공간을 **공유**합니다(코드, 데이터, 힙) but **독립**된 스택

<aside>
💻 공유와 독립의 의미

- **공유**: 코드, 데이터, 힙 영역은 프로세스 내의 모든 스레드가 공유하므로, 이들 영역에 있는 변수나 데이터는 스레드 간에 공통으로 접근할 수 있음. 예를 들어, 하나의 스레드가 힙 영역에 할당한 메모리를 다른 스레드가 접근하거나 수정이 가능함.
- **독립**: 각 스레드는 자신만의 스택을 가지고 있으며, 이 스택은 다른 스레드와 독립적으로 운영. 따라서 한 스레드의 함수 호출이나 지역 변수는 다른 스레드에 영향을 주지 않음. 예를 들어, 스레드 A의 지역 변수는 스레드 B에서 직접 접근하거나 변경할 수 없음.
</aside>

⇒ 이렇게 함으로써, 여러 스레드가 동시에 실행되면서도 서로 독립적인 함수 실행 환경을 유지할 수 있음(널티쓰레드의 장점)

### PCB (Process Control Block)

운영체제가 각 프로세스에 대해 관리하는 중요한 데이터 구조, 프로세스의 상태와 관련된 모든 정보를 담고 있음

### 컨텍스트 스위칭

CPU가 한 프로세스의 실행을 멈추고, 다른 프로세스의 실행을 시작하는 과정

⇒ 현재 실행 중인 프로세스의 상태를 PCB에 저장하고, 다음 실행할 프로세스의 PCB에서 상태를 읽어와 CPU에 로드함

### IPC (Inter-Process Communication)

서로 다른 프로세스 간에 데이터를 주고받는 방법으로, 파이프, 메시지 큐, 공유 메모리, 소켓 등이 사용됨
