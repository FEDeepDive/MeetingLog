## 보경

## 1. 프로토콜

**프로토콜**

서로 다른 시스템이나 기기간 데이터 교환을 원활하게 하기 위한 표준화 된 통신 규약

**[HTTP/HTTPS(Hyper Text Transfer Protocol SSL)](https://velog.io/@reggias/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91HTTP-HTTPS)**

- HTTP : 웹에서 데이터를 주고 받기 위한 프로토콜,
- HTTPS : HTTP에 SSL 프로토콜을 추가해 데이터를 암호화 하는 프로토콜

**[HTTP 버전별 특징](https://zu-techlog.tistory.com/113)**

- HTTP 1.0 : 하나의 연결당 하나의 요청 처리
- HTTP 1.1 : keep-alive 옵션을 추가해 하나의 연결당 여러번의 송수신 가능
- HTTP 2 : 여러 리소스를 한번에 요청 가능
- HTTP 3 : UDP 기반의 프로토콜로 사용

**HTTP Status Code**

클라이언트가 보낸 특정 HTTP 요청에 대한 서버의 응답 코드 상태 코드에 따라 요청의 성공이나 실패 여부 판단

- **1xx(정보제공) :** 클라이언트의 요청을 받았으며 프로세스를 계속 진행함
- **2xx(성공) :** 클라이언트가 요청한 동작을 수신/이해/승낙하여 성공적으로 처리함
    - 200 : 요청을 성공적으로 처리함
    - 201 : 요청이 처리되어서 새로운 리소스 생성
    - 202 : 요청은 접수했지만, 처리가 완료되지 않음
- **3xx(리다이렉션) :** 클라이언트는 요청 완료를 위해 추가 작업을 해야함
    - 301 : 지정할 리소스가 새로운 URI로 이동함
    - 303 : 다른 위치로 요청
    - 307 : 임시 리다이렉션 필요
- **4xx(클라이언트 에러) :** 클라이언트 요청에 오류가 있음
    - 400 : 요청 구문 에러
    - 401 : 지정한 리소스에 대한 액세스 권한 X
    - 403 : 지정한 리소스에 대한 엑세스 금지
    - 404 : 지정한 리소스를 찾을 수 없음
- **5xx(서버 에러) :** 클라이언트의 요청은 유효하나 서버가 처리 실패함
    - 500 : 서버 내부 에러 발생
    - 501 : 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않음
    - 502 : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.

**HTTP 헤더 / HTTTP 페이로드**

- 헤더(Header) : HTTP 요청이나 응답에 대한 메타 데이터
- 페이로드(Payload) : 실제 데이터

## 2. RESTful API

**API(Application Programming Interface )**

응용 프로그램에서 데이터를 주고 받기 위한 인터페이스로 어떠한 사이트에서 데이터를 공유할 경우 어떤 방식으로 정보를 요청해야 되는지, 어떠한 형태로 데이터를 제공받게 되는지에 대한 규격

**REST(Representational State Transfer)**

자원을 이름으로 구분하여 자원의 상태(정보)를 주고 받는 것

**REST의 구성요소**

- **자원(RESOURCE)** : HTTP URI
- **행위(Verb)** : HTTP METHOD
    - **GET** : 조회
    - **POST** : 리소스 생성
    - **PUT** : 리소스 전체 교체
    - **PATCH** : 리소스의 일부 수정
    - **DELETE** : 리소스 삭제
- **표현(Representations)** : HTTP Message Pay Load

**REST API(Representational State Transfer)**

- REST 아키텍쳐를 따르는 API

**RESTful API 설계 가이드**

1. URI 는 정보의 자원을 표현해야 한다.
2. 자원에 대한 행위는 HTTP Method로 표현한다.

## 미림

## 1. 프로토콜

### 1. HTTP/HTTPS

- **개념**
    - **H**yper**T**ext **T**ransfer **P**rotocol (하이퍼텍스트 전송 규약)
    - **client-server 간 통신을 위한 요청/응답 프로토콜**
    - HTTPS: **데이터 전송 전에 패킷을 암호화 →** 제3자가 가로챌 수 없도록 보안 강화(**S**ecure)
- **특징**
    - **무상태(stateless)**: server가 client의 이전 상태를 보존하지 않음
    - 비연결성(connectionless): client가 server에 요청하고 응답을 받으면 TCP/IP 연결 끊기
    ⇒ HTTP/1.1부터는 TCP/IP 연결을 재사용해 **지속 연결(persistent connection)**
- **비교**
    
    
    |  | HTTP | HTTPS |
    | --- | --- | --- |
    | 의미 | Hypertext Transfer Protocol | Hypertext Transfer Protocol Secure |
    | 기본 프로토콜 | - HTTP/1 및 HTTP/2: TCP/IP
    - HTTP/3: QUIC 프로토콜 | HTTP/2 + SSL/TLS |
    | 포트 | 기본 포트 80 | 기본 포트 443 |
    | 보안 | x | 퍼블릭 키 암호화에 SSL 인증서 사용 |
    | 이점 | 인터넷을 통한 통신 지원 | 신뢰성, SEO 개선 |
- **SSL/TLS 인증서란?**
    - SSL/TLS 프로토콜을 사용해 **암호화된 네트워크 연결을 설정할 수 있게** 함
    ⇒ 즉 연결이 설정된 client-server만 전송한 데이터를 볼 수 있음
    - **네트워크 암호화 설정 과정**
        - 유저가 SSL/TLS 보안 웹 사이트(=https)에 접속
        - 브라우저가 서버의 진위 여부 확인을 위해 식별 가능한 정보를 요청
        - 서버가 암호화에 필요한 `퍼블릭 키`를 SSL/TLS 인증서에 담아 회신
        - 브라우저는 SSL/TLS 인증서가 유효한지 확인 (ex. 도메인 일치 여부, 만료 여부 등)
        - 유효하면 `퍼블릭 키`를 사용해 `비밀 세션 키`를 포함해 데이터를 암호화하여 전송
        - 서버는 브라우저가 보낸 데이터를 `프라이빗 키`로 복호화하고 세션 키를 꺼냄
        - 서버는 `세션 키`를 사용해 암호화하고 브라우저에 승인 메시지를 보냄
        - ⇒ 브라우저-서버가 동일한 `세션 키`를 사용하여 안전하게 통신
        
        <aside>
        💡 퍼블릭 키로 암호화한 파일은 프라이빗 키로만 복호화할 수 있고, 그 반대의 경우도 마찬가지이다. 해당 파일을 복호화할 수 있다는 것은, 수신자/발신자를 신뢰할 수 있음을 나타낸다.
        
        </aside>
        
        <aside>
        💡 세션 키는 초기 SSL/TLS 인증이 완료된 후, 브라우저와 서버 간 암호화된 통신을 유지한다. 세션 키는 암호화와 복호화에 동일한 키를 사용하는 대칭 암호화를 위한 키이다.
        비대칭 암호화(ex. 퍼블릭 키 암호화-프라이빗 키 복호화)는 계산 비용이 엄청나기 때문에, 인증이 완료된 이후부터는 계산이 덜 필요한 대칭 암호화로 전환하는 것이다.
        
        </aside>
        

### 2. HTTP/1.1,  HTTP/2, HTTP/3

|  | 특징 |
| --- | --- |
| HTTP/1.1 | 최초 표준 버전으로, 가장 기초적인 전송 형식이 확립됨 |
| HTTP/2 | - 전송 데이터 형식 변경: 텍스트 → 바이너리
- 다중화 프로토콜 ⇒ 동일한 연결을 통해 병렬 요청 수행이 가능
- 헤더 압축 ⇒ 오버헤드 제거 (기존: 데이터만 압축 가능)
- 서버 푸시 매커니즘: 서버가 클라이언트 캐시에 데이터 저장 가능 |
| HTTP/3 | - 전송 계층 변경: TCP/IP → QUIC
- 업그레이드된 다중화 프로토콜: QUIC은 UDP를 통해 여러 스트림을 독립적으로 실행 ⇒ 오류 발생 시 해당 스트림만 차단 (HTTP/2의 다중화 프로토콜은 모든 스트림이 차단됨) |

<aside>
💡 HTTP/2의 등장 배경

- 웹의 발전으로 주고받는 스크립트 코드 양이 증가
- ⇒ HTTP/1.1 연결에 복잡성과 오버헤드가 많이 발생
- ⇒ 2010년, Google이 SPDY라는 프로토콜 구현
    - HTTP/1.x 메시지를 프레임으로 나눠 스트림에 끼워넣고 여러 스트림을 하나로 묶음
    - ⇒ 중복 데이터 전송 문제 해결 & 데이터/헤더 분리로 인한 헤더 압축 가능
- ⇒ HTTP/2의 기반이 되어, 2015년 HTTP/2가 공식 표준화 됨
</aside>

### 3. HTTP 메시지 프로토콜

- **요청 메시지**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/b76d77a0-8077-4257-8ba6-23c3023788a8/Untitled.png)
    
    - 시작줄: `HTTP METHOD` + `요청 타겟` + `HTTP 버전`
    - 헤더: `Request 헤더` + `General 헤더` + `Representation 헤더`(본문이 있을 때만 존재)
    - 본문(optional)
- **응답 메시지**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/27ec025d-d82b-46a8-8d63-a2b4b104ca59/Untitled.png)
    
    - 상태줄: `HTTP 버전` + `Status Code` + `Status Text`(순전히 사람을 위한 정보 제공 목적)
    - 헤더: `General 헤더` + `Response 헤더` + `Representation 헤더`(본문이 있을 때만 존재)
    - 본문(optional)

<aside>
💡 페이로드(payload)는 전송되는 데이터 자체를 의미한다(=body에 담기는 데이터).
메시지에서 페이로드를 제외한 나머지 부분은 “프로토콜 오버헤드”에 해당한다.

</aside>

### 4. HTTP METHOD

- 종류 및 역할
    
    
    |  | 역할 | 멱등성(부수효과가 없는가?) |
    | --- | --- | --- |
    | GET | 리소스 주세요(Read) | O |
    | POST | 리소스 받으세요 | X |
    | PUT | 리소스 없으면 만들고, 있으면 바꿔주세요(Update) | O |
    | PATCH | 리소스 여기만 바꿔주세요(Update) | X |
    | DELETE | 리소스 삭제해주세요 | O |
    |  |  |  |
    | CONNECT | 양방향 연결 요청 (ex. HTTPS 접속 시) | X |
    | HEAD | 응답 바디가 없는 GET (⇒검색/확인/검사용) | O |
    | TRACE | 메시지 loop-back test (⇒디버깅/검사용) | O |
    | OPTIONS | 서버가 지원하는 통신 옵션 정보 얻기(⇒예비요청용)
    (ex. HTTP 메소드, CORS 정책 정보 등 주세요) | O |
- `POST`의 역할
    - 리소스 조회(Read)
    - 리소스 제출 ⇒ 데이터 생성(Create) 여부는 서버 로직에 따르는 것 뿐임
        - ex. 게시글 등록, 파일 업로드, 로그인, form 제출, 상태 변경(ex. 결제완료)
- `GET` 조회 vs. `POST` 조회
    
    
    |  | GET 조회 | POST 조회 |
    | --- | --- | --- |
    | 캐싱 여부 | 가능 ⇒ 속도 빠름 | 조건부 가능 |
    | 보안 이슈 | 쿼리스트링이 URL에 노출됨
    (ex. http://www.ex.com/search?&query=테스트...) | 요청 데이터 노출 X |
    | 복잡한 쿼리 처리 | 쿼리 파라미터가 복잡한 경우, URL 길이 제한에 걸릴 수 있음 | 쿼리 파라미터가 복잡해도 바디에 담아 전달하므로 문제 없음 |
    | 잠재적 문제 | 사용자가 URL 쿼리를 수정해 요청을 생성하기 쉬움 | 그럴 일이 없음 |

### 5. HTTP Status Code를 종류별로 나누어 설명해주세요.

|  | 의미 | 해석 |
| --- | --- | --- |
| 100 | 정보 | 요청 받았고 계속 진행할게. |
| 200 | 성공 | 요청 성공적으로 받았고 처리했어. |
| 300 | 리다이렉션 | 요청 완료를 위해 추가 작업이 필요해. |
| 400 | 클라이언트 에러 | 요청이 이상하거나 처리 불가능해. |
| 500 | 서버 에러 | 요청은 유효한데, 서버가 수행하지 못했어. |

### 참고

- [AWS HTTP와 HTTPS 비교](https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/)
- [MDN HTTP 메시지](https://developer.mozilla.org/ko/docs/Web/HTTP/Messages)
- [🌐 HTTP 메서드 종류 & 요청 흐름 💯 총정리](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#html_form_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%A0%84%EC%86%A1_%EA%B3%BC%EC%A0%95)
- [Wikipedia HTTP 상태 코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

## 2. REST API

- **개념**
    - 모범적인 HTTP 프로토콜 사용을 위한 아키텍처
    - **RE**presentational **S**tate **T**ransfer
- **6가지 제한 조건**
    
    
    |  | 의미 |
    | --- | --- |
    | 인터페이스 일관성 | 일관적인 형식(인터페이스)으로 정보를 전송해야 함 (\*아래 참고) |
    | 무상태(Stateless) | 각 요청 간 클라이언트의 콘텍스트가 서버에 저장되어선 안 됨 |
    | 캐싱 가능성 | 리소스를 캐싱할 수 있어야 함 |
    | 계층 구조 아키텍처 | 클라이언트는 서버에 직접 연결되었는지 중간 서버를 통해 연결되었는지 몰라야 함 |
    | client-server 구조 | 클라이언트/서버는 서로 독립적으로 분리되어야 함 |
    | 온디맨드 코드 | 필요한 경우, 응답에 실행 코드를 포함할 수 있어야 함 |
- **인터페이스 일관성을 위한 규칙*
    - 요청 시 URI로 리소스 식별이 가능해야 함
    - 리소스 표현 시 리소스를 처리하는 데 필요한 정보를 충분히 포함해야 함(=자기서술적)
    - HTTP Method로 리소스에 대한 행위(조작)을 나타내야 함

## 정욱

## 영은

## **1. 프로토콜 - HTTP**

## **2. RESTful API**

REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고,

RESTAPI는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.

**REST API 설계 원칙**

- **URI는 리소스를 표현 ⇒ 동사보다는 명사**

```jsx
# bad
GET /getTodos/1
GET /todos/show/1
# good
GET /todos/1
```

- **리소스에 대한 행위는 HTTP 요청 메서드로 표현**

주로 5가지 요청 메서드(GET, POST, PUT, PATCH, DELETE 등)을 사용한다.

| 메서드 | 설명 | 특징 |
| --- | --- | --- |
| GET | 데이터를 요청합니다. | 요청 본문 없음. 쿼리 문자열을 통해 데이터를 전달할 수 있음. |
| POST | 새로운 데이터를 제출합니다. | 요청 본문에 데이터를 포함하여 전송합니다. |
| PUT | 데이터를 저장하거나 업데이트합니다. | 요청 본문에 업데이트할 데이터를 포함하여 전송합니다. |
| DELETE | 데이터를 삭제합니다. | 요청 본문에 삭제할 데이터를 포함할 수 있지만, 일반적으로는 URL에 데이터를 포함하여 전송합니다. |
| PATCH | 리소스의 일부를 수정합니다. | 요청 본문에 수정할 데이터를 포함하여 전송합니다. |
| HEAD | 데이터를 요청하지 않고 응답 헤더만 반환합니다. | GET과 유사하지만, 데이터를 반환하지 않습니다. |
| OPTIONS | 서버에서 지원되는 HTTP 메서드 및 기능을 확인합니다. | CORS 요청에서 주로 사용되며, 클라이언트가 특정 리소스에 대해 어떤 메서드를 사용할 수 있는지 확인합니다. |
| TRACE | 서버로 보낸 요청을 다시 받아서 확인합니다. | 주로 디버깅 목적으로 사용되며, 클라이언트가 요청이 서버에서 어떻게 처리되는지 확인할 때 사용됩니다. |
| CONNECT | 목적지 서버로의 터널을 설정합니다. | 주로 프록시를 통해 암호화된 연결을 설정할 때 사용됩니다. |
- OPTIONS: 서버에서 지원되는 HTTP 메서드 및 기능을 확인하는 데 사용됩니다.
- TRACE: 요청이 서버에서 어떻게 처리되는지 확인하기 위해 주로 디버깅 목적으로 사용됩니다.

```jsx
# bad
GET /todos/delete/1
# good
DELETE /todos/1 
//메서드로 표현하고굳이 url에 행위를 넣지 않는 것이 좋음
```
