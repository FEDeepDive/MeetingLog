## 보경

 **동적타입언어 vs. 정적타입언어**

- 정적 타입 언어 : 코드 실행 이전에 모든 변수의 타입을 고정적으로 결정하는 언어(ex : c, java)
- 동적 타입 언어 : 코드 실행 이후 유동적으로 변수의 타입을 결정하는 언어(ex : js, python)

**타입스크립트란 ?**

유연한 자바스크립트가 타입으로 인한 버그로부터 더 안전하게 사용할 수 있도록 “타입 관련 기능들을 추가한 언어”이다.

**타입스크립트의 특징(장점)**

- JS 코드와 호환 가능하며, JS에 타입 시스템을 추가하여 타입관련 오류를 해결할 수 있다.
- 코드에서 객체와 함수의 모양을 한눈에 알아볼 수 있다.
- 코드 실행 전 검사를 통해 안정성을 확보하고, 자동으로 변수의 타입을 추론한다.

**type vs interface**

- **`type`** : 타입을 정의하는 키워드로 타입 별칭(type alias)이라고 한다. 객체, 유니언, 튜플 등 다양한 형태의 타입을 정의한다.
- **`interface`** : 타입을 정의하는 또 다른 방법으로 주로 객체 타입을 정의하는데 사용됨

**enum vs object**

- **`enum`** : 열거형 타입, 열거형 상수를 정의하는데 사용되며 컴파일 시 객체로 변환된다.
- **`object`** : 키-값을 가진 객체를 정의하는데 사용됨

## 미림

## 1. typescript 장점

### 정적 타입 검사 ⇒ 타입 에러 방지

JS는 컴파일 단계가 아니라 런타임에서 변수의 타입이 결정되는 `**동적 타입 언어**`이다. 따라서 변수를 실제 타입에 맞지 않게 사용하는 경우를 사전에 방지하기가 어렵다. 예를 들어 `number` 타입인 변수를 함수처럼 호출하도록 코드를 짜도, 실행하기 전에는 이 코드가 오류를 야기하는지 알 수 없다.

반면 TS는 컴파일 단계에서 타입을 결정하는 **`정적 타입 언어`**이다. 런타임에서의 에러를 방지하므로 **안정성**이 높고, 런타임에서 할 일이 줄어들기 때문에 그만큼 **실행 속도가 빠르다**. 또한 타입이 명시되어 있으므로 **코드를 읽을 때 역할과 동작을 유추하기 쉽다**.

### 타입 추론(자동으로 타입을 적용해줌)

```tsx
let foo = 123;
foo = '456'; // Error: cannot assign `string` to `number`
```

타입을 지정하지 않아도, 타입시스템이 타입을 추론하여 암시적으로 적용한다. 이러한 타입 추론을 잘 활용하면, **타입 명시를 생략하여 코드를 간결하게 유지**할 수 있다.

또 위 코드 예제처럼 컴파일 오류가 있더라도, 최대한 JS 코드를 반환한다.

---

### 동적 타입 언어

- 장점
    - 유연한 코드 작성
    - 타입 생략을 통한 높은 생산성
- 단점
    - 타입 에러를 미리 방지하지 못함

### 정적 타입 언어

- 장점
    - 타입 명시를 통한 높은 안정성
    - 사전 타입 명시를 통한 런타임 실행속도 향상
- 단점
    - 타입을 일일이 명시해야 하는 번거로움
    - 규모가 클수록 타입 선언이 차지하는 코드가 많아져 복잡함
    - 타입을 관리하는 어려움

## 2. type/interface 차이

### type alias (타입 별칭)

- 타입 집합을 특정 “별칭”에 할당할 수 있음
    
    ```tsx
    type User = { age: number };
    type Age = number;
    ```
    
- 에디터에서 마우스를 호버하면 타입 리터럴이 띄워짐
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/fa5f87f9-0506-4412-8f88-7932f8fd1ba1/Untitled.png)
    
- 인터페이스와 달리, 중복 선언 불가능

### interface (인터페이스)

- 타입 정의를 객체 꼴로만 할 수 있음
    
    ```tsx
    interface Item { price : number };
    interface Price: number; // 이런 식으로 쓸 순 없음!
    ```
    
- 에디터에서 마우스를 호버하면 인터페이스가 띄워짐
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/d57f00bd-1cfb-4370-9390-c3951f608b54/Untitled.png)
    
- Declaration Merging: 동일한 이름의 인터페이스끼리 병합되는 기능 ⇒ 확장성⬆️ 안정성⬇️
    
    ```tsx
    interface Item {
        price: number
    };
    
    // 똑같은 이름으로 선언 가능
    interface Item {
        name: string
    };
    
    // Property 'name' is missing in type '{ price: number; }' but required in type 'Item'.
    const item: Item = {
        price: 18000
    };
    ```
    

---

참고: `[type`과 `interface` 중 고민할 때 도움이 되었던 영상](https://youtu.be/Idf0zh9f3qQ?si=w4MpyU9MPv4S_0aR)

## 3. enum/object 차이

### Enums

- 이름이 있는 상수들의 집합을 정의할 때 사용
- 마우스 호버 시 enum이 띄워짐
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/a3817167-7643-4d10-b796-8ae45aeef459/Untitled.png)
    
- 예제
    - 숫자 열거형
        
        ```tsx
        enum Week {
          MON = 1,
          TUE, // 2
          WED, // 3
          THU,
          FRI,
          SAT,
          SUN, // 7
        }
        
        let day:Week;
        day = Week.MON; // assign value
        day = 1;        // same as Week.MON
        day = 'Hello';  // Error: Type '"Hello"' is not assignable to type 'Week'.
        let weekend: Week.SAT | Week.SUN; // possible to use enum member as type
        ```
        
        - 만약 초깃값이 없으면 `0`부터 시작함
    - 문자열 열거형
        
        ```tsx
        enum Direction {
          Up = "UP",
          Down = "DOWN",
          Left = "LEFT",
          Right = "RIGHT",
        }
        ```
        
    - 열거형 멤버를 숫자, 문자열뿐만 아니라 계산(ex. 함수호출)의 결과 등으로 초기화 가능
    - 한 enum 안에 다양한 타입의 멤버가 있을 수 있음

### Object

- 객체 타입으로, 객체를 구성하는 각 프로퍼티의 타입을 나타낼 수 있음
- 마우스 호버 시 객체 리터럴이 띄워짐
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/32c36b0c-d9b4-422e-9140-e6ff26fb9695/4618ffc1-25aa-48e1-a0cc-a7efa500b972/Untitled.png)
    
- `Object`로 `Enum`을 대체 가능
- `Enum` 사용 시 발생 가능한 성능 문제를 `Object`로 대체하여 해결 가능 ([TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking))

## 정욱

## 1. 타입스크립트의 장점

### 정적 타입 언어

정적 타입 언어는 변수의 타입이 컴파일 타임에 결정되는 언어로 다음과 같은 장점이 있다.

1. 실행 시간에 변수의 타입을 결정하기 위한 작업을 하지 않아도 되며, 타입에 대한 정보를 미리 제공하기 때문에 더 나은 최적화가 가능해져 실행 시 효율적이다.
2. 컴파일 타임에 타입 관련 에러를 검출할 수 있기 때문에 디버깅이 용이하다.
3. 코드의 구조를 엄격하게 정의할 수 있기 때문에 깔끔하고 읽기 쉬운 코드를 작성할 수 있다.

### TypeScript?

TypeScript는 정적 타입 언어이기 때문에 위에서 언급한 장점들을 가진다. 또한 정적 타입 사용으로 인해 현대적인 IDE에서 지원 가능한 툴링(코드 힌팅, 자동 완성, 리팩토링 지원 등)의 종류가 많아 생산성이 높다는 장점도 있다.

## 2. type/interface 차이

|  | type | interface |
| --- | --- | --- |
| 명칭(번역) | Type alias(타입 별칭) | Interface(인터페이스) |
| 사용 가능 타입 | 어떤 타입이든 가능 | 객체 타입만 가능 |
| 확장하는 법 | & 기호를 사용 | extends 키워드를 사용 |
| 이미 있는 타입에 필드 추가 | 불가능 | 가능(선언 병합) |

공식 문서에서는 ‘타입 별칭이 필요해지기 전까지 인터페이스를 사용하라’고 한다.

Union 타입이나 Intersection 타입을 활용해 두 개 이상의 타입을 조합해야 하는 경우에는 타입 별칭이 더 유용할 수 있고, 타입을 쉽게 확장하거나 병합해야 하는 경우에는 인터페이스가 더 유용할 수 있다.

## 3. enum/object 차이

### `enum`

`enum`은 서로 연관된 상수의 집합으로, 흔히 ‘열거형’으로 번역된다. TypeScript에서 `enum`은 크게 숫자형과 문자열형의 두 가지로 구분된다. 그 자체가 타입으로 사용될 수 있어 별도로 타입 지정을 해줄 필요가 없다. 객체와 비슷하게 `Object.keys`와 `Object.values`를 이용한 순회가 가능하다.

### `object as const`

할당된 값 그 자체를 타입으로 취급하는 것을 리터럴 타입이라고 부르는데, 객체 선언 시 `as const`를 붙여줄 경우 해당 객체의 각 프로퍼티는 선언 시에 사용된 값과 동일한 리터럴 타입을 가지게 된다.

|  | enum  | object as const |
| --- | --- | --- |
| 사용되지 않는 코드 컴파일 타임에 삭제(Tree-shaking) | 불가능(const로 선언 시 가능) | 가능 |
| 컴파일 후 코드 크기 | 비교적 큼 | 비교적 작음 |

## 영은

## 1.타입스크립트의 장점

- 자바스크립트의 가장 큰 특징중 하나가 동적타입의 언어라는 점이다.
    - **동적타입 언어**란? 
    변수에 타입을 명시적으로 지정하지 않고 코드가 실행되는 런타임에 변숫값이 할당될 때 해당 값의 타입에 따라 변수 타입이  결정된다는 것을 의미.
    - 한계
    유연하다는 장점이 있지만 이런 타입 결정의 유연함은 실수를 야기 할 수 있게 된다.
    런타임에 타입이 결정되기 때문에 런타임 전에 오류를 찾기 힘들다. 이는 어플리케이션의 안정성을 저하시킨다.
    - 한계 극복 방안
    JSDoc,propTypes,다트 등 동적타입언어의 한계를 커버하기 위해 많은 방법이 나왔지만
    자스 스스로 인터페이스를 기술 할 수 있는 언어로 발전해야 한다는 목소리가 커졌다
- 타입스크립트의 등장
 마이크로소프트는 자바스크립트의 슈퍼셋 언어로 타입스크립트를 공개했다.
- 장점
안정성보장, 개발 생상성 향상, 협업에 유리함, 자바스크립트에 점진적으로 적용 가능

## 2. type/interface 차이

우리가 아는 객체의 타입은 object다 하지만 실무에서 사용하지는 않는다. 캑체를 타이핑하기 위해서는 타입스크립에서만 독자적으로 사용할 수 있는 키워드를 사용하는게 일반적이다.
주로 type/interface 라는 키워드를 사용한다.

| 구분 | Type | Interface |
| --- | --- | --- |
| 확장성 | 합집합, 교집합을 통한 조합 가능 | 다른 인터페이스를 확장 가능 |
| 재정의 | 한 번 선언 후 재선언 불가 | 같은 이름으로 여러 번 선언 가능, 자동 병합 |
| 구현 | 클래스가 구현 불가 | 클래스가 구현 가능 |
| 유연성 | 더 복잡한 구조 조합에 유리 | 구조적 확장에 유리 |
| 사용 사례 | 복잡한 타입의 조합이 필요할 때 사용 | 객체 지향 프로그래밍 패턴에 사용 |

+) [회사에서 type 키워드를 사용하다가 성능이 너무 느려져서 interface로 바꿨던 사례](https://www.totaltypescript.com/react-apps-ts-performance)

## 3.enum/object 차이

가장 큰 차이는 enum은 정해진 상수들의 집합으로 컴파일 시에 모든 값이 결정되는 것이다

| 특징 | Enum (열거형) | Object (객체) |
| --- | --- | --- |
| 정의 | 상수의 집합을 정의하는 자료형. | 클래스의 인스턴스. |
| 사용 목적 | 제한된 수의 상수 값을 정의 및 사용. | 데이터 구조와 기능을 캡슐화하여 동적 인스턴스 생성. |
| 타입 안전성 | 컴파일 시 모든 값이 고정되며 타입 안전성이 보장됨. | 런타임에 타입 체크가 이루어지며 유연함. |
| 인스턴스 생성 시기 | 컴파일 타임에 모든 인스턴스가 생성됨. | 런타임에 인스턴스가 생성됨. |
| 확장성 | 다른 클래스를 상속할 수 없으며, 기본적으로 Enum 클래스 상속. | 다른 클래스를 상속할 수 있고, 인터페이스를 구현할 수 있음. |
| 메서드 정의 | 메서드를 포함할 수 있으며, 각 인스턴스는 동일 메서드 공유. | 클래스에 따라 다양한 메서드를 정의하고 객체별로 상태가 있음. |
| 상태 보유 | 상수 값 이외의 상태를 추가로 보유하기 어려움. | 동적으로 상태를 가질 수 있으며, 상태를 변경할 수 있음. |
